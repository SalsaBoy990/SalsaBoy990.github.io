<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gulácsi András</title>
    <description>Gulácsi András vagyok, Frontend/JavaScript Developer, természettudós és író. A blogommal a földrajzot egy új szemléletben egyesítem az informatikával és a webfejlesztéssel.
</description>
    <link>http://localhost:4000</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>A Big Data és a felhő alapú számítástechnika a földrajzban</title>
        <description>&lt;h2 id=&quot;mi-az-a-big-data&quot;&gt;Mi az a Big Data?&lt;/h2&gt;

&lt;p&gt;Néhány részletet idézek az IT Services Hungary &lt;a href=&quot;https://www.it-services.hu/hirek/mi-az-a-big-data/&quot;&gt;honlapján&lt;/a&gt; megjelent cikkből:&lt;/p&gt;

&lt;p&gt;A „Big Data” („Nagy Adat”) a cégek, az intelligens hálózatok, a magánszektor és az egyéni felhasználók által világszerte és napi szinten előállított óriási adatmennyiséget jelenti. Strukturáltan és kielemezve ez a rengeteg információ nagy hasznot hozhat a cégek és ügyfelek számára.&lt;/p&gt;

&lt;p&gt;A megfelelően felhasznált „Big Data” magyarázatot adhat a felhasználók fogyasztói és információs viselkedésére, segítséget nyújthat piacok felméréséhez, javíthatja a marketing- és értékesítési kampányokat, támogatást adhat az árképzésnél és optimalizálhatja a logisztikai folyamatokat és az árufolyamot.&lt;/p&gt;

&lt;p&gt;A „Big Data” analitika az az eszköz, amely segít az adattömeget összegyűjteni, integrálni és elemezni –  majd a vállalkozások számára felhasználhatóvá tenni.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Sven Löffler&lt;/em&gt;-t, a T-Systems Üzleti Intelligencia és Big Data üzletfejlesztési igazgatóját kérdeztük a „Big Data” és a felhő kapcsolatáról, továbbá a „3V”-ről.&lt;/p&gt;

&lt;h3 id=&quot;löffler-úr-hogyan-jellemezné-a-big-data-t&quot;&gt;Löffler úr, hogyan jellemezné a „Big Data”-t?&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Sven Löffler&lt;/strong&gt;: A Big Data-nak három jellemzője van: mennyiség (volume), sebesség (velocity) és változatosság (variety). Erre szoktunk úgy utalni, hogy a „3V”. A mennyiség a másodpercenként előállított hatalmas adatözönre vonatkozik. A sebesség azért fontos kérdés, mert az adatok nem halmazokban jönnek, hanem folyamatosan áramolnak. Mindig gyorsabban és gyorsabban kell őket feldolgozni, és lehetőleg valós időben. Végül pedig az egyik legnagyobb kihívást a változatosság jelenti, mert az egyes adatokat strukturálni kell és egymással összefüggésbe hozni, a forrásra való tekintet nélkül. A cél a kontrollálatlan adatfolyamok formázása az értékes információk kinyeréséhez. Ez végső soron hozzásegíthet minket üzleti döntések meghozatalához, és hosszú távú versenyelőnyök megszerzéséhez.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;pontosan-hogy-kapcsolódik-a-felhő-és-a-big-data&quot;&gt;Pontosan hogy kapcsolódik a felhő és a big data?&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Löffler&lt;/strong&gt;: Nagyon egyszerűen fogalmazva: felhő nélkül nincs Big Data. Az internet és a felhő – magánéletünk fokozódó digitalizációja és az üzleti folyamatok virtualizálásának térhódítása – egyszerre teszik szükségessé és lehetővé a big datát. A felhő alapú számítástechnika az egyetlen lehetőség, hogy támogassuk a Big Data infrastruktúra-igényeit. Hatalmas tárolókapacitást és nagyteljesítményű szervereket és adatbázisokat kínál.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;adatfúzió-és-a-térbeli-adatok-feldolgozása&quot;&gt;Adatfúzió és a térbeli adatok feldolgozása&lt;/h2&gt;

&lt;p&gt;Az adatgyűjtés, adatfeldolgozás, adatelemzés és adatmegjelenítés egyre inkább áttevődik a felhő alapú megoldásokra.&lt;/p&gt;

&lt;p&gt;Az adatfúzió (data fusion) során a különböző forrásból származó adatokat összevonjuk vagy együtt kezeljük egy adott jelenség vagy valamilyen létező dolog (entitás) érzékelésére, azonosítására vagy jellemzésére egy valamilyen ismereteken alapuló keretrendszerben. Az adatfúzió célja független adatállományokból származó, különböző információkat hordozó változók összekapcsolása az egyes esetek szintjén. Ezáltal adott a lehetőség különálló információk együttes elemzésére (&lt;em&gt;Carl Reed&lt;/em&gt; 2010). A Google Earth Engine a földtudományi és távérzékelt adatokat fogja össze egy egységes rendszerbe.&lt;/p&gt;

&lt;p&gt;A „Big Data”-n belül kifejezetten a térbeli/távérzékelési adatok feldolgozásával, a &lt;a href=&quot;http://www.newgeographer.com/tudomany/2017/08/07/google_earth_engine_01.html&quot;&gt;Google Earth Engine&lt;/a&gt; (GEE) felhő alapú webalkalmazás - analitikai eszköz foglalkozom, a JavaScript nyelv erejével. Ezen felül JavaScript tutoriálokat is készítettem: &lt;a href=&quot;http://www.newgeographer.com/tudomany/2017/08/29/javascript_01.html&quot;&gt;a sorozat első része&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A „Big Data” tárolására és megosztásához egységes adatszabványokra van szükség, hiszen az adatok változatos forrásokból származnak, más formátumban állnak rendelkezésre. Ahhoz, hogy ezeket össze tudjuk kapcsolni, egy egységes, integrált rendszert kell felépíteni: egy internet felhőre van szükség. Egy ilyet épített fel a földi léptékű földrajzi és távérzékelt adatok feldolgozására a Google. A nagyvállalat hatalmas szerverparkokat üzemeltet erre a célra, amik óriási számítási teljesítményre képesek.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/bigdata/google_servers.jpg&quot; alt=&quot;A Google egyik szerverparkja&quot; class=&quot;medium&quot; /&gt;&lt;/p&gt;
&lt;figcaption&gt;2. kép: &lt;a href=&quot;https://i.ytimg.com/vi/1Ve5u7jfxds/maxresdefault.jpg&quot;&gt;Csendélet a Google egyik szerverparkjában.&lt;/a&gt; Persze a gépek keményen pörögnek. Komoly hűtőrendszer védi őket a besüléstől.&lt;/figcaption&gt;

&lt;h3 id=&quot;geojson-és-json&quot;&gt;GeoJSON és JSON&lt;/h3&gt;

&lt;p&gt;Több nemzetközi szabványt létezik a földrajzi adatokra. Mivel a JavaScripttel kiemelten foglalkozom, ezért először a szabad hozzáférésű &lt;a href=&quot;http://geojson.org/&quot;&gt;GeoJSON&lt;/a&gt;-t (JavaScript Object Notation, JSON) említem meg, ugyanis ezt extenzíven használja a GEE. Ez annyiban különbözik a hagyományos JSON-tól, hogy van egy geometria (&lt;code class=&quot;highlighter-rouge&quot;&gt;geometry&lt;/code&gt;) tulajdonsága, ami tartalmazza az adott objektum (pont, vonal, poligon) földrajzi koordinátáit tömbök formájában, a szabvány által megszabott módon. De egy egyszerű példán keresztül jobban szemléltethető ez:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;type&quot;: &quot;Feature&quot;,
    &quot;properties&quot;: {
      &quot;fovaros&quot;: &quot;Colombo&quot;,
      &quot;lakossag&quot;: 669700,
      &quot;orszag&quot;: &quot;Sri Lanka&quot;
    },
    &quot;geometry&quot;: {
      &quot;type&quot;: &quot;Point&quot;,
        &quot;coordinates&quot;: [
          79.88433837890625,
          6.931879889517218
        ]
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;properties&lt;/code&gt; tulajdonság a város főbb jellemzőit (név, lakosság, melyik ország fővárosa) tartalmazza, míg a &lt;code class=&quot;highlighter-rouge&quot;&gt;geometry&lt;/code&gt; tulajdonság a geometria típusát és a koordinátákat tartalmazza. Nagyon könnyű átalakítani egy JavaScript objektummá a &lt;code class=&quot;highlighter-rouge&quot;&gt;JSON.parse()&lt;/code&gt; metódussal:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// A GeoJSON-t minimalizálni kell egy sorba https://www.minifier.org/:
var szoveg = '{&quot;type&quot;:&quot;Feature&quot;,&quot;properties&quot;:{&quot;fovaros&quot;:&quot;Colombo&quot;,&quot;lakossag&quot;:669700,&quot;orszag&quot;:&quot;Sri Lanka&quot;},&quot;geometry&quot;:{&quot;type&quot;:&quot;Point&quot;,&quot;coordinates&quot;:[79.88433837890625,6.931879889517218]}}';

var telepules = JSON.parse(szoveg);
console.log(
  telepules.properties.orszag + ' fővárosa ' +
  telepules.properties.fovaros + ', melynek lakossága: ' +
  telepules.properties.lakossag + ' fő.'
);

// Természetesen vissza is alakítható:
var geojson = JSON.stringify(telepules);
console.log(geojson);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A JSON nagyon tömör és sokkal jobb választás, mint a régi XML formátum, ami tag-eket használ, ezért nagyon redundáns, hiszen a nyitó és a zárótag-ek kétszer tartalmazzák a tulajdonság nevét:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&lt;xmp&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
	&lt;type&gt;Feature&lt;/type&gt;
	&lt;properties&gt;
		&lt;fovaros&gt;Colombo&lt;/fovaros&gt;
		&lt;lakossag&gt;669700&lt;/lakossag&gt;
		&lt;orszag&gt;Sri Lanka&lt;/orszag&gt;
	&lt;/properties&gt;
	&lt;geometry&gt;
		&lt;type&gt;Point&lt;/type&gt;
		&lt;coordinates&gt;79.88433837890625&lt;/coordinates&gt;
		&lt;coordinates&gt;6.931879889517218&lt;/coordinates&gt;
	&lt;/geometry&gt;&lt;/xmp&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A kliens (a Google Earth Engine Kódszerkesztő) és a szerver közötti kommunikáció JSON-ba csomagoltan történik: a felhasználó kérést (&lt;code class=&quot;highlighter-rouge&quot;&gt;request&lt;/code&gt;) küld a szerver számára, hogy az végezze el az általunk megszabott műveletek sorozatát az adatbázisban található általunk meghatározott adatokra. A szerver ezt fogadja és elvégzi a feladatot, és JSON-ban válaszol (az eredményeket beleágyazza). A JSON-t a kliens dekódolja és megjeleníti. Ha hiba volt a kódunkban, akkor természetesen hibával tér vissza a szerver. Egyszerű, nem agysebészet.&lt;/p&gt;

&lt;p&gt;Hogy bebizonyítsam, hogy ez tényleg így van, írjuk be ezt a GEE Kódszerkesztőjébe (a hozzáféréshez regisztrálni kell, a részleteket lásd az egyik korábbi cikkemben), és futtassuk:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Az adatok kiválasztása: SRTM domborzatmodell
var image = ee.Image('CGIAR/SRTM90_V4');
// Hozzáadunk 10-et a domborzatmodell minden cellájához
var operation = image.add(10);
// Kiírjuk a konzolra a kérésünket szövegként (JSON)
print(operation.toString());
// A szerver válasza (JSON)
print(operation);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A kérésünk így néz ki (ezt küldjük a szerver számára):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;ee.Image({
  &quot;type&quot;: &quot;Invocation&quot;,
  &quot;arguments&quot;: {
    &quot;image1&quot;: {
      &quot;type&quot;: &quot;Invocation&quot;,
      &quot;arguments&quot;: {
        &quot;id&quot;: &quot;CGIAR/SRTM90_V4&quot;
      },
      &quot;functionName&quot;: &quot;Image.load&quot;
    },
    &quot;image2&quot;: {
      &quot;type&quot;: &quot;Invocation&quot;,
      &quot;arguments&quot;: {
        &quot;value&quot;: 10
      },
      &quot;functionName&quot;: &quot;Image.constant&quot;
    }
  },
  &quot;functionName&quot;: &quot;Image.add&quot;
})&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;print()&lt;/code&gt; függvénnyel az új objektum (kép) tulajdonságait kérdeztük le. A szerver hozzáadott 10-et a domborzatmodell minden egyes cellaértékéhez. Ezt nyilván el kell végeznie, hiszen akkor nem tudná kiiírni a létrehozott új kép tulajdonságait. A GEE-ben csak akkor küldjük el a kérést, ha explicite utasítást adunk rá. A példánkban a &lt;code class=&quot;highlighter-rouge&quot;&gt;print&lt;/code&gt; meghívásával ez teljesül. Így néz ki a szerver válasza (&lt;code class=&quot;highlighter-rouge&quot;&gt;POST response&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;type&quot;: &quot;Image&quot;,
  &quot;bands&quot;: [
    {
      &quot;id&quot;: &quot;elevation&quot;,
      &quot;data_type&quot;: {
        &quot;type&quot;: &quot;PixelType&quot;,
        &quot;precision&quot;: &quot;int&quot;,
        &quot;min&quot;: -32758,
        &quot;max&quot;: 32777
      },
      &quot;crs&quot;: &quot;EPSG:4326&quot;,
      &quot;crs_transform&quot;: [
        0.0008333333535119891,
        0,
        -180,
        0,
        -0.0008333333535119891,
        60
      ]
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Eredményül kaptuk az új objektumunk tulajdonságait. Látható, hogy a kérés és a válasz is JSON. Na, röviden így működik a Google Earth Engine. A számításnak persze nem sok értelme volt, de itt a működés megértésén volt a hangsúly.&lt;/p&gt;

&lt;h3 id=&quot;ogc-szabványok&quot;&gt;OGC szabványok&lt;/h3&gt;

&lt;p&gt;Igazából ezzel nem kívánok nagyon részletesen foglalkozni, de azért megemlítem ezeket, hogy halljatok még egy kicsit erről is.&lt;/p&gt;

&lt;p&gt;Az Open Geospatial Consortium (OGC) egy 1994-ben alapított globális ipari konzorcium. Az OGC nyilvánosan elérhető térinformatikai felület szabványokat (geospatial interface standards) és kódolásokat fejleszt, tesztel és dokumentál az információs és kommunikációs iparban való használatra (&lt;em&gt;Carl Reed&lt;/em&gt; 2010).&lt;/p&gt;

&lt;p&gt;Az OGC célja, hogy a térbeli erőforrások kereskedelmi és intézményi folyamatokba való integrálásából származó társadalmi, gazdasági és tudományos előnyöket a legteljesebben kihasználjuk. 2013-ban több mint 475 tagja van (térinformatikai szoftver forgalmazók, kormányzati ügynökségek és egyetemek). Az ODC együttműködik más szabványosító szervezetekkel is mint például az ISO-val (International Organization for Standardization) (&lt;em&gt;Carl Reed&lt;/em&gt; 2010).&lt;/p&gt;

&lt;p&gt;Számos OGC szabvány van használatban, ezek:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;OGC Web Map Service (WMS) Interface&lt;/strong&gt;: Egyszerű HTTP (HyperText Transfer Protocol) interfész georeferált képek lekérdezésére egy megosztott adattárból (szerver). Egy WMS-kérés definiálja a lekérdezni kívánt réteget és területet. A szerver válaszként visszaküldi a lekérdezett képeket (JPEG, PNG stb. formátumban), amit a böngészőalkalmazás meg tud jeleníteni. A WMS egy adatmegjelenítő felület.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Web Coverage Service (WCS) Interface&lt;/strong&gt;: Standard interfész és műveletek, amelyek hozzáférést biztosítanak raszteres fedvényekhez (műholdkép, légifotó, DEM). Szintén HTTP-n keresztül (a metaadatokat és a fedvényeket is elküldi valamilyen bináris formátumban - GeoTiFF, NetCDF stb.). A WCS az adatok letöltésére szolgál.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Sensor Observation Service (SOS) Interface&lt;/strong&gt;: Szabványosított felületet biztosít a metaadatok és a megfigyelések kezelésére és kinyerésére a különféle érzékelő (szenzor) rendszerekből.
Pl. in-situ szenzorok (pl. vízmércék), mozgó szenzoros platformok (automata UAV-k), szenzorok hálózata (pl. szeizmikus mérések) stb.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Web Processing Service (WPS) Interface&lt;/strong&gt;: Szabványosított felület, ami bármilyen algoritmus, számítás és modell publikálását lehetővé teszi, ami térbeli adatokon elvégezhető. Az ügyfél számára GIS funkcionalitást nyújt a hálózaton keresztül. Az ügyfél számára elérhetővé teszi, hogy használják az algoritmusokat és a modelleket a saját adataikon. Tehát végrehajthatnak előre leprogramozott műveleteket: a bemenő adatokat megadva futtatják a modelleket, és készen megkapják a modellfuttatás eredményét, amit felhasználhatnak a saját céljaikra. Ez nem igényel nagy háttértudást az ügyfél részéről.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/bigdata/GITEWS_1.jpg&quot; alt=&quot;GITEWS - Német-Indonéz Cúnami Korai Riasztási Rendszer.&quot; class=&quot;medium&quot; /&gt;&lt;/p&gt;
&lt;figcaption&gt;1. ábra: &lt;a href=&quot;http://www.marinebuzz.com/2008/12/27/indonesia-has-reliable-german-indonesian-tsunami-early-warning-system-gitews/&quot;&gt;A Német-Indonéz Cúnami Korai Riasztási Rendszer.&lt;/a&gt; Példa egy működő Sensor Observation Service (SOS) rendszerre.&lt;/figcaption&gt;

&lt;h2 id=&quot;a-big-data-árnyoldala&quot;&gt;A Big Data árnyoldala&lt;/h2&gt;

&lt;p&gt;A három kulcskérdés itt a titoktartás, az adatok eredete és minősége.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Titoktartás&lt;/strong&gt;: az emberek napi mozgása a mobileszközökön keresztül folyamatosan nyomon követhető, személyük beazonosítható, viselkedésük elemezhető. Már szinte az összes okoseszköz gyűjt valamiféle információt a felhasználóról, ami sértheti a személyiségi jogokat. Nincs ez másként a felhő alapú megoldásoknál sem.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Az adatok eredete&lt;/strong&gt;: ha az adatok hivatalos forrásból származnak (állami, magánszektor), akkor szinte biztosan rendelkezésre áll rendes leíró adat vagy metaadat (ilyen például az adat forrása, hogy ki állította össze az adatokat, információ az adatfrissítésekről, milyen célból készült az adatgyűjtés stb.). Azonban a crowd-sourcing és az állampolgári adatgyűjtéseknél ezek hiányoznak, így bizonytalanok vagy megbízhatatlanok lehetnek az így nyert adatok.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Adatminőség&lt;/strong&gt;: hivatalos források esetén van információ az adatok minőségéről: például a lépték, a mérések pontossága, a mérések precizitása, kalibráció, a hibák halmozódása (error propagation) a származtatott termékben. Az állampolgárok, de különösen a “civil” szervezetek (vagy inkább politikai/gazdasági lobbicsoportok) által készített adatgyűjtések nem igazán megbízhatóak.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;felhasznált-irodalom&quot;&gt;Felhasznált irodalom&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;Carl Reed&lt;/em&gt; (2010). OGC Standards and Geospatial Big Data. – In. &lt;em&gt;Hassan A. Karimi&lt;/em&gt; (szerk.): Big Data: Techniques and Technologies in Geoinformatics. CRC Press, Boca Raton, USA. pp. 279-289.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developers.google.com/earth-engine/concepts_overview&quot;&gt;Google Earth Engine API kézikönyv.&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 05 Nov 2017 18:04:00 +0100</pubDate>
        <link>http://localhost:4000//tudomany/2017/11/05/big_data.html</link>
        <guid isPermaLink="true">http://localhost:4000//tudomany/2017/11/05/big_data.html</guid>
      </item>
    
      <item>
        <title>A jövő évi tematika</title>
        <description>&lt;p&gt;Összeállítottam a 2018-as tematikát. Egy-két írás talán már most decemberben elkészül.&lt;/p&gt;

&lt;p&gt;A JavaScript tutoriálokat is át fogom dolgozni, ugyanis apróbb pontatlanságok vannak bennük és persze folytatni fogom a JavaScript sorozatot. Az ember a hibákból sokat tanul, és ez hatványozottan igaz a programozásra. A tutoriálok készítése rendkívül hasznos számomra, ugyanis ezzel jobban elmélyítem és rendszerezem az elsajátított tudást.&lt;/p&gt;

&lt;p&gt;Bízom benne, hogy mindenki talál számára érdekes és hasznos írásokat.&lt;/p&gt;

&lt;h2 id=&quot;íme-a-tervezett-blogbejegyzéseim-listája&quot;&gt;Íme, a tervezett blogbejegyzéseim listája:&lt;/h2&gt;

&lt;ul class=&quot;update&quot;&gt;
  &lt;li&gt;Mi áll a „zöldek” vegyszer- és GMO-ellenessége mögött?&lt;/li&gt;
  &lt;li&gt;Az élővilág és a kihalási hullámok. De hol vannak a tetemek?&lt;/li&gt;
  &lt;li&gt;Törzsi ösztön.&lt;/li&gt;
  &lt;li&gt;A nyugati kultúra válsága.&lt;/li&gt;
  &lt;li&gt;Gondolatok az abortuszról.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Tudományos&lt;/em&gt; szkepticizmus, kulturális ellenállás és tagadás a kulturális evolúció tükrében.&lt;/li&gt;
  &lt;li&gt;A radioaktivitás veszélyeinek eltúlozása. A lineáris, küszöbérték nélküli (LNT) modell tarthatatlansága.&lt;/li&gt;
  &lt;li&gt;Mitől jó üzlet a „megújuló” energia? Al Gore miért terjeszti a globális felmelegedés &lt;em&gt;körüli&lt;/em&gt; hisztériát? Mit mond az IPCC a klímaváltozás várható következményeiről (valószínűségek)?&lt;sup&gt;1&lt;/sup&gt;&lt;/li&gt;
  &lt;li&gt;A konzervativizmus közelebb áll a környezetvédelemhez, mint a globális „zöld” ideológia.&lt;/li&gt;
  &lt;li&gt;A legkegyetlenebb adó. A CO&lt;sub&gt;2&lt;/sub&gt; társadalmi költsége és haszna.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Nem feltétlenül ebben a sorrendben fognak megjelenni. Ezek közül néhány cikk a készülő kétrészes könyvem részét fogja képezni. Apropó, az első kötettel (kb. 200-250 oldal), ha minden a terv szerint halad, akkor 2018 őszére készülök el. Csak az éghajlatváltozásos fejezet nincsen kész (ez egyébként a legnehezebb), a többi közel kész állapotban van.&lt;/p&gt;

&lt;p&gt;Ezt a honlapot messzemenőkig fontosabbnak tartom az összes tudományos publikációmnál. Én úgy látom, hogy több értelme van közvetlenül az interneten megosztani az elemzéseimet (illetve a véleményemet), mint folyóiratokba irogani olyan cikkeket, amiket szinte senki nem fog elolvasni.&lt;/p&gt;

&lt;p&gt;A blogom 100%-ban független a magyar államtól, a Szegedi Tudományegyetemtől és a nagyvállalatoktól. Így aztán senki nem mondhatja meg nekem, hogy mit publikálhatok.&lt;/p&gt;

&lt;p&gt;Ha gondolod, iratkozz fel a &lt;a href=&quot;http://eepurl.com/c2wHQj&quot;&gt;hírlevelemre&lt;/a&gt; vagy kövesd a híreket a &lt;a href=&quot;https://www.facebook.com/newgeographer&quot;&gt;Facebook&lt;/a&gt;-on!&lt;/p&gt;

&lt;p class=&quot;footnote&quot;&gt;(&lt;sup&gt;1&lt;/sup&gt; Természetesen a médiában nap mint nap hallható klímahisztéria, vagy nevezhetnénk katasztrófabeszédnek, köszönőviszonyban sincsen azzal, amit az IPCC állít.)&lt;/p&gt;

</description>
        <pubDate>Wed, 01 Nov 2017 20:14:00 +0100</pubDate>
        <link>http://localhost:4000//hirdetmeny/2017/11/01/tematika_2018.html</link>
        <guid isPermaLink="true">http://localhost:4000//hirdetmeny/2017/11/01/tematika_2018.html</guid>
      </item>
    
      <item>
        <title>Az „ego” miatt…</title>
        <description>&lt;blockquote class=&quot;poem&quot;&gt;
&lt;p&gt;Az „ego” miatt épült fel a civilizáció és lett kapitalista.&lt;br /&gt;
Az „ego” miatt jött a kuruzslás helyére modern orvoslás:&lt;br /&gt;
Járványok és gyógyíthatatlan betegségek váltak múlttá.&lt;br /&gt;
Az „ego” miatt lett alacsony a csecsemőhalandóság s&lt;br /&gt;
nem hal meg minden hat nőből egy a szülés közben.
&lt;/p&gt;

&lt;p&gt;Az „ego” miatt nőtt meg a születéskor várható élettartam.&lt;br /&gt;
Az „ego” miatt jött el az a jólét, amit azok a képmutató zöldek,&lt;br /&gt;
akik a dolgozó embereket ostorozzák, ugyanúgy élveznek.&lt;br /&gt;
Az „egoisták” mindig többet akartak, és mennyi jót tettek&lt;br /&gt;
a világgal eközben.&lt;/p&gt;

&lt;p&gt;A naplopó „értelmiségiek” nem tettek le semmit az asztalra.&lt;br /&gt;
Nem úgy, mint a kiváló mérnökök és a tehetséges tudósok.&lt;br /&gt;
Az „egoisták” nagyszerű épületeket húztak fel, a művészeteket&lt;br /&gt;
felvirágoztatták, szólásszabadságot hoztak s a bűnözést letörték.&lt;/p&gt;

&lt;p&gt;„Egoisták” voltak azok, akik megtisztították a levegőt, a vizeket&lt;br /&gt;
és a vadvilágnak hatalmas területeket érintetlenül hagytak.&lt;br /&gt;
Nézz meg egy amerikai szénerőművet és vesd össze a kínai szmoggal!&lt;br /&gt;
Egyetlen egy „felvilágosult” utópista sem tagadhatja e tényeket.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/az_ego_miatt.jpg&quot; class=&quot;small&quot; alt=&quot;Ego kontra öko&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 23 Sep 2017 16:22:00 +0100</pubDate>
        <link>http://localhost:4000//egyeb/2017/09/23/az_ego_miatt.html</link>
        <guid isPermaLink="true">http://localhost:4000//egyeb/2017/09/23/az_ego_miatt.html</guid>
      </item>
    
      <item>
        <title>Rövid elméleti bevezető a JavaScript nyelvbe, 3. rész.</title>
        <description>&lt;p&gt;Az előző részben az írtam, hogy a végrehajtási kontextusban (execution context) (globális szinten vagy függvényen belül) a változók „felemelése” (hoisting) történik az első sorba. &lt;strong&gt;Ez a felemelés csak látszólagos&lt;/strong&gt;, mivel a JS motor fizikailag nem változtatja meg a változók helyét (a kód hányadik sorában lettek deklarálva)! Mi történik, amikor a böngészőben futtatjuk a kódunkat?&lt;/p&gt;

&lt;p&gt;Először a JS motor létrehozza a böngészőablakunkban a &lt;strong&gt;globális futtatási környezetet&lt;/strong&gt; (a globális objektumot, ami a Window objektumot és a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; értéket, ami a globális objektumra hivatkozik). Ezután a &lt;strong&gt;Syntax Parser&lt;/strong&gt; végigfut a kódunkon és megkeresi az összes &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;-t és &lt;code class=&quot;highlighter-rouge&quot;&gt;function&lt;/code&gt;-t. A következő, &lt;strong&gt;létrehozási fázisban&lt;/strong&gt; (creation phase) a JS motor lefoglalja a memóriát a változóink/objektumaink számára, értéküket ideiglenesen &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;-ra állítja (az értékeket majd később fogjuk definiálni). A kódunk még mindig nem futott le, de már létrejöttek azok a változók, amiket majd használni fogunk.&lt;/p&gt;

&lt;p&gt;Ezután jön a &lt;strong&gt;futtatási fázis&lt;/strong&gt;, amikor a JS értelmező végrehajtja az utasításokat. A JS nyelv egy menetben (single threaded) és szinkron módban (synchronous) futtatja a kódot. Egyszerre csak egy sort, illetve utasítást hajt végre.&lt;/p&gt;

&lt;p&gt;Mint írtam, a futtatási szakasz előtt már léteznek a memóriában a változóink, értékük &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;, tehát hozzájuk férünk még azelőtt, hogy értéket adtunk volna nekik az &lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; operátorral. Ezért tűnik úgy, mintha felemelődnének. Ez a JS motor működésének a következménye. Így most már jobban érthető az alábbi kódrészlet:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;console.log(a); //-&amp;gt; undefined lesz.
var a = 7;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A JS ezt a valóságban nem fogja átírni erre:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var a;
console.log(a); //-&amp;gt; undefined lesz.
a = 7;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Arról van itt szó, hogy a kódunk futtatása előtt már lefoglalódnak a változóink, objektumaink a memóriában, tehát a &lt;code class=&quot;highlighter-rouge&quot;&gt;console.log()&lt;/code&gt; segítségével már hozzáférünk az értékükhöz (&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;) még azelőtt, míg mi értékül adnánk valamit a változónknak. Ennyi és nem több. Semmi &lt;strong&gt;tényleges&lt;/strong&gt; felemelődés nem történik!&lt;/p&gt;

&lt;p&gt;A JavaScript gyengén típusos nyelv, tehát &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;-ral lefoglalt változóink típusa a kódunk futtatásakor dől el és futás közben változhat. A JS a szabvány szerint megállapítja a változóink típusát és gondoskodik az adattípusok közötti konverzióról.&lt;/p&gt;

&lt;p&gt;Térjünk át most a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; érték és annak eredetének boncolgatására, majd utána a bezárással (closure), a privát hozzáféréssel és az egymásba ágyazott függvényekkel fogunk foglalkozni.&lt;/p&gt;

&lt;h2 id=&quot;mi-a-this-honnan-származik&quot;&gt;Mi a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;, honnan származik?&lt;/h2&gt;

&lt;p&gt;Az előző részben egy félmondat erejéig megemlítettem, hogy a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; az éppen aktuális objektumpéldányra mutató referencia, amin keresztül hozzáférünk az éppen aktuális objektum tulajdonságaihoz. (Objektum: azonosító-érték párok gyűjteménye.) Ehhez lássunk egy könnyű példát:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* Ez egy pont osztály konstruktora. */
function Point(x, y) {
    this.x = x || 0;
    this.y = x || 0;

    this.print = function () {
        console.log(&quot;x: &quot; + this.x + &quot;, y: &quot; + this.y);
    };
}
// Az osztály példányosítása.
var o = new Point(10, 20);
o.print();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A konstruktor meghívásával példányosítjuk a &lt;code class=&quot;highlighter-rouge&quot;&gt;Point&lt;/code&gt; „osztályt”: létrehozunk egy &lt;code class=&quot;highlighter-rouge&quot;&gt;o&lt;/code&gt; nevű objektumot. Amikor meghívjuk a &lt;code class=&quot;highlighter-rouge&quot;&gt;print()&lt;/code&gt; metódusát, mi helyettesítődik be a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; helyére? Természetesen az aktuális objektumpéldány referenciája, vagyis az &lt;code class=&quot;highlighter-rouge&quot;&gt;o&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; kulcsszó ismerős lehet annak, akinek van tapasztalata a C++-szal vagy a Java-val.&lt;/p&gt;

&lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; eredetének a tisztázásához vissza kell térnünk a C nyelvhez, méghozzá a struktúrákhoz. A struktúrák olyan öszetett adatszerkezetek, amelyek különféle változókat fognak össze, kezelnek együtt. A struktúra (&lt;code class=&quot;highlighter-rouge&quot;&gt;struct&lt;/code&gt;) az osztály (&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;) ősének mondható. A struktúra-tagok hozzáférése alapértelmezetten publikus. Ez a rövid C kódrészletem rámutat a lényegre:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;locale.h&amp;gt;

/* Egy egyszerű struktúra megvalósítása C-ben. */
struct Kijelzo {
    // A kijelző oldalai.
    int szelesseg;
    int magassag;
};
void printKijelzo (struct Kijelzo *);

int main() {
    // Az ékezetes karakterek miatt.
    setlocale(LC_ALL, &quot;hun&quot;);
    // A struktúra példányosítása.
    struct Kijelzo elso;
    // Kijelzo típusú mutató létrehozása
    struct Kijelzo *p;
    // A struktúra példányunk kezdőcímére mutat.
    p = &amp;elso;

    (*p).szelesseg = 1024;
    (*p).magassag = 768;
    printKijelzo(p);

    /* Helyette ezt is írhatnám: */
    p-&amp;gt;szelesseg = 1280;
    p-&amp;gt;magassag = 1024;
    printKijelzo(p);

    getchar();
    return 0;
}
void printKijelzo (struct Kijelzo *ptr) {
    printf(&quot;A kijelző szélessége: %d, magassága: %d\n&quot;,
        ptr-&amp;gt;szelesseg, ptr-&amp;gt;magassag);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Magyarázat: egy &lt;code class=&quot;highlighter-rouge&quot;&gt;struct Kijelzo&lt;/code&gt; típusú struktúrát jelölő mutatót hoztam létre &lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt; néven. Ha &lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt; egy &lt;code class=&quot;highlighter-rouge&quot;&gt;Kijelzo&lt;/code&gt; struktúrát címez, akkor &lt;code class=&quot;highlighter-rouge&quot;&gt;*p&lt;/code&gt; maga a struktúra (memóriacím, ahol &lt;code class=&quot;highlighter-rouge&quot;&gt;elso&lt;/code&gt; megtalálható), és &lt;code class=&quot;highlighter-rouge&quot;&gt;(*p).szelesseg&lt;/code&gt;, illetve &lt;code class=&quot;highlighter-rouge&quot;&gt;(*p).magassag&lt;/code&gt; az &lt;code class=&quot;highlighter-rouge&quot;&gt;elso&lt;/code&gt; struktúra tagjai. A zárójelre szükség van, mivel a &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt; struktúratag operátor precedenciája magasabb, mint a &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; operátoré. A szintaxis egyszerűsítésére vezették be a &lt;code class=&quot;highlighter-rouge&quot;&gt;-&amp;gt;&lt;/code&gt; nyíl operátort (balról jobbra köt).&lt;/p&gt;

&lt;p&gt;(A &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; operátor segítségével a mutató által mutatott memóriacímen található értéket érhetjük el. Az &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; operátor pedig a memóriacímek lekérdezésére használatos. Az &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;p&lt;/code&gt; a mutató memóriacímét adja vissza. A mutató memóriacímén egy másik változó, mutató, tömb stb. memóriacímét tároljuk el.)&lt;/p&gt;

&lt;p&gt;Természetesen egyszerűen használhatnánk a &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt; struktúra-adattag operátort is a struktúratagok lekérdezésére, így: &lt;code class=&quot;highlighter-rouge&quot;&gt;elso.szelesseg = 1920;&lt;/code&gt;. De mi a helyzet akkor, ha több száz struktúrapéldánnyal vagy struktúratömbökkel kell dolgoznunk? Ilyenkor sok hasznát vesszük a mutatóknak.&lt;/p&gt;

&lt;p&gt;A C++-ban a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; az osztály példányát jelölő (annak kezdőcímét tároló) belső mutató, amivel az osztály tagváltozóihoz és metódusaihoz hozzáférünk. Átírtam az előbbi példaprogramunkat C++-ba:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;locale.h&amp;gt;

using namespace std;

class Kijelzo {
private:
    int szelesseg;
    int magassag;
public:
    Kijelzo() {}; // Alapértelmezett konstruktor.
    // Saját konstruktor inicializálási listával.
    Kijelzo(int szelesseg, int magassag): 
        szelesseg(szelesseg), magassag(magassag) {};
    // Destruktor.
    ~Kijelzo() {};

    inline void printKijelzo() const {
        cout &amp;lt;&amp;lt; &quot;A kijelző szélessége: &quot; &amp;lt;&amp;lt; this-&amp;gt;szelesseg
        &amp;lt;&amp;lt; &quot;, magassága: &quot; &amp;lt;&amp;lt; this-&amp;gt;magassag &amp;lt;&amp;lt; endl;
    }
    inline void setSzelesseg(int x) { this-&amp;gt;szelesseg = x; }
    inline int getSzelesseg() const { return this-&amp;gt;szelesseg; }
    inline void setMagassag(int x) { this-&amp;gt;magassag = x; }
    inline int getMagassag() const { return this-&amp;gt;magassag; }
    void this_erteke() const;
};

int main()
{
    setlocale(LC_ALL, &quot;hun&quot;);
    // Az osztály példányosítása.
    Kijelzo elso(1024, 768);
    elso.printKijelzo();
    elso.setMagassag(600);
    cout &amp;lt;&amp;lt; elso.getMagassag() &amp;lt;&amp;lt; endl;

    Kijelzo *p;
    p = &amp;elso;
    cout &amp;lt;&amp;lt; p-&amp;gt;getSzelesseg() &amp;lt;&amp;lt; endl; //=&amp;gt; 1024

    elso.this_erteke();
    cin.get();
    return 0;
}
/* A this értékének kiírása. */
void Kijelzo::this_erteke() const {
    cout &amp;lt;&amp;lt; &quot;A this értéke: &quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; &lt;strong&gt;az osztály aktuális példányának&lt;/strong&gt; (az &lt;code class=&quot;highlighter-rouge&quot;&gt;elso&lt;/code&gt;-nek) &lt;strong&gt;a belső mutatója&lt;/strong&gt;, amivel a tagváltozókat és a tagfüggvényeket (más szóval metódusokat) érhetjük el a &lt;code class=&quot;highlighter-rouge&quot;&gt;-&amp;gt;&lt;/code&gt; (nyíl) operátor segítségével. Ez egy valódi mutató, amit a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; kulcsszóval helyettesítünk és jelen esetben az &lt;code class=&quot;highlighter-rouge&quot;&gt;elso&lt;/code&gt; osztálypéldány címére mutat. Figyeljétek meg jobban a példaprogramot: létrehoztam egy &lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt; nevű mutatót, aminek értékül adtam az &lt;code class=&quot;highlighter-rouge&quot;&gt;elso&lt;/code&gt; memóriacímét. A &lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt; mutató használatával a &lt;code class=&quot;highlighter-rouge&quot;&gt;-&amp;gt;&lt;/code&gt; operátor segítségével is hozzáférek az osztálytagokhoz (természetesen a privát tagváltozókhoz nem férünk hozzá). A &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; pontosan egy ilyen mutató, csak ennek jelölésére bevezették a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; kulcsszót: &lt;code class=&quot;highlighter-rouge&quot;&gt;p-&amp;gt;szelesseg&lt;/code&gt; helyett &lt;code class=&quot;highlighter-rouge&quot;&gt;this-&amp;gt;szelesseg&lt;/code&gt;-et írunk. A program végén kiírtam a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; értékét, ami egy memóriacím.&lt;/p&gt;

&lt;p&gt;A JavaScript-ben szintén létezik a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;. A &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; &lt;strong&gt;az éppen aktuális objektumpéldányra hivatkozik.&lt;/strong&gt; A &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; egy &lt;strong&gt;referencia&lt;/strong&gt;. Mivel a JS-ben nincsen mutató, ezért nincs szükség a nyíl operátorra, helyette a &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt; operátorral érhetjük el az objektum tulajdonságait a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;-en keresztül, vagyis a &lt;code class=&quot;highlighter-rouge&quot;&gt;this.x&lt;/code&gt; a helyes szintaxis.&lt;/p&gt;

&lt;h2 id=&quot;a-bezárás-closure-a-privát-hozzáférés-és-a-beágyazott-függvények&quot;&gt;A bezárás (closure), a privát hozzáférés és a beágyazott függvények&lt;/h2&gt;

&lt;p&gt;A JavaScript-ben nem blokkhatókör van, hanem &lt;strong&gt;függvényhatókör&lt;/strong&gt;, tehát nem &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;/code&gt; segítségével tudunk lokális, kívülről nem hozzáférhető változókat bezárni, hanem &lt;code class=&quot;highlighter-rouge&quot;&gt;()&lt;/code&gt; használatával. Tetszőleges számú függvényhatókört (és végrehajtási kontextust) hozhatunk létre a &lt;code class=&quot;highlighter-rouge&quot;&gt;()&lt;/code&gt; zárójelpár segítségével. Ezt a technikát &lt;strong&gt;bezárásnak&lt;/strong&gt; nevezzük. A függvényen belül a &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; kulcsszóval deklarált változók privátak, vagyis kívülről nem elérhetők. A külső környezetben, tehát a függvényen kívül deklarált ugyanolyan nevű változókat elrejtik az aktuális függvényen belül deklarált változók (ha vannak ilyenek).&lt;/p&gt;

&lt;p&gt;Ez nem jelent több védelmet, mint amikor a C++-ban privát hozzáférést alkalmazok a &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt; kulcsszó segítségével. Az újabb JS-szabványok a jövőben majd támogatni fogják a &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;protected&lt;/code&gt; és a &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt; hozzáférési szinteket.&lt;/p&gt;

&lt;p&gt;Nézzünk néhány nagyon egyszerű példát:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function b() {
    console.log(myVar);
}
function a() {
    var myVar = 2;
    b();
}
var myVar = 1;
a(); // Mit fog kiírni?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nyilván az &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;-et fogja kiírni. Erre gondoltatok ti is? Az &lt;code class=&quot;highlighter-rouge&quot;&gt;a()&lt;/code&gt; függvényen belül deklarált &lt;code class=&quot;highlighter-rouge&quot;&gt;myVar&lt;/code&gt; hatóköre az &lt;code class=&quot;highlighter-rouge&quot;&gt;a()&lt;/code&gt; függvény. A másik &lt;code class=&quot;highlighter-rouge&quot;&gt;myVar&lt;/code&gt; változó nincs függvényen belül, tehát globális. A hatókör láncolatra kell itt visszaemlékeznünk. A &lt;code class=&quot;highlighter-rouge&quot;&gt;b()&lt;/code&gt; függvényünk külső környezete a globális végrehajtási környezet. A &lt;code class=&quot;highlighter-rouge&quot;&gt;b()&lt;/code&gt; függvény elsőként a saját hatókörén belül keresi a &lt;code class=&quot;highlighter-rouge&quot;&gt;myVar&lt;/code&gt;-t, de mivel itt nem találja, egy fölötte levő hatókörben, a globális hatókörben keresi tovább. Ez van a hatókörlánc legtetején. Itt található egy &lt;code class=&quot;highlighter-rouge&quot;&gt;myVar&lt;/code&gt; változó, és ennek az értékét írja ki a &lt;code class=&quot;highlighter-rouge&quot;&gt;b()&lt;/code&gt; függvény. Hiába az &lt;code class=&quot;highlighter-rouge&quot;&gt;a()&lt;/code&gt; függvényen belül hívtuk meg. &lt;strong&gt;A lényeg, hogy fizikailag hol található a függvény deklaráció.&lt;/strong&gt; Csak erre figyeljetek!&lt;/p&gt;

&lt;p&gt;Ha a &lt;code class=&quot;highlighter-rouge&quot;&gt;b()&lt;/code&gt; függvényt az &lt;code class=&quot;highlighter-rouge&quot;&gt;a()&lt;/code&gt; függvényen belül deklaráltuk volna, akkor a külső környezete az &lt;code class=&quot;highlighter-rouge&quot;&gt;a()&lt;/code&gt; függvény lenne, az &lt;code class=&quot;highlighter-rouge&quot;&gt;a()&lt;/code&gt; függvényé pedig a globális futtatási környezet. Ebben az esetben a JS motor elsőként a &lt;code class=&quot;highlighter-rouge&quot;&gt;b()&lt;/code&gt;-ben keresné a &lt;code class=&quot;highlighter-rouge&quot;&gt;myVar&lt;/code&gt;-t, utána az &lt;code class=&quot;highlighter-rouge&quot;&gt;a()&lt;/code&gt;-ban és végül a globális környezetben. Ez a &lt;strong&gt;hatókörlánc&lt;/strong&gt;. Kicsit módosítva az előbbi kódot:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function a() {
    var myVar = 2;
    function b() {
        console.log(myVar);
    }
    b();
}
var myVar = 1;
a(); //=&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Az &lt;code class=&quot;highlighter-rouge&quot;&gt;a()&lt;/code&gt; függvényen belüli &lt;code class=&quot;highlighter-rouge&quot;&gt;myVar&lt;/code&gt; változó értékét írja ki a &lt;code class=&quot;highlighter-rouge&quot;&gt;b()&lt;/code&gt; függvény A függvény-definíció után természetesen egyszer meg kell hívunk a &lt;code class=&quot;highlighter-rouge&quot;&gt;b()&lt;/code&gt;-t. Azt nézzétek, hol található a függvénydeklaráció, mibe van beágyazva.&lt;/p&gt;

&lt;p&gt;Még egy példa:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var a = &quot;krumpli&quot;;
function szulo () {
    var b = &quot;körte&quot;;
    function beagyazott () {
        var c = &quot;paprika&quot;;
        console.log(a); //=&amp;gt; krumpli
        console.log(b); //=&amp;gt; körte
    }
    beagyazott();
    console.log(c); // Referenciahiba: c nincs definiálva.
}
szulo();

console.log(b); //=&amp;gt; Referenciahiba: b nincs definiálva.
console.log(c); //=&amp;gt; Referenciahiba: c nincs definiálva.
console.log(a); //=&amp;gt; krumpli
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A kódban a &lt;code class=&quot;highlighter-rouge&quot;&gt;beagyazott()&lt;/code&gt; függvényt ágyaztam be a &lt;code class=&quot;highlighter-rouge&quot;&gt;szulo()&lt;/code&gt; függvénybe, tehát így néz ki a hatókörlánc: &lt;code class=&quot;highlighter-rouge&quot;&gt;beagyazott()&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;szulo()&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;global&lt;/code&gt;. A legbelső függvény változóihoz kívülről nem fér hozzá a &lt;code class=&quot;highlighter-rouge&quot;&gt;szulo()&lt;/code&gt; függvény, sem pedig globálisan nem hozzáférhetők. Ez fordítva nem igaz! A &lt;code class=&quot;highlighter-rouge&quot;&gt;beagyazott()&lt;/code&gt; függvény hozzáfér a &lt;code class=&quot;highlighter-rouge&quot;&gt;szulo()&lt;/code&gt; változóihoz, valamint az összes globális változóhoz, hiszen végighalad az hatókör láncon a nyilak szerinti irányban. Viszont amikor a &lt;code class=&quot;highlighter-rouge&quot;&gt;szulo()&lt;/code&gt;-n belül megpróbáljuk a &lt;code class=&quot;highlighter-rouge&quot;&gt;beagyazott()&lt;/code&gt; függvény &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; változóját elérni, akkor referenciahibát dob a JS értelmező: nem találja a &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;-t. De hol keresi a &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;-t? A szülő függvényhez tartozó hatókör lánc: &lt;code class=&quot;highlighter-rouge&quot;&gt;szulo()&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;global&lt;/code&gt;. Tehát a külső, globális hatókörben keresi, de ott nem találja és ezért dob hibát. (A hibakezelésről egy későbbi részben lesz szó.)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Privát tulajdonságokat vagy változókat&lt;/strong&gt; függvénybe zárás és a &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; kulcsszó használatával hozhatunk létre:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function Hallgato(nev, eha, email) {
    var nev = nev;
    this.getNev = function() { return this.nev; };

    var eha_kod = eha;
    this.setEha = function(x) { this.eha_kod = x; };
    this.getEha = function() { return this.eha_kod; };

    this.email = email;
}
var sanyi = new Hallgato(
                        &quot;Petőfi Sándor&quot;,
                        &quot;PESAABT.SZE&quot;,
                        &quot;sanyi1848@freemail.hu&quot;
);
sanyi.eha_kod = &quot;ABCDEFG.SZE&quot;; //=&amp;gt; Hiba.
sanyi.email = &quot;sanyi1848@gmail.com&quot; 
console.log(sanyi.email); //=&amp;gt; sanyi1848@gmail.com
console.log(sanyi);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ha kiíratod a konzolra &lt;code class=&quot;highlighter-rouge&quot;&gt;sanyi&lt;/code&gt; tartalmát, akkor nem fogod látni a &lt;code class=&quot;highlighter-rouge&quot;&gt;nev&lt;/code&gt; és az &lt;code class=&quot;highlighter-rouge&quot;&gt;eha_kod&lt;/code&gt; tulajdonságát, hiszen a &lt;code class=&quot;highlighter-rouge&quot;&gt;console.log()&lt;/code&gt; nem fér hozzájuk! Csak a get és a set függvények láthatók. Csak ezeken keresztül, szabályozottan férhetünk hozzá ezekhez a tulajdonságokhoz. Tehát „illetéktelenek” nem férnek hozzájuk.&lt;/p&gt;

&lt;h2 id=&quot;a-beágyazott-függvények-és-a-this&quot;&gt;A beágyazott függvények és a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; érték a változókkal ellentétben nem kapcsolódik hatókörhöz és a beágyazott függvények sem férnek hozzá a befoglaló függvény &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; értékéhez. A &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;-nek mi nem adhatunk értéket, pl. a &lt;code class=&quot;highlighter-rouge&quot;&gt;this = obj;&lt;/code&gt; utasítás érvénytelen.&lt;/p&gt;

&lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; értéke nem fix a JS-ben, hanem futási időben, a függvényhíváskor dől el. Ha nem az &lt;code class=&quot;highlighter-rouge&quot;&gt;objektumnev.metodus()&lt;/code&gt; szintaxist használjuk, amikor a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; helyére az &lt;code class=&quot;highlighter-rouge&quot;&gt;objektumnev&lt;/code&gt; helyettesítődik be, hanem egy egyszerű függvény hívunk meg, akkor a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; a globális objektumra hivatkozik:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var obj = {
    id: &quot;egy objektum&quot;,
    method: function() {
        console.log(this);
    }
}
obj.method(); //=&amp;gt; az obj-ra hivatkozik

function f2() {
    console.log(this.toString()); // [object Window]
    console.log(this === window); //=&amp;gt; true
}
f2();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ha függvényeket ágyazunk egymásba, akkor a befoglaló függvényben el kell tárolnunk a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; értékét egy változóban, amit megegyezés szerint &lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt;-nek szokás elnevezni.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var obj = {
    elemek: [&quot;Gandalf&quot;, &quot;Aragorn&quot;, &quot;Legolas&quot;, &quot;Gimli&quot;],
    feldolgoz: function() {
        var self = this;
        this.elemek.forEach(function(elem) {
            self.kiir(elem);
        });
    },
    kiir: function(elem) {
        console.log('*' + elem + '*');
    }
};
obj.feldolgoz();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ha a &lt;code class=&quot;highlighter-rouge&quot;&gt;forEach&lt;/code&gt; cikluson belüli függvényben a &lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt; helyett a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;-t használtuk volna, akkor rossz objektumra hivatkoztunk volna, így a &lt;code class=&quot;highlighter-rouge&quot;&gt;kiir()&lt;/code&gt; meghívása sikertelen lett volna (a JS fordító típushibát dobna: a &lt;code class=&quot;highlighter-rouge&quot;&gt;this.kiir&lt;/code&gt; nem függvény). Ilyenkor a &lt;code class=&quot;highlighter-rouge&quot;&gt;kiir()&lt;/code&gt; függvény minden egyes meghívásakor a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; értéke nem a mi objektumunk, hanem a globális objektum lesz (szigorú módban pedig &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;)! A globális objektumnak pedig nincsen &lt;code class=&quot;highlighter-rouge&quot;&gt;kiir()&lt;/code&gt; nevű metódusa. Az első függvény, a &lt;code class=&quot;highlighter-rouge&quot;&gt;feldolgoz()&lt;/code&gt; meghívásakor a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; az &lt;code class=&quot;highlighter-rouge&quot;&gt;obj&lt;/code&gt;-ra hivatkozik. A &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; értékét eltároljuk a &lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt; változóban. A &lt;code class=&quot;highlighter-rouge&quot;&gt;forEach&lt;/code&gt; ciklus az &lt;code class=&quot;highlighter-rouge&quot;&gt;elemek&lt;/code&gt; tömb minden elemére meghív egy úgynevezett callback függvényt. Ebben a függvényben a &lt;code class=&quot;highlighter-rouge&quot;&gt;self.kiir(elem)&lt;/code&gt; szintaxissal hivatkozunk az &lt;code class=&quot;highlighter-rouge&quot;&gt;obj&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;kiir()&lt;/code&gt; metódusára, és mivel a &lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt; tartalma az &lt;code class=&quot;highlighter-rouge&quot;&gt;obj&lt;/code&gt;-ra hivatkozik, elérjük a függvényt.&lt;/p&gt;

&lt;p&gt;Egyelőre elég ennyi. A következő két részben foglalkozni fogok a kivételkezeléssel (exeption handling), a RegExp objektumokkal, a JSON-nal (JavaScript Object Notation) és a metóduslánccal (method chain). Végül a prototípusos öröklést mutatom be.&lt;/p&gt;

&lt;p&gt;Ezek után pedig rá fogok térni a funkcionális programozásra és a Google Earth Engine API (Application Programming Interface, vagyis alkamazásprogramozási felület) használatára.&lt;/p&gt;

&lt;h2 id=&quot;ajánlott-irodalom&quot;&gt;Ajánlott irodalom&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;Anthony Alicea&lt;/em&gt; (2015). &lt;a href=&quot;https://www.youtube.com/watch?v=Bv_5Zv5c-Ts&quot;&gt;JavaScript: Understanding the Weird Parts - The First 3.5 Hours.&lt;/a&gt; A teljes 12 órás kurzus az &lt;a href=&quot;https://www.udemy.com/understand-javascript/?utm_content=_._pd_364426_._&amp;amp;utm_source=facebook-row&amp;amp;utm_medium=udemyads&amp;amp;utm_campaign=NEW-FB-VRT-ROW-Tech-EN-ALL_._ci_._sl_ALL_._vi_._sd_All_._la_EN_.&amp;amp;utm_term=_._ag_NEW-FB-VRT-ROW-Tech-EN-ALL_._ci_._sl_ALL_._vi_._sd_All_._la_EN_._-_._ci_._._pi_1814585708581485_._gi_all_._ai_18--65_._an_M3oTyZ&amp;amp;k_clickid=97b08e8c-94fa-4830-ad99-8b6239fe4a0d_131994849&quot;&gt;udemy.com&lt;/a&gt;-on megtalálható. Néha van akció. Ilyenkor 10-15 euróért megvehető egy-egy kurzus, ami egyébként közel 200 euróba kerülne.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Brian W. Kernighan - Dennis M. Richie&lt;/em&gt;: A C programozási nyelv. 2. kiadás. - Műszaki Kiadó, Budapest.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Benedek Zoltán - Levendovszky Tihamér&lt;/em&gt; (2013). Szoftverfejlesztés C++ nyelven. SZAK Kiadó Kft., Bicske.&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 20 Sep 2017 16:37:00 +0100</pubDate>
        <link>http://localhost:4000//tudomany/2017/09/20/javascript_03.html</link>
        <guid isPermaLink="true">http://localhost:4000//tudomany/2017/09/20/javascript_03.html</guid>
      </item>
    
      <item>
        <title>Földrajzi adatfeldolgozás a parancssorban: a SAGA GIS és a GDAL</title>
        <description>&lt;p&gt;A SAGA mozaikszó a System for Automated Geoscientific Analyses (Automatizált Földtudományi Elemző Rendszer) rövidítése.
A &lt;a href=&quot;http://www.saga-gis.org/en/index.html&quot;&gt;SAGA GIS&lt;/a&gt; egy C++-ban írt szabad forráskódú térinformatikai szoftver. A legújabb, &lt;strong&gt;5.0&lt;/strong&gt;-ás verziót használtam a tutoriálhoz.&lt;/p&gt;

&lt;p&gt;A &lt;strong&gt;SAGA GIS térinformatikai szoftver&lt;/strong&gt; kifejlesztésének ötlete az 1990-es évek végén született meg a németországi Göttingeni Egyetem Természetföldrajzi Tanszékén. A tanszéken futó kutatási projektek középpontjában a raszteres adatok, azon belül is kifejezetten a digitális domborzatmodellek, elemzése volt, amit többek közt a talajtulajdonságok, terep által irányított folyamatok, valamint éghajlati paraméterek modellezésére, előrejelzésére használtak. A SAGA GIS-t tehát kifejezetten raszteres adatokfeldolgozására, elemzésére írták. A SAGA GIS fejlesztése &lt;em&gt;Jürgen Böhner&lt;/em&gt; és &lt;em&gt;Olaf Conrad&lt;/em&gt; vezetésével történt és történik napjainkban is.&lt;/p&gt;

&lt;p&gt;A kereskedelmi szoftverek közül az ERDAS Imagine ingyenes alternatívája lehet a SAGA GIS.&lt;/p&gt;

&lt;p&gt;A &lt;a href=&quot;http://www.gdal.org/&quot;&gt;GDAL&lt;/a&gt; (Geospatial Data Abstraction Library) egy szabad forrású földrajzi adatfeldolgozó szoftverkönyvtár, ami számos vektoros és raszteres adatokat manipuláló modult tartalmaz, amelyek a paranccssorban vagy valamilyen héjalkalmazáson (&lt;a href=&quot;https://trac.osgeo.org/osgeo4w/&quot;&gt;OSGeo4W Shell&lt;/a&gt;) keresztül érhetők el. A gépemen lévő változat a &lt;a href=&quot;http://www.qgis.org/hu/site/&quot;&gt;Quantum GIS (QGIS)&lt;/a&gt; szabad forráskódú térinformatikai szoftver mellett települ fel (ugyanis a QGIS is használja a GDAL moduljait), és az &lt;strong&gt;OSGeo4W Shell&lt;/strong&gt; héjalkalmazáson keresztül futtatom. A &lt;strong&gt;GDAL verzióm: 1.11.2&lt;/strong&gt; (2015. február 10.). A QGIS 2.8.1-Wien változatot telepítettem fel.&lt;/p&gt;

&lt;p&gt;A fenti verziójú alkalmazásokat használtam a parancssori szkriptek futtatására, tehát más verziókkal nem 100%, hogy tökéletesen működnek.&lt;/p&gt;

&lt;h2 id=&quot;1-adat-és-módszer&quot;&gt;1. Adat és módszer&lt;/h2&gt;

&lt;p&gt;Egy 15 éves 2000 és 2016 közötti műholdas adatsort használtam fel a parancssorban történő adatfeldolgozás demonstrálására. A NASA Terra műhold MODIS szenzorának &lt;a href=&quot;https://lpdaac.usgs.gov/dataset_discovery/modis/modis_products_table/mod13q1_v006&quot;&gt;250 méteres felbontású, 16 napos EVI és NDVI kompozitképeit&lt;/a&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;MOD13Q1: MODIS/Terra Vegetation Indices 16-Day L3 Global 250 m SIN Grid V005&lt;/code&gt;) dolgoztam fel a Duna-Tisza-közi erdőterületekre, melyeket az Európai Uniós &lt;a href=&quot;https://www.eea.europa.eu/publications/COR0-landcover&quot;&gt;CORINE&lt;/a&gt; (Coordination of Information on the Environment) felszínborítási adatbázis segítségével határolt le a témavezetőm (&lt;em&gt;Dr. Kovács Ferenc&lt;/em&gt;).
Az EU tagállamok nagyjából 6 évente felmérik a felszínborítás változásait különböző felszínborítási kategóriák szerint, 1:100 000-es méretarányban. A &lt;code class=&quot;highlighter-rouge&quot;&gt;CLC_2000&lt;/code&gt; (a 2000-05 közötti), a &lt;code class=&quot;highlighter-rouge&quot;&gt;CLC_2006&lt;/code&gt; (a 2006-11 közötti) és a &lt;code class=&quot;highlighter-rouge&quot;&gt;CLC_2012&lt;/code&gt; (2012-től kezdődő műholdképekre) adatok alapján lettek lehatárolva az erdők.&lt;/p&gt;

&lt;p&gt;Azokat a 250*250 méteres cellákat válogattuk le, aminek legalább 2/3 részét erdő borította. Külön vizsgáljuk a lomb-, a tűlevelű és az elegyes erdőket. A cél a vegetáció egészségi állapotának monitorozása, valamint trendszerű változásainak kimutatása a szárazodó Homokhátságon március vége és szeptember vége között. Az 1970-es évektől számítva a talajvízkút-hálózat mérései szerint átlagosan 3 méterrel süllyedt a régióban a talajvízszint (a magasabban fekvő térségekben ennél nagyobb csökkenés is megfigyelhető, de kizárólag csak ott).&lt;/p&gt;

&lt;p&gt;A 16 napos kompozitképeket úgy kell érteni, hogy a 16 nap alatt készült összes felvételből raknak össze egy képet: a legjobb minőségű, azaz tiszta, felhőktől mentes értékeket használják fel minden egyes cellára (képpontra). A legnagyobb hátulütője az optikai (a látható és az infravörös tartományban mérő) szenzoroknak, hogy a felhőkön nem látnak át, szemben a lézeres vagy radaros mérésekkel. A kompozit készítésével sokkal teljesebb adatokat kapunk, hiszen egy hosszabb időszakra nézve valószínűbb, hogy lesznek olyan felhőmentes képek, amelyek lefedik a földfelszín nagy részét, így használható információkhoz jutunk.&lt;/p&gt;

&lt;p&gt;Az &lt;strong&gt;EVI&lt;/strong&gt; (Enhanced Vegetation Index, Továbbfejlesztett Vegetációindex) és az &lt;strong&gt;NDVI&lt;/strong&gt; (Normalized Difference Vegetation Index, &lt;a href=&quot;https://www.agroinform.hu/gazdasag/hogyan-hasznosithatom-a-vegetacios-index-kepeket-demo-32500-001&quot;&gt;Normalizált Vegetációindex&lt;/a&gt;) spektrális index. A &lt;a href=&quot;http://www.geo.u-szeged.hu/~feri/kornyezeti_informatika/ch10s02.html&quot;&gt;spektrális indexek&lt;/a&gt; olyan származtatott mérőszámok, amelyek a műholdkép-sávokon (például látható kék, látható zöld, látható vörös, közeli, középhullámú és hosszúhullámú, azaz termális infravörös hullámhossz-tartományú sávok) végzett aritmetikai műveletek (osztás, szorzás, kivonás, összeadás) eredményeképpen állnak elő.&lt;/p&gt;

&lt;p&gt;A műholdkép sávok értékei reflektancia értékek, vagyis a különböző hullámhossz tartományokban mért, felszínre beérkező és onnan visszaverődő sugárzás hányadosai (0 és 1 közötti értékek lehetnek). Például a hófelszín a beérkező napsugárzás 90%-át veri vissza a látható hullámhossz-tartományban. Ezzel szemben a homok csak 30-40%-ot ver vissza, ezért nem csoda, hogy nyáron nagyon felforrósodik a tűző napon. A különböző felszínek/anyagok másképpen vernek vissza a különböző hullámhosszakon. Ez azért fontos, mert ennek segítségével jól el tudjuk határolni egymástól a felszínborítás-típusokat és feltérképezni a változásokat.&lt;/p&gt;

&lt;p&gt;A vegetációs indexek segítségével a levélzetben bekövetkező biológiai változásokat számszerűsíthetjük (cifrán mondva: kvantifikálhatjuk). Szoros kapcsolat áll fenn a levélzet klorofilltartalma és a vegetációs indexek értékei között. A vegetációs indexeket az 1970-es évek eleje óta használják a növényzet/biomassza változásainak értékelére (&lt;em&gt;Rouse, J. W. et al. 1973&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;A klorofill molekulák (klorofill-a és klorofill-b) a zöld színtestekben (kloroplasztisz) találhatók. A kloroplasztisz a szén-dioxidból és a vízből fény hatására cukrot (glükózt) állít elő. Ez a fotoszintézis folyamata. A klorofill molekulák nagyon fontos szerepet töltenek be a növények energiatermelő folyamataiban, ugyanis ezek nyelik el (abszorbeálják) a látható vörös és kék tartományba eső napfényt. (A zöld tartományban viszont nagy a visszaverődés, és innen a levelek zöld színe.) Az így elnyelt fotonok energiáját összegyűjtik és továbbítják a fotoszintézis enzimei, fehérjéi felé.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Egészséges vegetáció&lt;/strong&gt; esetén magas a klorofilltartalom a levelekben. Ilyenkor &lt;strong&gt;a látható vörös tartományban nagyon alacsony a reflektancia&lt;/strong&gt; (a visszaverődés), hiszen a klorofill elnyeli a sugárzást. Ezzel szemben, a közeli infravörös tartományban reflektancia csúcs jelentkezik, ugyanis itt a levélzet erősen visszaverő. &lt;strong&gt;A vegetációindexek a vörös és a közeli infravörös sáv reflektanciaértékei közötti különbségen alapszanak.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A hosszan tartó szárazság, illetve aszály hatására&lt;/strong&gt; a növény nem jut elegendő vízhez, ezért a levelek elkezdenek sárgulni-barnulni, csökken a klorofill-tartalmuk, a fotoszintetikus aktivitás lecsökken. Ilyenkor &lt;strong&gt;a klorofill kevesebb vörös tartományú fényt nyel el, tehát a reflektancia itt megnő.&lt;/strong&gt; Ezzel együtt a közeli infravörös tartományban is csökken egy kicsit a reflektancia, vagyis &lt;strong&gt;kisebb lesz a különbség a két sáv értékei között.&lt;/strong&gt; A magasabb vegetációindex értékek nagyobb klorofill tartalmat, míg a kisebbek lecsökkent klorofilltartalmat jeleznek. Másképpen kifejezve, egyenes arányosság áll fenn az indexértékek és a fotoszintetikus aktivitás között.&lt;/p&gt;

&lt;p&gt;A vegetációs indexek esetén szokás normalizálást alkalmazni, amivel [-1; +1] intervallumba transzformáljuk az értékeket. Ez azért előnyös, mert különböző lejtőszög és megvilágítás hatásait kiküszöbölhetjük vele.&lt;/p&gt;

&lt;p&gt;Az &lt;a href=&quot;https://en.wikipedia.org/wiki/Enhanced_vegetation_index&quot;&gt;EVI index&lt;/a&gt; a hagyományos NDVI továbbfejlesztett, optimalizált változata, melynek számításához a közeli infravörös és a vörös sávok mellett a kék sávot is felhasználják azon célból, hogy javítsák a talaj háttérjeleket és csökkentsék a légköri befolyásokat, mint például az aeroszol szétszóródást.&lt;/p&gt;

&lt;p&gt;Itt vannak a vegetációindexek képletei:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NDVI = (NIR − Red) / (NIR + Red)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;EVI = G * ((NIR − Red) / (NIR + C1 * Red − C2 * Blue + L))&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ahol &lt;code class=&quot;highlighter-rouge&quot;&gt;NIR&lt;/code&gt; a közeli infravörös sáv (841-876 nm), &lt;code class=&quot;highlighter-rouge&quot;&gt;Red&lt;/code&gt; a látható vörös sáv (620-670 nm) és &lt;code class=&quot;highlighter-rouge&quot;&gt;Blue&lt;/code&gt; a látható kék sáv (459-479 nm).  nm: nanométer, &lt;code class=&quot;highlighter-rouge&quot;&gt;10^-9&lt;/code&gt; m. A korrekciós együtthatók értékei &lt;code class=&quot;highlighter-rouge&quot;&gt;C1 = 6&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;C2 = 2,5&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;L = 1&lt;/code&gt; és &lt;code class=&quot;highlighter-rouge&quot;&gt;G = 7,5&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;2-feldolgozás-a-parancssorban&quot;&gt;2. Feldolgozás a parancssorban&lt;/h2&gt;

&lt;p&gt;A Windows parancssorban úgynevezett &lt;a href=&quot;https://hu.wikipedia.org/wiki/K%C3%B6tegelt_%C3%A1llom%C3%A1ny&quot;&gt;kötegelt állományokat&lt;/a&gt; futtatok. Egyszerű és hatékony kis programokat lehet batch-ban írni. Az általában .cmd vagy &lt;strong&gt;.bat&lt;/strong&gt; kiterjesztésű kötegelt állományokat (angolból átvett néven &lt;a href=&quot;https://hu.wikipedia.org/wiki/Batch_programoz%C3%A1s&quot;&gt;batch fájlokat&lt;/a&gt;) Windows, OS/2, és MS-DOS rendszerekben szokták használni. Formailag egy szövegfájlhoz hasonlítanak, tartalmuk pedig parancsok (DOS/Windows parancsok) egymásutánja. Futtatásuk a tartalom sorról sorra való olvasásával történik például a &lt;strong&gt;cmd.exe&lt;/strong&gt;-vel a Windows operációs rendszer alatt. A SAGA GIS parancssorban is futtatható, de célszerű kötegelt fájlként futtatni az utasítások sorozatát.&lt;/p&gt;

&lt;h3 id=&quot;21-saga-gis-saga_cmd&quot;&gt;2.1. SAGA GIS (saga_cmd)&lt;/h3&gt;

&lt;p&gt;A SAGA GIS moduljai a parancssorban is elérhetők. Ha írunk egy programot vagy egy szkriptet, akkor mindig adjuk meg kommentekben, hogy mit csinál a program, milyen probléma megoldására írtuk! A batch-ban a &lt;code class=&quot;highlighter-rouge&quot;&gt;REM&lt;/code&gt; paranccsal tudunk kommentet elhelyezni a szkriptünkbe. Ezeket a számítógép parancsértelmezője figyelmen kívül hagyja. Az &lt;code class=&quot;highlighter-rouge&quot;&gt;ECHO&lt;/code&gt; (visszhang) parancs üzeneteket jelenít meg a kijelzőn (a kommenteket és a parancsokat). Alapértelmezetten &lt;code class=&quot;highlighter-rouge&quot;&gt;ON&lt;/code&gt; módban van (&lt;code class=&quot;highlighter-rouge&quot;&gt;ECHO ON&lt;/code&gt;), de ki is kapcsolható az &lt;code class=&quot;highlighter-rouge&quot;&gt;ECHO OFF&lt;/code&gt; paranccsal. Az &lt;code class=&quot;highlighter-rouge&quot;&gt;@&lt;/code&gt; jel azt a célt szolgálja hogy az &lt;code class=&quot;highlighter-rouge&quot;&gt;echo off&lt;/code&gt;-ot tartalmazó sorra is kikapcsolja a visszhangot. A parancsokat kisbetűsen és nagybetűsen is írhatjuk.&lt;/p&gt;

&lt;p&gt;He beírjátok a parancssorba, hogy &lt;code class=&quot;highlighter-rouge&quot;&gt;help&lt;/code&gt;, akkor kilistázza az összes parancsot és rövid leírásukat, valamint útmutatókat a használatukról. Ha pedig a &lt;code class=&quot;highlighter-rouge&quot;&gt;help parancs_neve&lt;/code&gt; sort írátok be, akkor még részletesebb magyarázatot kaptok a parancs használatáról. &lt;a href=&quot;https://www.tutorialspoint.com/batch_script/batch_script_quick_guide.htm&quot;&gt;Ezen a linken&lt;/a&gt; egy jó tutoriált találtok a batch használatáról.&lt;/p&gt;

&lt;p&gt;A helyi változók a felhasználó által megadott azonosítók, melyek az értékadás során jönnek létre. Értékadás a &lt;code class=&quot;highlighter-rouge&quot;&gt;SET&lt;/code&gt; parancs segítségével történik az alábbi szintaxis szerint: &lt;code class=&quot;highlighter-rouge&quot;&gt;SET azonosito = ertek&lt;/code&gt;. A helyi változók csak az adott programban érvényesek. A változók értéke rejtve marad, ha a visszhang ki van kapcsolva az &lt;code class=&quot;highlighter-rouge&quot;&gt;echo off&lt;/code&gt; parancs segítségével.&lt;/p&gt;

&lt;p&gt;A környezeti változók (például a &lt;code class=&quot;highlighter-rouge&quot;&gt;PATH&lt;/code&gt; a futtatható fájlok keresési útja) a gép működésére nézve fontos információkat tartalmaznak. A szkriptünkben külső programokat (a SAGA GIS moduljait) futtatunk. Ezeknek vannak bemenő parancssori argumentumai, amiket meg kell adni.&lt;/p&gt;

&lt;p&gt;Ahhoz, hogy hozzáférjünk a SAGA modulokhoz, ideiglenesen módosítanunk kell a &lt;code class=&quot;highlighter-rouge&quot;&gt;PATH&lt;/code&gt; környezeti változót, hogy az a &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;saga_cmd.exe&lt;/code&gt;&lt;/strong&gt; elérési útjára mutasson (&lt;code class=&quot;highlighter-rouge&quot;&gt;set PATH=%PATH%;g:\saga-5.0.0_x64\&lt;/code&gt;). Csak így tudjuk meghívni a programot. A &lt;code class=&quot;highlighter-rouge&quot;&gt;SETLOCAL&lt;/code&gt; parancs segítségével lokálissá tehetjük a &lt;code class=&quot;highlighter-rouge&quot;&gt;PATH&lt;/code&gt; változónkat, így csak a szkriptünkben lesz látható, vagyis kívülről nem lesz hozzáférhető.&lt;/p&gt;

&lt;p&gt;Évenként dolgozom fel az adatokat, tehát minden év esetén módosítani kell egy kicsit a változókat! Itt van a programom eleje:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-batch&quot;&gt;REM @ECHO OFF
REM *****************************************************************
REM Create mean and median images and clip them with polygons
REM Author: András Gulácsi
REM E-mail: admin@newgeographer.com
REM Date: September 10th, 2017
REM SAGA GIS és GDAL: Földrajzi adatfeldolgozás a parancssorban
REM http://www.newgeographer.com/tudomany/2017/09/16/parancssor_a_geoinformatikaban.html
REM *****************************************************************
REM *************** PATHS ******************
REM Path to saga_cmd.exe
SETLOCAL
set PATH=%PATH%;g:\saga-5.0.0_x64\

REM Path to working dir
SET WORK=g:\modis\2005\EOV_2005\ndvi\
SET RESULT=g:\modis\TEMP
SET SHAPES=g:\modis\
SET POLYGON=00_l_250_66sz_poli.shp
SET POSTFIX=_00_l
SET YEAR=2005
REM ****************************************
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Létrehoztam néhány fontos változót a fájlok elérési útjait/nevét eltárolva bennük. A &lt;code class=&quot;highlighter-rouge&quot;&gt;WORK&lt;/code&gt; a bemenő képfájlok (GeoTIFF-ben), a &lt;code class=&quot;highlighter-rouge&quot;&gt;SHAPES&lt;/code&gt; a bemenő shape fájlok elérési útvonala. A &lt;code class=&quot;highlighter-rouge&quot;&gt;RESULT&lt;/code&gt; az eredményfájlok kimenő útvonala, a &lt;code class=&quot;highlighter-rouge&quot;&gt;POLYGON&lt;/code&gt; a shape fájl neve, amivel kivágjuk a mintaterületet a képből. Ez egy poligon típusú vektoros állomány.&lt;/p&gt;

&lt;p&gt;A következő lépésben &lt;strong&gt;egy &lt;code class=&quot;highlighter-rouge&quot;&gt;FOR&lt;/code&gt; ciklus segítségével beolvassuk a bemenő fájlokat tartalmazó mappánkban található összes .tif állományt, majd átkonvertáljuk azokat a SAGA GIS saját fájlformátumába, .sgrd-be.&lt;/strong&gt; A &lt;code class=&quot;highlighter-rouge&quot;&gt;%WORK%&lt;/code&gt; helyére a &lt;code class=&quot;highlighter-rouge&quot;&gt;WORK&lt;/code&gt; változónk tartalma helyettesítődik be. A &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; az egy tetszőleges sztringet helyettesít, vagyis tetszőleges nevű, de .tif állományokat olvasunk be.&lt;/p&gt;

&lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;saga_cmd io_gdal 0&lt;/code&gt; parancs a SAGA GIS &lt;strong&gt;io_gdal&lt;/strong&gt; moduljának egyik eszközét hívja meg (raszter importálása). Ezután &lt;strong&gt;a parancssori argumentumokat&lt;/strong&gt; kell megadnunk: &lt;code class=&quot;highlighter-rouge&quot;&gt;-GRIDS&lt;/code&gt; (bemenő fájl), &lt;code class=&quot;highlighter-rouge&quot;&gt;-FILES&lt;/code&gt; (eredményfájl), &lt;code class=&quot;highlighter-rouge&quot;&gt;-TRANSFORM&lt;/code&gt; (transzformáció, ez nekünk nem kell). A &lt;code class=&quot;highlighter-rouge&quot;&gt;%%i&lt;/code&gt; az éppen aktuális fájl nevét jelöli. A továbbiakban a .sgrd fájlokkal dolgozunk. A &lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt; &lt;strong&gt;beszúrási jelre&lt;/strong&gt; azért van szükség, mert egy sorba kellene írni a parancsot, de a láthatóság kedvéért sortöréseket használtam. A &lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt; jel a sor végéhez hozzáfűzi a következő sort (a beszúrási jel és a rá következő újsor karakter törlődik). Fontos a sorköz a &lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt; előtt!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-batch&quot;&gt;FOR /F %%i IN ('dir /b %WORK%\*.tif') DO (

REM Tool: Import Raster
saga_cmd io_gdal 0 ^
-GRIDS=%WORK%\%%i.sgrd ^
-FILES=%WORK%\%%i ^
-TRANSFORM=0

)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A modulokról és azok használatáról a &lt;a href=&quot;http://www.saga-gis.org/saga_tool_doc/5.0.0/a2z.html&quot;&gt;SAGA GIS dokumentációban&lt;/a&gt; találhattok bővebb leírást.&lt;/p&gt;

&lt;p&gt;A raszterállományokra (grid-ek) statisztikákat (átlagképeket, szórást stb.) a &lt;strong&gt;Statistics for Grids&lt;/strong&gt; eszközzel számolhatunk. Argumentumként meg kell adni a bemenő grid-eket (amiket az előzőekben .sgrd-be alakítottunk át), valamint azokat a statisztikákat, amiket ki akarunk számolni (&lt;code class=&quot;highlighter-rouge&quot;&gt;-MEAN&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;-PCTL&lt;/code&gt;). A &lt;code class=&quot;highlighter-rouge&quot;&gt;-PCTL&lt;/code&gt; a percentilis rövidítése, ehhez tartozik egy másik argumentum (&lt;code class=&quot;highlighter-rouge&quot;&gt;-PCTL_VAL&lt;/code&gt;), ahol meg kell adni, hogy hányadik percentilist akarjuk kiszámítani. Az 50. percentilis a medián, ami egyébként az alapértelmezett érték, tehát meg sem kéne adnunk külön.&lt;/p&gt;

&lt;p&gt;Viszont van egy problémánk: évenként meg kell adnunk a 13 db kép teljes elérési útvonalát, amit begépelni kényelmetlen és időigényes volna. &lt;code class=&quot;highlighter-rouge&quot;&gt;FOR&lt;/code&gt; ciklust itt nem használhatunk. Ilyenkor mit tehetünk? Van egy fontos alapelvem, ami így szól: &lt;strong&gt;ha lehetséges, akkor mindig térj vissza egy olyan megoldáshoz, amit már ismersz!&lt;/strong&gt; Az Excelben mindenki ismeri a függvényeket. Az &lt;code class=&quot;highlighter-rouge&quot;&gt;ÖSSZEFŰZ()&lt;/code&gt; függvény segítségével könnyedén legenerálhatjuk az elérési utakat, és csak az éveket kell átírni. Az összefűzött szöveget pedig egyben bemásoljuk a szkriptünkbe. (Itt zárójelben megjegyzem, ha esetleg valamelyikőtök nem tudná, hogy a .bat fájlokat úgy szerkeszthetjük, hogy átírjuk a fájlkiterjesztést .txt-re.). A grid-ek elérési útvonalait &lt;code class=&quot;highlighter-rouge&quot;&gt;;&lt;/code&gt;-vel kell elválasztanunk egymástól.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/sagagis/excel.png&quot; class=&quot;large&quot; alt=&quot;Elérési utak, fájlnevek generálása az ÖSSZEFŰZ() függvény segítségével&quot; /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-batch&quot;&gt;REM Tool: Statistics for Grids

saga_cmd statistics_grid 4 ^
-GRIDS=%WORK%\NDVI2005081_eov_kiv.tif.sgrd;%WORK%\NDVI2005097_eov_kiv.tif.sgrd;%WORK%\NDVI2005113_eov_kiv.tif.sgrd;%WORK%\NDVI2005129_eov_kiv.tif.sgrd;%WORK%\NDVI2005145_eov_kiv.tif.sgrd;%WORK%\NDVI2005161_eov_kiv.tif.sgrd;%WORK%\NDVI2005177_eov_kiv.tif.sgrd;%WORK%\NDVI2005193_eov_kiv.tif.sgrd;%WORK%\NDVI2005209_eov_kiv.tif.sgrd;%WORK%\NDVI2005225_eov_kiv.tif.sgrd;%WORK%\NDVI2005241_eov_kiv.tif.sgrd;%WORK%\NDVI2005257_eov_kiv.tif.sgrd;%WORK%\NDVI2005273_eov_kiv.tif.sgrd ^
-MEAN=%RESULT%\atlag.sgrd ^
-PCTL=%RESULT%\median.sgrd ^
-PCTL_VAL=50
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ezután az átlag- és mediánképekből ki kell vágnunk az erdőterületeket a poligonok segítségével. Erre a &lt;code class=&quot;highlighter-rouge&quot;&gt;shapes_grid&lt;/code&gt; modul &lt;strong&gt;Grid vágása poligonnal&lt;/strong&gt; eszközét használjuk. Meg kell adni a bemenetet, a kimenetet, a poligonokat tartalmazó shape fájlt és az &lt;code class=&quot;highlighter-rouge&quot;&gt;-EXTENT&lt;/code&gt; argumentumot, ami a kimenő grid terjedelmét határozza meg. Mi ezt &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;-ra állítjuk. Ebben az esetben az eredeti terjedelmet megtartjuk. Ez az alapértelmezett beállítás:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-batch&quot;&gt;REM Tool: Clip Grid with Polygon

saga_cmd shapes_grid 7 ^
-INPUT=%RESULT%\atlag.sgrd ^
-OUTPUT=%RESULT%\atlag%POSTFIX%.sgrd ^
-POLYGONS=%SHAPES%\%POLYGON% ^
-EXTENT=0

saga_cmd shapes_grid 7 ^
-INPUT=%RESULT%\median.sgrd ^
-OUTPUT=%RESULT%\median%POSTFIX%.sgrd ^
-POLYGONS=%SHAPES%\%POLYGON% ^
-EXTENT=0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/sagagis/saga_results.png&quot; class=&quot;large&quot; alt=&quot;A mintaterületek sikeresen kivágva az átlagképből&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
Miután eredményül kaptuk a mintaterületünkre kivágott átlag- és mediánképeket, ki kell exportálnunk őket GeoTIFF-be. Ehhez megint csak az &lt;code class=&quot;highlighter-rouge&quot;&gt;io_gdal&lt;/code&gt; modult használjuk. A &lt;code class=&quot;highlighter-rouge&quot;&gt;-GRIDS&lt;/code&gt;-nél az exportálandó grid-et, a &lt;code class=&quot;highlighter-rouge&quot;&gt;-FILE&lt;/code&gt;-nál a kimenő fájlt adjuk meg:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-batch&quot;&gt;REM Tool: Export GeoTIFF

saga_cmd io_gdal 2 ^
-GRIDS=%RESULT%\atlag%POSTFIX%.sgrd ^
-FILE=%RESULT%\%YEAR%_atlag%POSTFIX%.tif

saga_cmd io_gdal 2 ^
-GRIDS=%RESULT%\median%POSTFIX%.sgrd ^
-FILE=%RESULT%\%YEAR%_median%POSTFIX%.tif

PAUSE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;PAUSE&lt;/code&gt; paranccsal megállítjuk a szkript futását, hogy ne lépjen ki azonnal a konzolból, hanem várja meg egy billentyű lenyomását, és utána lépjen ki. Ez olyan, mint amikor a C-ben a &lt;code class=&quot;highlighter-rouge&quot;&gt;system(&quot;PAUSE&quot;);&lt;/code&gt; utasítással tesszük ugyanezt. (Megjegyzendő, hogy C-ben &lt;a href=&quot;(http://www.cplusplus.com/articles/j3wTURfi/)&quot;&gt;nem ajánlom ezt a megoldást&lt;/a&gt;, mert erőforrásigényes, nem biztonságos és csak Windows rendszeren működik. Ennél sokkal egyszerűbb a &lt;code class=&quot;highlighter-rouge&quot;&gt;getchar()&lt;/code&gt;-t használni.)&lt;/p&gt;

&lt;p&gt;A következő részben pedig az idősorok számtani átlagát és egyéb statisztikai jellemzőjét exportáljuk ki szöveges fájlba.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;22-virtuális-raszter-készítése-gdal-ban&quot;&gt;2.2. Virtuális raszter készítése GDAL-ban&lt;/h3&gt;

&lt;p&gt;Először létrehozunk egy virtuális raszter (&lt;a href=&quot;http://www.gdal.org/gdal_vrttut.html&quot;&gt;.vrt fájl, a GDAL saját formátuma&lt;/a&gt;) fájlkatalógust, ami XML formátumban tartalmazza az együtt kezelt képfájlok leíró adatait, de magukat az adatokat nem. Ezt a virtuális rasztert fogjuk megnyitni a SAGA GIS-ben.&lt;/p&gt;

&lt;p&gt;Nyissunk az OSGeo4W héjalkalmazást és gépeljük be ezt a rövid parancsot egyben:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gdalbuildvrt -separate g:\modis\TEMP\raszter\layer_stack.vrt g:\modis\TEMP\raszter\*.tif&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/sagagis/shell.png&quot; class=&quot;medium&quot; alt=&quot;Az OSGeo4W Shell felülete: a gdalbuildvrt használati útmutatója kiíratva&quot; /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;-separate&lt;/code&gt; logikai argumentumot megadva külön sávokba helyezi a képeket (ha ezt lehagynánk, akkor virtuális mozaikot készítene nekünk a GDAL), utána következik a kimenet és a bemenet. Ebben a sorrendben! Az elérési útvonalakat pedig módosítsátok, ha szükséges.&lt;/p&gt;

&lt;p&gt;Indítsuk el a &lt;strong&gt;saga_gui.exe&lt;/strong&gt;-t, utána a menüsorban válasszuk ki a &lt;strong&gt;File -&amp;gt; Open&lt;/strong&gt; parancsot (vagy a mappa ikonra is kattinthatunk a fájl megnyitásához) és nyissuk meg a virtuális raszterünket (&lt;code class=&quot;highlighter-rouge&quot;&gt;layer_stack.vrt&lt;/code&gt;)! Utána navigáljunk el ide: &lt;strong&gt;Geoprocessing -&amp;gt; Spatial and Geostatistics -&amp;gt; Grids -&amp;gt; Save Grid Statistics to Table&lt;/strong&gt;. Nyissuk meg az eszközt! A &lt;strong&gt;Grid Systems&lt;/strong&gt;-nél adjuk meg grid rendszerünket (a raszter terjedelem és felbontás) a legördülő listából. Utána a &lt;strong&gt;Grids&lt;/strong&gt;-nél a &lt;code class=&quot;highlighter-rouge&quot;&gt;...&lt;/code&gt; gombra kattintva a felugró kéthasábos ablak bal oldali oszlopában válasszuk ki a képkötegünket és a dupla vagy a szimpla nyílra kattintva pakoljuk át a jobb oldali ablakba (így lesz kiválasztva), majd kattintsunk az oké gombra! A táblázat részt hagyjuk úgy, ahogy van. Végül válasszuk ki, hogy milyen statisztikákat számoljon a képekre, és kattintsunk az okéra.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/sagagis/saga_gui_1.png&quot; class=&quot;large&quot; alt=&quot;Grid statisztikák mentése táblázatba eszköz&quot; /&gt;
&lt;br /&gt;
A létrehozott táblázatra kattintsunk jobb egérgombbal és válasszuk ki a &lt;strong&gt;„mentés mint”&lt;/strong&gt; opciót és mentsük el .txt formátumba. Ez utána könnyedén beilleszthető az MS Excel-be vagy más táblázatkezelő szoftverbe.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/sagagis/saga_gui_2.png&quot; class=&quot;large&quot; alt=&quot;A statisztikákat tartalmazó táblázat exportálása szöveges formátumba&quot; /&gt;
&lt;br /&gt;
Feltöltöttem nektek a Google Drive-ra a MODIS minta-adatbázisomat (&lt;a href=&quot;https://drive.google.com/open?id=0B8pLujeireG7YjBmWTMtbm85UzQ&quot;&gt;modis_sample_data.rar&lt;/a&gt;, 561 MB, kitömörítve 2,71 GB), amin gyakorolhatjátok a parancssori adatfeldolgozást. A batch szkriptet megtaláljátok a &lt;a href=&quot;https://github.com/SalsaBoy990/saga_gis_batch&quot;&gt;saga_gis_batch&lt;/a&gt; repository-mban.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Házi feladat:&lt;/strong&gt; Készíts egy tudományos színvonalú elemzést egy tetszőlegesen választott mintaterület erdőiben (pl. Keszthelyi-hegység) bekövetkezett változásokról az NDVI adatok alapján, 2000 és 2016 között! Milyen kapcsolat áll fenn a megfigyelt változások és az éves meteorológiai viszonyok között? (A minta-adatbázisban az ország egész területére megvannak az NDVI-képek.) A Keszthelyi-hegységet azért ajánlom mintaterületnek, mert ott egy igen jelentős erdőpusztulás következett be 2011-től kezdődően.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;ajánlott-irodalom&quot;&gt;Ajánlott irodalom&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;Gulácsi András - Kovács Ferenc&lt;/em&gt; (2015). &lt;a href=&quot;http://www.tajokologiailapok.szie.hu/pdf/201502/04_Gulacsi_Kovacs.pdf&quot;&gt;Aszályvizsgálat lehetősége MODIS műholdképekből számított spektrális indexekkel Magyarországon.&lt;/a&gt; Tájökológiai Lapok 13(2), pp. 235-248.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Gulácsi András - Kovács Ferenc&lt;/em&gt; (2015). &lt;a href=&quot;http://publicatio.bibl.u-szeged.hu/11921/&quot;&gt;Drought monitoring with spectral indices calculated from MODIS satellite images in Hungary.&lt;/a&gt; Journal of Environmental Geography 8(3-4), pp. 11-20.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Rouse, J. W. - Haas, H. R. - Schell, A. J. - Deering, W. D.&lt;/em&gt; (1973). &lt;a href=&quot;https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19740022614.pdf&quot;&gt;Monitoring vegetation systems in the Great Plains
with ERTS.&lt;/a&gt; Third ERTS Symposium, NASA SP-351 1. pp. 309–317.&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Sat, 16 Sep 2017 20:50:00 +0100</pubDate>
        <link>http://localhost:4000//tudomany/2017/09/16/parancssor_a_geoinformatikaban.html</link>
        <guid isPermaLink="true">http://localhost:4000//tudomany/2017/09/16/parancssor_a_geoinformatikaban.html</guid>
      </item>
    
  </channel>
</rss>