<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gulácsi András</title>
    <description>Gulácsi András vagyok. Geoinformatikusként a legújabb web-alapú megoldásokat alkalmazom a földrajzi kutatásban, a földrajzi adatok feldolgozására és megjelenítésére a JavaScript nyelv erejével. Az alacsony színvonalú, elavult egyetemi tömegoktatás nem képes megfelelni
 a jelen kihívásainak és nem aknázza ki a legújabb IT-technológiákban rejlő nagy
 lehetőségeket. A tudásom 90%-át nem az egyetemen szereztem, programozni is magamtól
 tanultam meg. Az írásaimban és a készülő könyvemben az ideológiai alapú, utópisztikus
 gondolkodás ellen veszem fel a küzdelmet a tények, a tapasztalatok és a józan ész
 segítségével, hogy ne váljon a pusztító ideológiák martalékává a társadalom,
 szenvedést és nyomort hagyva maga után. A New Geographer – Új Geográfus blog
 egy újszerű szemléletben egyesíti a földrajzot az informatikával és a webfejlesztéssel.
</description>
    <link>http://localhost:4000</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Az „ego” miatt…</title>
        <description>&lt;blockquote class=&quot;poem&quot;&gt;
&lt;h4&gt;Gulácsi András: Az „ego” miatt…&lt;/h4&gt;
&lt;p&gt;Az „ego” miatt épült fel a civilizáció és lett kapitalista.&lt;br /&gt;
Az „ego” miatt jött a kuruzslás helyére modern orvoslás:&lt;br /&gt;
Járványok és gyógyíthatatlan betegségek váltak múlttá.&lt;br /&gt;
Az „ego” miatt lett alacsony a csecsemőhalandóság s&lt;br /&gt;
nem hal meg minden hat nőből egy a szülés közben.
&lt;/p&gt;

&lt;p&gt;Az „ego” miatt nőtt meg a születéskor várható élettartam.&lt;br /&gt;
Az „ego” miatt jött el az a jólét, amit azok a képmutató zöldek,&lt;br /&gt;
akik a dolgozó embereket ostorozzák, ugyanúgy élveznek.&lt;br /&gt;
Az „egoisták” mindig többet akartak, és mennyi jót tettek&lt;br /&gt;
a világgal eközben.&lt;/p&gt;

&lt;p&gt;A naplopó „értelmiségiek” nem tettek le semmit az asztalra.&lt;br /&gt;
Nem úgy, mint a kiváló mérnökök és a tehetséges tudósok.&lt;br /&gt;
Az „egoisták” nagyszerű épületeket húztak fel, a művészeteket&lt;br /&gt;
felvirágoztatták, szólásszabadságot hoztak s a bűnözést letörték.&lt;/p&gt;

&lt;p&gt;„Egoisták” voltak azok, akik megtisztították a levegőt, a vizeket&lt;br /&gt;
és a vadvilágnak hatalmas területeket érintetlenül hagytak.&lt;br /&gt;
Nézz meg egy amerikai szénerőművet és vesd össze a kínai szmoggal!&lt;br /&gt;
Egyetlen egy „felvilágosult” utópista sem tagadhatja e tényeket.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/az_ego_miatt.jpg&quot; class=&quot;image&quot; alt=&quot;Ego kontra öko&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 23 Sep 2017 16:22:00 +0200</pubDate>
        <link>http://localhost:4000//egyeb/2017/09/23/az_ego_miatt.html</link>
        <guid isPermaLink="true">http://localhost:4000//egyeb/2017/09/23/az_ego_miatt.html</guid>
      </item>
    
      <item>
        <title>Rövid elméleti bevezető a JavaScript nyelvbe, 3. rész.</title>
        <description>&lt;p&gt;Az előző részben az írtam, hogy a végrehajtási kontextusban (execution context) (globális szinten vagy függvényen belül) a változók „felemelése” (hoisting) történik az első sorba. &lt;strong&gt;Ez a felemelés csak látszólagos&lt;/strong&gt;, mivel a JS motor fizikailag nem változtatja meg a változók helyét (a kód hányadik sorában lettek deklarálva)! Mi történik, amikor a böngészőben futtatjuk a kódunkat?&lt;/p&gt;

&lt;p&gt;Először a JS motor létrehozza a böngészőablakunkban a &lt;strong&gt;globális futtatási környezetet&lt;/strong&gt; (a globális objektumot, ami a Window objektumot és a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; értéket, ami a globális objektumra hivatkozik). Ezután a &lt;strong&gt;Syntax Parser&lt;/strong&gt; végigfut a kódunkon és megkeresi az összes &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;-t és &lt;code class=&quot;highlighter-rouge&quot;&gt;function&lt;/code&gt;-t. A következő, &lt;strong&gt;létrehozási fázisban&lt;/strong&gt; (creation phase) a JS motor lefoglalja a memóriát a változóink/objektumaink számára, értéküket ideiglenesen &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;-ra állítja (az értékeket majd később fogjuk definiálni). A kódunk még mindig nem futott le, de már létrejöttek azok a változók, amiket majd használni fogunk.&lt;/p&gt;

&lt;p&gt;Ezután jön a &lt;strong&gt;futtatási fázis&lt;/strong&gt;, amikor a JS értelmező végrehajtja az utasításokat. A JS nyelv egy menetben (single threaded) és szinkron módban (synchronous) futtatja a kódot. Egyszerre csak egy sort, illetve utasítást hajt végre.&lt;/p&gt;

&lt;p&gt;Mint írtam, a futtatási szakasz előtt már léteznek a memóriában a változóink, értékük &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;, tehát hozzájuk férünk még azelőtt, hogy értéket adtunk volna nekik az &lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; operátorral. Ezért tűnik úgy, mintha felemelődnének. Ez a JS motor működésének a következménye. Így most már jobban érthető az alábbi kódrészlet:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;console.log(a); //-&amp;gt; undefined lesz.
var a = 7;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A JS ezt a valóságban nem fogja átírni erre:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var a;
console.log(a); //-&amp;gt; undefined lesz.
a = 7;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Arról van itt szó, hogy a kódunk futtatása előtt már lefoglalódnak a változóink, objektumaink a memóriában, tehát a &lt;code class=&quot;highlighter-rouge&quot;&gt;console.log()&lt;/code&gt; segítségével már hozzáférünk az értékükhöz (&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;) még azelőtt, míg mi értékül adnánk valamit a változónknak. Ennyi és nem több. Semmi &lt;strong&gt;tényleges&lt;/strong&gt; felemelődés nem történik!&lt;/p&gt;

&lt;p&gt;A JavaScript gyengén típusos nyelv, tehát &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;-ral lefoglalt változóink típusa a kódunk futtatásakor dől el és futás közben változhat. A JS a szabvány szerint megállapítja a változóink típusát és gondoskodik az adattípusok közötti konverzióról.&lt;/p&gt;

&lt;p&gt;Térjünk át most a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; érték és annak eredetének boncolgatására, majd utána a bezárással (closure), a privát hozzáféréssel és az egymásba ágyazott függvényekkel fogunk foglalkozni.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;mi-a-this-honnan-származik&quot;&gt;Mi a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;, honnan származik?&lt;/h2&gt;

&lt;p&gt;Az előző részben egy félmondat erejéig megemlítettem, hogy a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; az éppen aktuális objektumpéldányra mutató referencia, amin keresztül hozzáférünk az éppen aktuális objektum tulajdonságaihoz. (Objektum: azonosító-érték párok gyűjteménye.) Ehhez lássunk egy könnyű példát:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* Ez egy pont osztály konstruktora. */
function Point(x, y) {
    this.x = x || 0;
    this.y = x || 0;

    this.print = function () {
        console.log(&quot;x: &quot; + this.x + &quot;, y: &quot; + this.y);
    };
}
// Az osztály példányosítása.
var o = new Point(10, 20);
o.print();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A konstruktor meghívásával példányosítjuk a &lt;code class=&quot;highlighter-rouge&quot;&gt;Point&lt;/code&gt; „osztályt”: létrehozunk egy &lt;code class=&quot;highlighter-rouge&quot;&gt;o&lt;/code&gt; nevű objektumot. Amikor meghívjuk a &lt;code class=&quot;highlighter-rouge&quot;&gt;print()&lt;/code&gt; metódusát, mi helyettesítődik be a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; helyére? Természetesen az aktuális objektumpéldány referenciája, vagyis az &lt;code class=&quot;highlighter-rouge&quot;&gt;o&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; kulcsszó ismerős lehet annak, akinek van tapasztalata a C++-szal vagy a Java-val.&lt;/p&gt;

&lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; eredetének a tisztázásához vissza kell térnünk a C nyelvhez, méghozzá a struktúrákhoz. A struktúrák olyan öszetett adatszerkezetek, amelyek különféle változókat fognak össze, kezelnek együtt. A struktúra (&lt;code class=&quot;highlighter-rouge&quot;&gt;struct&lt;/code&gt;) az osztály (&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;) ősének mondható. A struktúra-tagok hozzáférése alapértelmezetten publikus. Ez a rövid C kódrészletem rámutat a lényegre:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;locale.h&amp;gt;

/* Egy egyszerű struktúra megvalósítása C-ben. */
struct Kijelzo {
    // A kijelző oldalai.
    int szelesseg;
    int magassag;
};
void printKijelzo (struct Kijelzo *);

int main() {
    // Az ékezetes karakterek miatt.
    setlocale(LC_ALL, &quot;hun&quot;);
    // A struktúra példányosítása.
    struct Kijelzo elso;
    // Kijelzo típusú mutató létrehozása
    struct Kijelzo *p;
    // A struktúra példányunk kezdőcímére mutat.
    p = &amp;elso;

    (*p).szelesseg = 1024;
    (*p).magassag = 768;
    printKijelzo(p);

    /* Helyette ezt is írhatnám: */
    p-&amp;gt;szelesseg = 1280;
    p-&amp;gt;magassag = 1024;
    printKijelzo(p);

    getchar();
    return 0;
}
void printKijelzo (struct Kijelzo *ptr) {
    printf(&quot;A kijelző szélessége: %d, magassága: %d\n&quot;,
        ptr-&amp;gt;szelesseg, ptr-&amp;gt;magassag);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Magyarázat: egy &lt;code class=&quot;highlighter-rouge&quot;&gt;struct Kijelzo&lt;/code&gt; típusú struktúrát jelölő mutatót hoztam létre &lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt; néven. Ha &lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt; egy &lt;code class=&quot;highlighter-rouge&quot;&gt;Kijelzo&lt;/code&gt; struktúrát címez, akkor &lt;code class=&quot;highlighter-rouge&quot;&gt;*p&lt;/code&gt; maga a struktúra (memóriacím, ahol &lt;code class=&quot;highlighter-rouge&quot;&gt;elso&lt;/code&gt; megtalálható), és &lt;code class=&quot;highlighter-rouge&quot;&gt;(*p).szelesseg&lt;/code&gt;, illetve &lt;code class=&quot;highlighter-rouge&quot;&gt;(*p).magassag&lt;/code&gt; az &lt;code class=&quot;highlighter-rouge&quot;&gt;elso&lt;/code&gt; struktúra tagjai. A zárójelre szükség van, mivel a &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt; struktúratag operátor precedenciája magasabb, mint a &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; operátoré. A szintaxis egyszerűsítésére vezették be a &lt;code class=&quot;highlighter-rouge&quot;&gt;-&amp;gt;&lt;/code&gt; nyíl operátort (balról jobbra köt).&lt;/p&gt;

&lt;p&gt;(A &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; operátor segítségével a mutató által mutatott memóriacímen található értéket érhetjük el. Az &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; operátor pedig a memóriacímek lekérdezésére használatos. Az &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;p&lt;/code&gt; a mutató memóriacímét adja vissza. A mutató memóriacímén egy másik változó, mutató, tömb stb. memóriacímét tároljuk el.)&lt;/p&gt;

&lt;p&gt;Természetesen egyszerűen használhatnánk a &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt; struktúra-adattag operátort is a struktúratagok lekérdezésére, így: &lt;code class=&quot;highlighter-rouge&quot;&gt;elso.szelesseg = 1920;&lt;/code&gt;. De mi a helyzet akkor, ha több száz struktúrapéldánnyal vagy struktúratömbökkel kell dolgoznunk? Ilyenkor sok hasznát vesszük a mutatóknak.&lt;/p&gt;

&lt;p&gt;A C++-ban a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; az osztály példányát jelölő (annak kezdőcímét tároló) belső mutató, amivel az osztály tagváltozóihoz és metódusaihoz hozzáférünk. Átírtam az előbbi példaprogramunkat C++-ba:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;locale.h&amp;gt;

using namespace std;

class Kijelzo {
private:
    int szelesseg;
    int magassag;
public:
    Kijelzo() {}; // Alapértelmezett konstruktor.
    // Saját konstruktor inicializálási listával.
    Kijelzo(int szelesseg, int magassag): 
        szelesseg(szelesseg), magassag(magassag) {};
    // Destruktor.
    ~Kijelzo() {};

    inline void printKijelzo() const {
        cout &amp;lt;&amp;lt; &quot;A kijelző szélessége: &quot; &amp;lt;&amp;lt; this-&amp;gt;szelesseg
        &amp;lt;&amp;lt; &quot;, magassága: &quot; &amp;lt;&amp;lt; this-&amp;gt;magassag &amp;lt;&amp;lt; endl;
    }
    inline void setSzelesseg(int x) { this-&amp;gt;szelesseg = x; }
    inline int getSzelesseg() const { return this-&amp;gt;szelesseg; }
    inline void setMagassag(int x) { this-&amp;gt;magassag = x; }
    inline int getMagassag() const { return this-&amp;gt;magassag; }
    void this_erteke() const;
};

int main()
{
    setlocale(LC_ALL, &quot;hun&quot;);
    // Az osztály példányosítása.
    Kijelzo elso(1024, 768);
    elso.printKijelzo();
    elso.setMagassag(600);
    cout &amp;lt;&amp;lt; elso.getMagassag() &amp;lt;&amp;lt; endl;

    Kijelzo *p;
    p = &amp;elso;
    cout &amp;lt;&amp;lt; p-&amp;gt;getSzelesseg() &amp;lt;&amp;lt; endl; //=&amp;gt; 1024

    elso.this_erteke();
    cin.get();
    return 0;
}
/* A this értékének kiírása. */
void Kijelzo::this_erteke() const {
    cout &amp;lt;&amp;lt; &quot;A this értéke: &quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; &lt;strong&gt;az osztály aktuális példányának&lt;/strong&gt; (az &lt;code class=&quot;highlighter-rouge&quot;&gt;elso&lt;/code&gt;-nek) &lt;strong&gt;a belső mutatója&lt;/strong&gt;, amivel a tagváltozókat és a tagfüggvényeket (más szóval metódusokat) érhetjük el a &lt;code class=&quot;highlighter-rouge&quot;&gt;-&amp;gt;&lt;/code&gt; (nyíl) operátor segítségével. Ez egy valódi mutató, amit a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; kulcsszóval helyettesítünk és jelen esetben az &lt;code class=&quot;highlighter-rouge&quot;&gt;elso&lt;/code&gt; osztálypéldány címére mutat. Figyeljétek meg jobban a példaprogramot: létrehoztam egy &lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt; nevű mutatót, aminek értékül adtam az &lt;code class=&quot;highlighter-rouge&quot;&gt;elso&lt;/code&gt; memóriacímét. A &lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt; mutató használatával a &lt;code class=&quot;highlighter-rouge&quot;&gt;-&amp;gt;&lt;/code&gt; operátor segítségével is hozzáférek az osztálytagokhoz (természetesen a privát tagváltozókhoz nem férünk hozzá). A &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; pontosan egy ilyen mutató, csak ennek jelölésére bevezették a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; kulcsszót: &lt;code class=&quot;highlighter-rouge&quot;&gt;p-&amp;gt;szelesseg&lt;/code&gt; helyett &lt;code class=&quot;highlighter-rouge&quot;&gt;this-&amp;gt;szelesseg&lt;/code&gt;-et írunk. A program végén kiírtam a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; értékét, ami egy memóriacím.&lt;/p&gt;

&lt;p&gt;A JavaScript-ben szintén létezik a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;. A &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; &lt;strong&gt;az éppen aktuális objektumpéldányra hivatkozik.&lt;/strong&gt; A &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; egy &lt;strong&gt;referencia&lt;/strong&gt;. Mivel a JS-ben nincsen mutató, ezért nincs szükség a nyíl operátorra, helyette a &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt; operátorral érhetjük el az objektum tulajdonságait a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;-en keresztül, vagyis a &lt;code class=&quot;highlighter-rouge&quot;&gt;this.x&lt;/code&gt; a helyes szintaxis.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;a-bezárás-closure-a-privát-hozzáférés-és-a-beágyazott-függvények&quot;&gt;A bezárás (closure), a privát hozzáférés és a beágyazott függvények&lt;/h2&gt;

&lt;p&gt;A JavaScript-ben nem blokkhatókör van, hanem &lt;strong&gt;függvényhatókör&lt;/strong&gt;, tehát nem &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;/code&gt; segítségével tudunk lokális, kívülről nem hozzáférhető változókat bezárni, hanem &lt;code class=&quot;highlighter-rouge&quot;&gt;()&lt;/code&gt; használatával. Tetszőleges számú függvényhatókört (és végrehajtási kontextust) hozhatunk létre a &lt;code class=&quot;highlighter-rouge&quot;&gt;()&lt;/code&gt; zárójelpár segítségével. Ezt a technikát &lt;strong&gt;bezárásnak&lt;/strong&gt; nevezzük. A függvényen belül a &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; kulcsszóval deklarált változók privátak, vagyis kívülről nem elérhetők. A külső környezetben, tehát a függvényen kívül deklarált ugyanolyan nevű változókat elrejtik az aktuális függvényen belül deklarált változók (ha vannak ilyenek).&lt;/p&gt;

&lt;p&gt;Ez nem jelent több védelmet, mint amikor a C++-ban privát hozzáférést alkalmazok a &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt; kulcsszó segítségével. Az újabb JS-szabványok a jövőben majd támogatni fogják a &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;protected&lt;/code&gt; és a &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt; hozzáférési szinteket.&lt;/p&gt;

&lt;p&gt;Nézzünk néhány nagyon egyszerű példát:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function b() {
    console.log(myVar);
}
function a() {
    var myVar = 2;
    b();
}
var myVar = 1;
a(); // Mit fog kiírni?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nyilván az &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;-et fogja kiírni. Erre gondoltatok ti is? Az &lt;code class=&quot;highlighter-rouge&quot;&gt;a()&lt;/code&gt; függvényen belül deklarált &lt;code class=&quot;highlighter-rouge&quot;&gt;myVar&lt;/code&gt; hatóköre az &lt;code class=&quot;highlighter-rouge&quot;&gt;a()&lt;/code&gt; függvény. A másik &lt;code class=&quot;highlighter-rouge&quot;&gt;myVar&lt;/code&gt; változó nincs függvényen belül, tehát globális. A hatókör láncolatra kell itt visszaemlékeznünk. A &lt;code class=&quot;highlighter-rouge&quot;&gt;b()&lt;/code&gt; függvényünk külső környezete a globális végrehajtási környezet. A &lt;code class=&quot;highlighter-rouge&quot;&gt;b()&lt;/code&gt; függvény elsőként a saját hatókörén belül keresi a &lt;code class=&quot;highlighter-rouge&quot;&gt;myVar&lt;/code&gt;-t, de mivel itt nem találja, egy fölötte levő hatókörben, a globális hatókörben keresi tovább. Ez van a hatókörlánc legtetején. Itt található egy &lt;code class=&quot;highlighter-rouge&quot;&gt;myVar&lt;/code&gt; változó, és ennek az értékét írja ki a &lt;code class=&quot;highlighter-rouge&quot;&gt;b()&lt;/code&gt; függvény. Hiába az &lt;code class=&quot;highlighter-rouge&quot;&gt;a()&lt;/code&gt; függvényen belül hívtuk meg. &lt;strong&gt;A lényeg, hogy fizikailag hol található a függvény deklaráció.&lt;/strong&gt; Csak erre figyeljetek!&lt;/p&gt;

&lt;p&gt;Ha a &lt;code class=&quot;highlighter-rouge&quot;&gt;b()&lt;/code&gt; függvényt az &lt;code class=&quot;highlighter-rouge&quot;&gt;a()&lt;/code&gt; függvényen belül deklaráltuk volna, akkor a külső környezete az &lt;code class=&quot;highlighter-rouge&quot;&gt;a()&lt;/code&gt; függvény lenne, az &lt;code class=&quot;highlighter-rouge&quot;&gt;a()&lt;/code&gt; függvényé pedig a globális futtatási környezet. Ebben az esetben a JS motor elsőként a &lt;code class=&quot;highlighter-rouge&quot;&gt;b()&lt;/code&gt;-ben keresné a &lt;code class=&quot;highlighter-rouge&quot;&gt;myVar&lt;/code&gt;-t, utána az &lt;code class=&quot;highlighter-rouge&quot;&gt;a()&lt;/code&gt;-ban és végül a globális környezetben. Ez a &lt;strong&gt;hatókörlánc&lt;/strong&gt;. Kicsit módosítva az előbbi kódot:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function a() {
    var myVar = 2;
    function b() {
        console.log(myVar);
    }
    b();
}
var myVar = 1;
a(); //=&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Az &lt;code class=&quot;highlighter-rouge&quot;&gt;a()&lt;/code&gt; függvényen belüli &lt;code class=&quot;highlighter-rouge&quot;&gt;myVar&lt;/code&gt; változó értékét írja ki a &lt;code class=&quot;highlighter-rouge&quot;&gt;b()&lt;/code&gt; függvény A függvény-definíció után természetesen egyszer meg kell hívunk a &lt;code class=&quot;highlighter-rouge&quot;&gt;b()&lt;/code&gt;-t. Azt nézzétek, hol található a függvénydeklaráció, mibe van beágyazva.&lt;/p&gt;

&lt;p&gt;Még egy példa:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var a = &quot;krumpli&quot;;
function szulo () {
    var b = &quot;körte&quot;;
    function beagyazott () {
        var c = &quot;paprika&quot;;
        console.log(a); //=&amp;gt; krumpli
        console.log(b); //=&amp;gt; körte
    }
    beagyazott();
    console.log(c); // Referenciahiba: c nincs definiálva.
}
szulo();

console.log(b); //=&amp;gt; Referenciahiba: b nincs definiálva.
console.log(c); //=&amp;gt; Referenciahiba: c nincs definiálva.
console.log(a); //=&amp;gt; krumpli
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A kódban a &lt;code class=&quot;highlighter-rouge&quot;&gt;beagyazott()&lt;/code&gt; függvényt ágyaztam be a &lt;code class=&quot;highlighter-rouge&quot;&gt;szulo()&lt;/code&gt; függvénybe, tehát így néz ki a hatókörlánc: &lt;code class=&quot;highlighter-rouge&quot;&gt;beagyazott()&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;szulo()&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;global&lt;/code&gt;. A legbelső függvény változóihoz kívülről nem fér hozzá a &lt;code class=&quot;highlighter-rouge&quot;&gt;szulo()&lt;/code&gt; függvény, sem pedig globálisan nem hozzáférhetők. Ez fordítva nem igaz! A &lt;code class=&quot;highlighter-rouge&quot;&gt;beagyazott()&lt;/code&gt; függvény hozzáfér a &lt;code class=&quot;highlighter-rouge&quot;&gt;szulo()&lt;/code&gt; változóihoz, valamint az összes globális változóhoz, hiszen végighalad az hatókör láncon a nyilak szerinti irányban. Viszont amikor a &lt;code class=&quot;highlighter-rouge&quot;&gt;szulo()&lt;/code&gt;-n belül megpróbáljuk a &lt;code class=&quot;highlighter-rouge&quot;&gt;beagyazott()&lt;/code&gt; függvény &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; változóját elérni, akkor referenciahibát dob a JS értelmező: nem találja a &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;-t. De hol keresi a &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;-t? A szülő függvényhez tartozó hatókör lánc: &lt;code class=&quot;highlighter-rouge&quot;&gt;szulo()&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;global&lt;/code&gt;. Tehát a külső, globális hatókörben keresi, de ott nem találja és ezért dob hibát. (A hibakezelésről egy későbbi részben lesz szó.)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Privát tulajdonságokat vagy változókat&lt;/strong&gt; függvénybe zárás és a &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; kulcsszó használatával hozhatunk létre:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function Hallgato(nev, eha, email) {
    var nev = nev;
    this.getNev = function() { return this.nev; };

    var eha_kod = eha;
    this.setEha = function(x) { this.eha_kod = x; };
    this.getEha = function() { return this.eha_kod; };

    this.email = email;
}
var sanyi = new Hallgato(
                        &quot;Petőfi Sándor&quot;,
                        &quot;PESAABT.SZE&quot;,
                        &quot;sanyi1848@freemail.hu&quot;
);
sanyi.eha_kod = &quot;ABCDEFG.SZE&quot;; //=&amp;gt; Hiba.
sanyi.email = &quot;sanyi1848@gmail.com&quot; 
console.log(sanyi.email); //=&amp;gt; sanyi1848@gmail.com
console.log(sanyi);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ha kiíratod a konzolra &lt;code class=&quot;highlighter-rouge&quot;&gt;sanyi&lt;/code&gt; tartalmát, akkor nem fogod látni a &lt;code class=&quot;highlighter-rouge&quot;&gt;nev&lt;/code&gt; és az &lt;code class=&quot;highlighter-rouge&quot;&gt;eha_kod&lt;/code&gt; tulajdonságát, hiszen a &lt;code class=&quot;highlighter-rouge&quot;&gt;console.log()&lt;/code&gt; nem fér hozzájuk! Csak a get és a set függvények láthatók. Csak ezeken keresztül, szabályozottan férhetünk hozzá ezekhez a tulajdonságokhoz. Tehát „illetéktelenek” nem férnek hozzájuk.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;a-beágyazott-függvények-és-a-this&quot;&gt;A beágyazott függvények és a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; érték a változókkal ellentétben nem kapcsolódik hatókörhöz és a beágyazott függvények sem férnek hozzá a befoglaló függvény &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; értékéhez. A &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;-nek mi nem adhatunk értéket, pl. a &lt;code class=&quot;highlighter-rouge&quot;&gt;this = obj;&lt;/code&gt; utasítás érvénytelen.&lt;/p&gt;

&lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; értéke nem fix a JS-ben, hanem futási időben, a függvényhíváskor dől el. Ha nem az &lt;code class=&quot;highlighter-rouge&quot;&gt;objektumnev.metodus()&lt;/code&gt; szintaxist használjuk, amikor a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; helyére az &lt;code class=&quot;highlighter-rouge&quot;&gt;objektumnev&lt;/code&gt; helyettesítődik be, hanem egy egyszerű függvény hívunk meg, akkor a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; a globális objektumra hivatkozik:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var obj = {
    id: &quot;egy objektum&quot;,
    method: function() {
        console.log(this);
    }
}
obj.method(); //=&amp;gt; az obj-ra hivatkozik

function f2() {
    console.log(this.toString()); // [object Window]
    console.log(this === window); //=&amp;gt; true
}
f2();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ha függvényeket ágyazunk egymásba, akkor a befoglaló függvényben el kell tárolnunk a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; értékét egy változóban, amit megegyezés szerint &lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt;-nek szokás elnevezni.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var obj = {
    elemek: [&quot;Gandalf&quot;, &quot;Aragorn&quot;, &quot;Legolas&quot;, &quot;Gimli&quot;],
    feldolgoz: function() {
        var self = this;
        this.elemek.forEach(function(elem) {
            self.kiir(elem);
        });
    },
    kiir: function(elem) {
        console.log('*' + elem + '*');
    }
};
obj.feldolgoz();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ha a &lt;code class=&quot;highlighter-rouge&quot;&gt;forEach&lt;/code&gt; cikluson belüli függvényben a &lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt; helyett a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;-t használtuk volna, akkor rossz objektumra hivatkoztunk volna, így a &lt;code class=&quot;highlighter-rouge&quot;&gt;kiir()&lt;/code&gt; meghívása sikertelen lett volna (a JS fordító típushibát dobna: a &lt;code class=&quot;highlighter-rouge&quot;&gt;this.kiir&lt;/code&gt; nem függvény). Ilyenkor a &lt;code class=&quot;highlighter-rouge&quot;&gt;kiir()&lt;/code&gt; függvény minden egyes meghívásakor a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; értéke nem a mi objektumunk, hanem a globális objektum lesz (szigorú módban pedig &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;)! A globális objektumnak pedig nincsen &lt;code class=&quot;highlighter-rouge&quot;&gt;kiir()&lt;/code&gt; nevű metódusa. Az első függvény, a &lt;code class=&quot;highlighter-rouge&quot;&gt;feldolgoz()&lt;/code&gt; meghívásakor a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; az &lt;code class=&quot;highlighter-rouge&quot;&gt;obj&lt;/code&gt;-ra hivatkozik. A &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; értékét eltároljuk a &lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt; változóban. A &lt;code class=&quot;highlighter-rouge&quot;&gt;forEach&lt;/code&gt; ciklus az &lt;code class=&quot;highlighter-rouge&quot;&gt;elemek&lt;/code&gt; tömb minden elemére meghív egy úgynevezett callback függvényt. Ebben a függvényben a &lt;code class=&quot;highlighter-rouge&quot;&gt;self.kiir(elem)&lt;/code&gt; szintaxissal hivatkozunk az &lt;code class=&quot;highlighter-rouge&quot;&gt;obj&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;kiir()&lt;/code&gt; metódusára, és mivel a &lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt; tartalma az &lt;code class=&quot;highlighter-rouge&quot;&gt;obj&lt;/code&gt;-ra hivatkozik, elérjük a függvényt.&lt;/p&gt;

&lt;p&gt;Egyelőre elég ennyi. A következő két részben foglalkozni fogok a kivételkezeléssel (exeption handling), a RegExp objektumokkal, a JSON-nal (JavaScript Object Notation) és a metóduslánccal (method chain). Végül a prototípusos öröklést mutatom be.&lt;/p&gt;

&lt;p&gt;Ezek után pedig rá fogok térni a funkcionális programozásra és a Google Earth Engine API (Application Programming Interface, vagyis alkamazásprogramozási felület) használatára.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;ajánlott-irodalom&quot;&gt;Ajánlott irodalom&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Anthony Alicea (2015). &lt;a href=&quot;https://www.youtube.com/watch?v=Bv_5Zv5c-Ts&quot;&gt;&lt;strong&gt;JavaScript: Understanding the Weird Parts - The First 3.5 Hours.&lt;/strong&gt;&lt;/a&gt; A teljes 12 órás kurzus az &lt;a href=&quot;https://www.udemy.com/understand-javascript/?utm_content=_._pd_364426_._&amp;amp;utm_source=facebook-row&amp;amp;utm_medium=udemyads&amp;amp;utm_campaign=NEW-FB-VRT-ROW-Tech-EN-ALL_._ci_._sl_ALL_._vi_._sd_All_._la_EN_.&amp;amp;utm_term=_._ag_NEW-FB-VRT-ROW-Tech-EN-ALL_._ci_._sl_ALL_._vi_._sd_All_._la_EN_._-_._ci_._._pi_1814585708581485_._gi_all_._ai_18--65_._an_M3oTyZ&amp;amp;k_clickid=97b08e8c-94fa-4830-ad99-8b6239fe4a0d_131994849&quot;&gt;udemy.com&lt;/a&gt;-on megtalálható. Nem biztos, hogy érdemes kiadni rá a pénzt. Én csak az első 3,5 órát néztem meg a youtube-on.&lt;/li&gt;
  &lt;li&gt;Brian W. Kernighan - Dennis M. Richie: &lt;strong&gt;A C programozási nyelv. 2. kiadás.&lt;/strong&gt; - Műszaki Kiadó, Budapest.&lt;/li&gt;
  &lt;li&gt;Benedek Zoltán - Levendovszky Tihamér (2013). &lt;strong&gt;Szoftverfejlesztés C++ nyelven.&lt;/strong&gt; SZAK Kiadó Kft., Bicske.&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 20 Sep 2017 16:37:00 +0200</pubDate>
        <link>http://localhost:4000//tudomany/2017/09/20/javascript_03.html</link>
        <guid isPermaLink="true">http://localhost:4000//tudomany/2017/09/20/javascript_03.html</guid>
      </item>
    
      <item>
        <title>Földrajzi adatfeldolgozás a parancssorban: a SAGA GIS és a GDAL</title>
        <description>&lt;p&gt;A SAGA mozaikszó a System for Automated Geoscientific Analyses (Automatizált Földtudományi Elemző Rendszer) rövidítése.
A &lt;a href=&quot;http://www.saga-gis.org/en/index.html&quot;&gt;SAGA GIS&lt;/a&gt; egy C++-ban írt szabad forráskódú térinformatikai szoftver. A legújabb, &lt;strong&gt;5.0&lt;/strong&gt;-ás verziót használtam a tutoriálhoz.&lt;/p&gt;

&lt;p&gt;A &lt;strong&gt;SAGA GIS térinformatikai szoftver&lt;/strong&gt; kifejlesztésének ötlete az 1990-es évek végén született meg a németországi Göttingeni Egyetem Természetföldrajzi Tanszékén. A tanszéken futó kutatási projektek középpontjában a raszteres adatok, azon belül is kifejezetten a digitális domborzatmodellek, elemzése volt, amit többek közt a talajtulajdonságok, terep által irányított folyamatok, valamint éghajlati paraméterek modellezésére, előrejelzésére használtak. A SAGA GIS-t tehát kifejezetten raszteres adatokfeldolgozására, elemzésére írták. A SAGA GIS fejlesztése &lt;em&gt;Jürgen Böhner&lt;/em&gt; és &lt;em&gt;Olaf Conrad&lt;/em&gt; vezetésével történt és történik napjainkban is.&lt;/p&gt;

&lt;p&gt;A kereskedelmi szoftverek közül az ERDAS Imagine ingyenes alternatívája lehet a SAGA GIS.&lt;/p&gt;

&lt;p&gt;A &lt;a href=&quot;http://www.gdal.org/&quot;&gt;GDAL&lt;/a&gt; (Geospatial Data Abstraction Library) egy szabad forrású földrajzi adatfeldolgozó szoftverkönyvtár, ami számos vektoros és raszteres adatokat manipuláló modult tartalmaz, amelyek a paranccssorban vagy valamilyen héjalkalmazáson (&lt;a href=&quot;https://trac.osgeo.org/osgeo4w/&quot;&gt;OSGeo4W Shell&lt;/a&gt;) keresztül érhetők el. A gépemen lévő változat a &lt;a href=&quot;http://www.qgis.org/hu/site/&quot;&gt;Quantum GIS (QGIS)&lt;/a&gt; szabad forráskódú térinformatikai szoftver mellett települ fel (ugyanis a QGIS is használja a GDAL moduljait), és az &lt;strong&gt;OSGeo4W Shell&lt;/strong&gt; héjalkalmazáson keresztül futtatom. A &lt;strong&gt;GDAL verzióm: 1.11.2&lt;/strong&gt; (2015. február 10.). A QGIS 2.8.1-Wien változatot telepítettem fel.&lt;/p&gt;

&lt;p&gt;A fenti verziójú alkalmazásokat használtam a parancssori szkriptek futtatására, tehát más verziókkal nem 100%, hogy tökéletesen működnek.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-adat-és-módszer&quot;&gt;1. Adat és módszer&lt;/h2&gt;

&lt;p&gt;Egy 15 éves 2000 és 2016 közötti műholdas adatsort használtam fel a parancssorban történő adatfeldolgozás demonstrálására. A NASA Terra műhold MODIS szenzorának &lt;a href=&quot;https://lpdaac.usgs.gov/dataset_discovery/modis/modis_products_table/mod13q1_v006&quot;&gt;250 méteres felbontású, 16 napos EVI és NDVI kompozitképeit&lt;/a&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;MOD13Q1: MODIS/Terra Vegetation Indices 16-Day L3 Global 250 m SIN Grid V005&lt;/code&gt;) dolgoztam fel a Duna-Tisza-közi erdőterületekre, melyeket az Európai Uniós &lt;a href=&quot;https://www.eea.europa.eu/publications/COR0-landcover&quot;&gt;CORINE&lt;/a&gt; (Coordination of Information on the Environment) felszínborítási adatbázis segítségével határolt le a témavezetőm (&lt;em&gt;Dr. Kovács Ferenc&lt;/em&gt;).
Az EU tagállamok nagyjából 6 évente felmérik a felszínborítás változásait különböző felszínborítási kategóriák szerint, 1:100 000-es méretarányban. A &lt;code class=&quot;highlighter-rouge&quot;&gt;CLC_2000&lt;/code&gt; (a 2000-05 közötti), a &lt;code class=&quot;highlighter-rouge&quot;&gt;CLC_2006&lt;/code&gt; (a 2006-11 közötti) és a &lt;code class=&quot;highlighter-rouge&quot;&gt;CLC_2012&lt;/code&gt; (2012-től kezdődő műholdképekre) adatok alapján lettek lehatárolva az erdők.&lt;/p&gt;

&lt;p&gt;Azokat a 250*250 méteres cellákat válogattuk le, aminek legalább 2/3 részét erdő borította. Külön vizsgáljuk a lomb-, a tűlevelű és az elegyes erdőket. A cél a vegetáció egészségi állapotának monitorozása, valamint trendszerű változásainak kimutatása a szárazodó Homokhátságon március vége és szeptember vége között. Az 1970-es évektől számítva a talajvízkút-hálózat mérései szerint átlagosan 3 méterrel süllyedt a régióban a talajvízszint (a magasabban fekvő térségekben ennél nagyobb csökkenés is megfigyelhető, de kizárólag csak ott).&lt;/p&gt;

&lt;p&gt;A 16 napos kompozitképeket úgy kell érteni, hogy a 16 nap alatt készült összes felvételből raknak össze egy képet: a legjobb minőségű, azaz tiszta, felhőktől mentes értékeket használják fel minden egyes cellára (pixelre). A legnagyobb hátulütője az optikai (a látható és az infravörös tartományban mérő) szenzoroknak, hogy a felhőkön nem látnak át, szemben a lézeres vagy radaros mérésekkel. A kompozit készítésével sokkal teljesebb adatokat kapunk, hiszen egy hosszabb időszakra nézve valószínűbb, hogy lesznek olyan felhőmentes képek, amelyek lefedik a földfelszín nagy részét, így használható információkhoz jutunk.&lt;/p&gt;

&lt;p&gt;Az &lt;strong&gt;EVI&lt;/strong&gt; (Enhanced Vegetation Index, Továbbfejlesztett Vegetációindex) és az &lt;strong&gt;NDVI&lt;/strong&gt; (Normalized Difference Vegetation Index, &lt;a href=&quot;https://www.agroinform.hu/gazdasag/hogyan-hasznosithatom-a-vegetacios-index-kepeket-demo-32500-001&quot;&gt;Normalizált Vegetációindex&lt;/a&gt;) spektrális index. A &lt;a href=&quot;http://www.geo.u-szeged.hu/~feri/kornyezeti_informatika/ch10s02.html&quot;&gt;&lt;strong&gt;spektrális indexek&lt;/strong&gt;&lt;/a&gt; olyan származtatott mérőszámok, amelyek a műholdkép-sávokon (például látható kék, látható zöld, látható vörös, közeli, középhullámú és hosszúhullámú, azaz termális infravörös hullámhossz-tartományú sávok) végzett aritmetikai műveletek (osztás, szorzás, kivonás, összeadás) eredményeképpen állnak elő.&lt;/p&gt;

&lt;p&gt;A műholdkép sávok értékei reflektancia értékek, vagyis a különböző hullámhossz tartományokban mért, felszínre beérkező és onnan visszaverődő sugárzás hányadosai (0 és 1 közötti értékek lehetnek). Például a hófelszín a beérkező napsugárzás 90%-át veri vissza a látható hullámhossz-tartományban. Ezzel szemben a homok csak 30-40%-ot ver vissza, ezért nem csoda, hogy nyáron nagyon felforrósodik a tűző napon. A különböző felszínek/anyagok másképpen vernek vissza a különböző hullámhosszakon. Ez azért fontos, mert ennek segítségével jól el tudjuk határolni egymástól a felszínborítás-típusokat és feltérképezni a változásokat.&lt;/p&gt;

&lt;p&gt;A vegetációs indexek segítségével a levélzetben bekövetkező biológiai változásokat számszerűsíthetjük (cifrán mondva: kvantifikálhatjuk). Szoros kapcsolat áll fenn a levélzet klorofilltartalma és a vegetációs indexek értékei között. A vegetációs indexeket az 1970-es évek eleje óta használják a növényzet/biomassza változásainak értékelére (&lt;em&gt;Rouse, J. W. et al. 1973&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;A klorofill molekulák (klorofill-a és klorofill-b) a zöld színtestekben (kloroplasztisz) találhatók. A kloroplasztisz a szén-dioxidból és a vízből fény hatására cukrot (glükózt) állít elő. Ez a fotoszintézis folyamata. A klorofill molekulák nagyon fontos szerepet töltenek be a növények energiatermelő folyamataiban, ugyanis ezek nyelik el (abszorbeálják) a látható vörös és kék tartományba eső napfényt. (A zöld tartományban viszont nagy a visszaverődés, és &lt;a href=&quot;http://miert.webclub.hu/miert-zoldek-a-levelek&quot;&gt;innen a levelek zöld színe.&lt;/a&gt;) Az így elnyelt fotonok energiáját összegyűjtik és továbbítják a fotoszintézis enzimei, fehérjéi felé.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Egészséges vegetáció&lt;/strong&gt; esetén magas a klorofilltartalom a levelekben. Ilyenkor &lt;strong&gt;a látható vörös tartományban nagyon alacsony a reflektancia&lt;/strong&gt; (a visszaverődés), hiszen a klorofill elnyeli a sugárzást. Ezzel szemben, a közeli infravörös tartományban reflektancia csúcs jelentkezik, ugyanis itt a levélzet erősen visszaverő. &lt;strong&gt;A vegetációindexek a vörös és a közeli infravörös sáv reflektanciaértékei közötti különbségen alapszanak.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A hosszan tartó szárazság, illetve aszály hatására&lt;/strong&gt; a növény nem jut elegendő vízhez, ezért a levelek elkezdenek sárgulni-barnulni, csökken a klorofill-tartalmuk, a fotoszintetikus aktivitás lecsökken. Ilyenkor &lt;strong&gt;a klorofill kevesebb vörös tartományú fényt nyel el, tehát a reflektancia itt megnő.&lt;/strong&gt; Ezzel együtt a közeli infravörös tartományban is csökken egy kicsit a reflektancia, vagyis &lt;strong&gt;kisebb lesz a különbség a két sáv értékei között.&lt;/strong&gt; A magasabb vegetációindex értékek nagyobb klorofill tartalmat, míg a kisebbek lecsökkent klorofilltartalmat jeleznek. Másképpen kifejezve, egyenes arányosság áll fenn az indexértékek és a fotoszintetikus aktivitás között.&lt;/p&gt;

&lt;p&gt;A vegetációs indexek esetén szokás normalizálást alkalmazni, amivel [-1; +1] intervallumba transzformáljuk az értékeket. Ez azért előnyös, mert különböző lejtőszög és megvilágítás hatásait kiküszöbölhetjük vele.&lt;/p&gt;

&lt;p&gt;Az &lt;a href=&quot;https://en.wikipedia.org/wiki/Enhanced_vegetation_index&quot;&gt;EVI index&lt;/a&gt; a hagyományos NDVI továbbfejlesztett, optimalizált változata, melynek számításához a közeli infravörös és a vörös sávok mellett a kék sávot is felhasználják azon célból, hogy javítsák a talaj háttérjeleket és csökkentsék a légköri befolyásokat, mint például az aeroszol szétszóródást.&lt;/p&gt;

&lt;p&gt;Itt vannak a vegetációindexek képletei:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NDVI = (NIR − Red) / (NIR + Red)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;EVI = G * ((NIR − Red) / (NIR + C1 * Red − C2 * Blue + L))&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ahol &lt;code class=&quot;highlighter-rouge&quot;&gt;NIR&lt;/code&gt; a közeli infravörös sáv (841-876 nm), &lt;code class=&quot;highlighter-rouge&quot;&gt;Red&lt;/code&gt; a látható vörös sáv (620-670 nm) és &lt;code class=&quot;highlighter-rouge&quot;&gt;Blue&lt;/code&gt; a látható kék sáv (459-479 nm).  nm: nanométer, &lt;code class=&quot;highlighter-rouge&quot;&gt;10^-9&lt;/code&gt; m. A korrekciós együtthatók értékei &lt;code class=&quot;highlighter-rouge&quot;&gt;C1 = 6&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;C2 = 2,5&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;L = 1&lt;/code&gt; és &lt;code class=&quot;highlighter-rouge&quot;&gt;G = 7,5&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-feldolgozás-a-parancssorban&quot;&gt;2. Feldolgozás a parancssorban&lt;/h2&gt;

&lt;p&gt;A Windows parancssorban úgynevezett &lt;a href=&quot;https://hu.wikipedia.org/wiki/K%C3%B6tegelt_%C3%A1llom%C3%A1ny&quot;&gt;&lt;strong&gt;kötegelt állományokat&lt;/strong&gt;&lt;/a&gt; futtatok. Egyszerű és hatékony kis programokat lehet batch-ban írni. Az általában .cmd vagy &lt;strong&gt;.bat&lt;/strong&gt; kiterjesztésű kötegelt állományokat (angolból átvett néven &lt;a href=&quot;https://hu.wikipedia.org/wiki/Batch_programoz%C3%A1s&quot;&gt;batch fájlokat&lt;/a&gt;) Windows, OS/2, és MS-DOS rendszerekben szokták használni. Formailag egy szövegfájlhoz hasonlítanak, tartalmuk pedig parancsok (DOS/Windows parancsok) egymásutánja. Futtatásuk a tartalom sorról sorra való olvasásával történik például a &lt;strong&gt;cmd.exe&lt;/strong&gt;-vel a Windows operációs rendszer alatt. A SAGA GIS parancssorban is futtatható, de célszerű kötegelt fájlként futtatni az utasítások sorozatát.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;21-saga-gis-saga_cmd&quot;&gt;2.1. SAGA GIS (saga_cmd)&lt;/h3&gt;

&lt;p&gt;A SAGA GIS moduljai a parancssorban is elérhetők. Ha írunk egy programot vagy egy szkriptet, akkor mindig adjuk meg kommentekben, hogy mit csinál a program, milyen probléma megoldására írtuk! A batch-ban a &lt;code class=&quot;highlighter-rouge&quot;&gt;REM&lt;/code&gt; paranccsal tudunk kommentet elhelyezni a szkriptünkbe. Ezeket a számítógép parancsértelmezője figyelmen kívül hagyja. Az &lt;code class=&quot;highlighter-rouge&quot;&gt;ECHO&lt;/code&gt; (visszhang) parancs üzeneteket jelenít meg a kijelzőn (a kommenteket és a parancsokat). Alapértelmezetten &lt;code class=&quot;highlighter-rouge&quot;&gt;ON&lt;/code&gt; módban van (&lt;code class=&quot;highlighter-rouge&quot;&gt;ECHO ON&lt;/code&gt;), de ki is kapcsolható az &lt;code class=&quot;highlighter-rouge&quot;&gt;ECHO OFF&lt;/code&gt; paranccsal. Az &lt;code class=&quot;highlighter-rouge&quot;&gt;@&lt;/code&gt; jel azt a célt szolgálja hogy az &lt;code class=&quot;highlighter-rouge&quot;&gt;echo off&lt;/code&gt;-ot tartalmazó sorra is kikapcsolja a visszhangot. A parancsokat kisbetűsen és nagybetűsen is írhatjuk.&lt;/p&gt;

&lt;p&gt;He beírjátok a parancssorba, hogy &lt;code class=&quot;highlighter-rouge&quot;&gt;help&lt;/code&gt;, akkor kilistázza az összes parancsot és rövid leírásukat, valamint útmutatókat a használatukról. Ha pedig a &lt;code class=&quot;highlighter-rouge&quot;&gt;help parancs_neve&lt;/code&gt; sort írátok be, akkor még részletesebb magyarázatot kaptok a parancs használatáról. &lt;a href=&quot;https://www.tutorialspoint.com/batch_script/batch_script_quick_guide.htm&quot;&gt;Ezen a linken&lt;/a&gt; egy jó tutoriált találtok a batch használatáról.&lt;/p&gt;

&lt;p&gt;A helyi változók a felhasználó által megadott azonosítók, melyek az értékadás során jönnek létre. Értékadás a &lt;code class=&quot;highlighter-rouge&quot;&gt;SET&lt;/code&gt; parancs segítségével történik az alábbi szintaxis szerint: &lt;code class=&quot;highlighter-rouge&quot;&gt;SET azonosito = ertek&lt;/code&gt;. A helyi változók csak az adott programban érvényesek. A változók értéke rejtve marad, ha a visszhang ki van kapcsolva az &lt;code class=&quot;highlighter-rouge&quot;&gt;echo off&lt;/code&gt; parancs segítségével.&lt;/p&gt;

&lt;p&gt;A környezeti változók (például a &lt;code class=&quot;highlighter-rouge&quot;&gt;PATH&lt;/code&gt; a futtatható fájlok keresési útja) a gép működésére nézve fontos információkat tartalmaznak. A szkriptünkben külső programokat (a SAGA GIS moduljait) futtatunk. Ezeknek vannak bemenő parancssori argumentumai, amiket meg kell adni.&lt;/p&gt;

&lt;p&gt;Ahhoz, hogy hozzáférjünk a SAGA modulokhoz, ideiglenesen módosítanunk kell a &lt;code class=&quot;highlighter-rouge&quot;&gt;PATH&lt;/code&gt; környezeti változót, hogy az a &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;saga_cmd.exe&lt;/code&gt;&lt;/strong&gt; elérési útjára mutasson (&lt;code class=&quot;highlighter-rouge&quot;&gt;set PATH=%PATH%;g:\saga-5.0.0_x64\&lt;/code&gt;). Csak így tudjuk meghívni a programot. A &lt;code class=&quot;highlighter-rouge&quot;&gt;SETLOCAL&lt;/code&gt; parancs segítségével lokálissá tehetjük a &lt;code class=&quot;highlighter-rouge&quot;&gt;PATH&lt;/code&gt; változónkat, így csak a szkriptünkben lesz látható, vagyis kívülről nem lesz hozzáférhető.&lt;/p&gt;

&lt;p&gt;Évenként dolgozom fel az adatokat, tehát minden év esetén módosítani kell egy kicsit a változókat! Itt van a programom eleje:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-batch&quot;&gt;REM @ECHO OFF
REM *****************************************************************
REM Create mean and median images and clip them with polygons
REM Author: András Gulácsi
REM E-mail: admin@newgeographer.com
REM Date: September 10th, 2017
REM SAGA GIS és GDAL: Földrajzi adatfeldolgozás a parancssorban
REM http://www.newgeographer.com/tudomany/2017/09/16/parancssor_a_geoinformatikaban.html
REM *****************************************************************
REM *************** PATHS ******************
REM Path to saga_cmd.exe
SETLOCAL
set PATH=%PATH%;g:\saga-5.0.0_x64\

REM Path to working dir
SET WORK=g:\modis\2005\EOV_2005\ndvi\
SET RESULT=g:\modis\TEMP
SET SHAPES=g:\modis\
SET POLYGON=00_l_250_66sz_poli.shp
SET POSTFIX=_00_l
SET YEAR=2005
REM ****************************************
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Létrehoztam néhány fontos változót a fájlok elérési útjait/nevét eltárolva bennük. A &lt;code class=&quot;highlighter-rouge&quot;&gt;WORK&lt;/code&gt; a bemenő képfájlok (GeoTIFF-ben), a &lt;code class=&quot;highlighter-rouge&quot;&gt;SHAPES&lt;/code&gt; a bemenő shape fájlok elérési útvonala. A &lt;code class=&quot;highlighter-rouge&quot;&gt;RESULT&lt;/code&gt; az eredményfájlok kimenő útvonala, a &lt;code class=&quot;highlighter-rouge&quot;&gt;POLYGON&lt;/code&gt; a shape fájl neve, amivel kivágjuk a mintaterületet a képből. Ez egy poligon típusú vektoros állomány.&lt;/p&gt;

&lt;p&gt;A következő lépésben &lt;strong&gt;egy &lt;code class=&quot;highlighter-rouge&quot;&gt;FOR&lt;/code&gt; ciklus segítségével beolvassuk a bemenő fájlokat tartalmazó mappánkban található összes .tif állományt, majd átkonvertáljuk azokat a SAGA GIS saját fájlformátumába, .sgrd-be.&lt;/strong&gt; A &lt;code class=&quot;highlighter-rouge&quot;&gt;%WORK%&lt;/code&gt; helyére a &lt;code class=&quot;highlighter-rouge&quot;&gt;WORK&lt;/code&gt; változónk tartalma helyettesítődik be. A &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; az egy tetszőleges sztringet helyettesít, vagyis tetszőleges nevű, de .tif állományokat olvasunk be.&lt;/p&gt;

&lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;saga_cmd io_gdal 0&lt;/code&gt; parancs a SAGA GIS &lt;strong&gt;io_gdal&lt;/strong&gt; moduljának egyik eszközét hívja meg (raszter importálása). Ezután &lt;strong&gt;a parancssori argumentumokat&lt;/strong&gt; kell megadnunk: &lt;code class=&quot;highlighter-rouge&quot;&gt;-GRIDS&lt;/code&gt; (bemenő fájl), &lt;code class=&quot;highlighter-rouge&quot;&gt;-FILES&lt;/code&gt; (eredményfájl), &lt;code class=&quot;highlighter-rouge&quot;&gt;-TRANSFORM&lt;/code&gt; (transzformáció, ez nekünk nem kell). A &lt;code class=&quot;highlighter-rouge&quot;&gt;%%i&lt;/code&gt; az éppen aktuális fájl nevét jelöli. A továbbiakban a .sgrd fájlokkal dolgozunk. A &lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt; &lt;strong&gt;beszúrási jelre&lt;/strong&gt; azért van szükség, mert egy sorba kellene írni a parancsot, de a láthatóság kedvéért sortöréseket használtam. A &lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt; jel a sor végéhez hozzáfűzi a következő sort (a beszúrási jel és a rá következő újsor karakter törlődik). Fontos a sorköz a &lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt; előtt!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-batch&quot;&gt;FOR /F %%i IN ('dir /b %WORK%\*.tif') DO (

REM Tool: Import Raster
saga_cmd io_gdal 0 ^
-GRIDS=%WORK%\%%i.sgrd ^
-FILES=%WORK%\%%i ^
-TRANSFORM=0

)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A modulokról és azok használatáról a &lt;a href=&quot;http://www.saga-gis.org/saga_tool_doc/5.0.0/a2z.html&quot;&gt;SAGA GIS dokumentációban&lt;/a&gt; találhattok bővebb leírást.&lt;/p&gt;

&lt;p&gt;A raszterállományokra (grid-ek) statisztikákat (átlagképeket, szórást stb.) a &lt;strong&gt;Statistics for Grids&lt;/strong&gt; eszközzel számolhatunk. Argumentumként meg kell adni a bemenő grid-eket (amiket az előzőekben .sgrd-be alakítottunk át), valamint azokat a statisztikákat, amiket ki akarunk számolni (&lt;code class=&quot;highlighter-rouge&quot;&gt;-MEAN&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;-PCTL&lt;/code&gt;). A &lt;code class=&quot;highlighter-rouge&quot;&gt;-PCTL&lt;/code&gt; a percentilis rövidítése, ehhez tartozik egy másik argumentum (&lt;code class=&quot;highlighter-rouge&quot;&gt;-PCTL_VAL&lt;/code&gt;), ahol meg kell adni, hogy hányadik percentilist akarjuk kiszámítani. Az 50. percentilis a medián, ami egyébként az alapértelmezett érték, tehát meg sem kéne adnunk külön.&lt;/p&gt;

&lt;p&gt;Viszont van egy problémánk: évenként meg kell adnunk a 13 db kép teljes elérési útvonalát, amit begépelni kényelmetlen és időigényes volna. &lt;code class=&quot;highlighter-rouge&quot;&gt;FOR&lt;/code&gt; ciklust itt nem használhatunk. Ilyenkor mit tehetünk? Van egy fontos alapelvem, ami így szól: &lt;strong&gt;ha lehetséges, akkor mindig térj vissza egy olyan megoldáshoz, amit már ismersz!&lt;/strong&gt; Az Excelben mindenki ismeri a függvényeket. Az &lt;code class=&quot;highlighter-rouge&quot;&gt;ÖSSZEFŰZ()&lt;/code&gt; függvény segítségével könnyedén legenerálhatjuk az elérési utakat, és csak az éveket kell átírni. Az összefűzött szöveget pedig egyben bemásoljuk a szkriptünkbe. (Itt zárójelben megjegyzem, ha esetleg valamelyikőtök nem tudná, hogy a .bat fájlokat úgy szerkeszthetjük, hogy átírjuk a fájlkiterjesztést .txt-re.). A grid-ek elérési útvonalait &lt;code class=&quot;highlighter-rouge&quot;&gt;;&lt;/code&gt;-vel kell elválasztanunk egymástól.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/sagagis/excel.png&quot; class=&quot;large&quot; alt=&quot;Elérési utak, fájlnevek generálása az ÖSSZEFŰZ() függvény segítségével&quot; /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-batch&quot;&gt;REM Tool: Statistics for Grids

saga_cmd statistics_grid 4 ^
-GRIDS=%WORK%\NDVI2005081_eov_kiv.tif.sgrd;%WORK%\NDVI2005097_eov_kiv.tif.sgrd;%WORK%\NDVI2005113_eov_kiv.tif.sgrd;%WORK%\NDVI2005129_eov_kiv.tif.sgrd;%WORK%\NDVI2005145_eov_kiv.tif.sgrd;%WORK%\NDVI2005161_eov_kiv.tif.sgrd;%WORK%\NDVI2005177_eov_kiv.tif.sgrd;%WORK%\NDVI2005193_eov_kiv.tif.sgrd;%WORK%\NDVI2005209_eov_kiv.tif.sgrd;%WORK%\NDVI2005225_eov_kiv.tif.sgrd;%WORK%\NDVI2005241_eov_kiv.tif.sgrd;%WORK%\NDVI2005257_eov_kiv.tif.sgrd;%WORK%\NDVI2005273_eov_kiv.tif.sgrd ^
-MEAN=%RESULT%\atlag.sgrd ^
-PCTL=%RESULT%\median.sgrd ^
-PCTL_VAL=50
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ezután az átlag- és mediánképekből ki kell vágnunk az erdőterületeket a poligonok segítségével. Erre a &lt;code class=&quot;highlighter-rouge&quot;&gt;shapes_grid&lt;/code&gt; modul &lt;strong&gt;Grid vágása poligonnal&lt;/strong&gt; eszközét használjuk. Meg kell adni a bemenetet, a kimenetet, a poligonokat tartalmazó shape fájlt és az &lt;code class=&quot;highlighter-rouge&quot;&gt;-EXTENT&lt;/code&gt; argumentumot, ami a kimenő grid terjedelmét határozza meg. Mi ezt &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;-ra állítjuk. Ebben az esetben az eredeti terjedelmet megtartjuk. Ez az alapértelmezett beállítás:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-batch&quot;&gt;REM Tool: Clip Grid with Polygon

saga_cmd shapes_grid 7 ^
-INPUT=%RESULT%\atlag.sgrd ^
-OUTPUT=%RESULT%\atlag%POSTFIX%.sgrd ^
-POLYGONS=%SHAPES%\%POLYGON% ^
-EXTENT=0

saga_cmd shapes_grid 7 ^
-INPUT=%RESULT%\median.sgrd ^
-OUTPUT=%RESULT%\median%POSTFIX%.sgrd ^
-POLYGONS=%SHAPES%\%POLYGON% ^
-EXTENT=0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/sagagis/saga_results.png&quot; class=&quot;large&quot; alt=&quot;A mintaterületek sikeresen kivágva az átlagképből&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
Miután eredményül kaptuk a mintaterületünkre kivágott átlag- és mediánképeket, ki kell exportálnunk őket GeoTIFF-be. Ehhez megint csak az &lt;code class=&quot;highlighter-rouge&quot;&gt;io_gdal&lt;/code&gt; modult használjuk. A &lt;code class=&quot;highlighter-rouge&quot;&gt;-GRIDS&lt;/code&gt;-nél az exportálandó grid-et, a &lt;code class=&quot;highlighter-rouge&quot;&gt;-FILE&lt;/code&gt;-nál a kimenő fájlt adjuk meg:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-batch&quot;&gt;REM Tool: Export GeoTIFF

saga_cmd io_gdal 2 ^
-GRIDS=%RESULT%\atlag%POSTFIX%.sgrd ^
-FILE=%RESULT%\%YEAR%_atlag%POSTFIX%.tif

saga_cmd io_gdal 2 ^
-GRIDS=%RESULT%\median%POSTFIX%.sgrd ^
-FILE=%RESULT%\%YEAR%_median%POSTFIX%.tif

PAUSE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;PAUSE&lt;/code&gt; paranccsal megállítjuk a szkript futását, hogy ne lépjen ki azonnal a konzolból, hanem várja meg egy billentyű lenyomását, és utána lépjen ki. Ez olyan, mint amikor a C-ben a &lt;code class=&quot;highlighter-rouge&quot;&gt;system(&quot;PAUSE&quot;);&lt;/code&gt; utasítással tesszük ugyanezt. (Megjegyzendő, hogy C-ben &lt;a href=&quot;(http://www.cplusplus.com/articles/j3wTURfi/)&quot;&gt;nem ajánlom ezt a megoldást&lt;/a&gt;, mert erőforrásigényes, nem biztonságos és csak Windows rendszeren működik. Ennél sokkal egyszerűbb a &lt;code class=&quot;highlighter-rouge&quot;&gt;getchar()&lt;/code&gt;-t használni.)&lt;/p&gt;

&lt;p&gt;A következő részben pedig az idősorok számtani átlagát és egyéb statisztikai jellemzőjét exportáljuk ki szöveges fájlba.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;22-virtuális-raszter-készítése-gdal-ban&quot;&gt;2.2. Virtuális raszter készítése GDAL-ban&lt;/h3&gt;

&lt;p&gt;Először létrehozunk egy virtuális raszter (&lt;a href=&quot;http://www.gdal.org/gdal_vrttut.html&quot;&gt;.vrt fájl, a GDAL saját formátuma&lt;/a&gt;) fájlkatalógust, ami XML formátumban tartalmazza az együtt kezelt képfájlok leíró adatait, de magukat az adatokat nem. Ezt a virtuális rasztert fogjuk megnyitni a SAGA GIS-ben.&lt;/p&gt;

&lt;p&gt;Nyissunk az OSGeo4W héjalkalmazást és gépeljük be ezt a rövid parancsot egyben:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gdalbuildvrt -separate g:\modis\TEMP\raszter\layer_stack.vrt g:\modis\TEMP\raszter\*.tif&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/sagagis/shell.png&quot; class=&quot;image3&quot; alt=&quot;Az OSGeo4W Shell felülete: a gdalbuildvrt használati útmutatója kiíratva&quot; /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;-separate&lt;/code&gt; logikai argumentumot megadva külön sávokba helyezi a képeket (ha ezt lehagynánk, akkor virtuális mozaikot készítene nekünk a GDAL), utána következik a kimenet és a bemenet. Ebben a sorrendben! Az elérési útvonalakat pedig módosítsátok, ha szükséges.&lt;/p&gt;

&lt;p&gt;Indítsuk el a &lt;strong&gt;saga_gui.exe&lt;/strong&gt;-t, utána a menüsorban válasszuk ki a &lt;strong&gt;File -&amp;gt; Open&lt;/strong&gt; parancsot (vagy a mappa ikonra is kattinthatunk a fájl megnyitásához) és nyissuk meg a virtuális raszterünket (&lt;code class=&quot;highlighter-rouge&quot;&gt;layer_stack.vrt&lt;/code&gt;)! Utána navigáljunk el ide: &lt;strong&gt;Geoprocessing -&amp;gt; Spatial and Geostatistics -&amp;gt; Grids -&amp;gt; Save Grid Statistics to Table&lt;/strong&gt;. Nyissuk meg az eszközt! A &lt;strong&gt;Grid Systems&lt;/strong&gt;-nél adjuk meg grid rendszerünket (a raszter terjedelem és felbontás) a legördülő listából. Utána a &lt;strong&gt;Grids&lt;/strong&gt;-nél a &lt;code class=&quot;highlighter-rouge&quot;&gt;...&lt;/code&gt; gombra kattintva a felugró kéthasábos ablak bal oldali oszlopában válasszuk ki a képkötegünket és a dupla vagy a szimpla nyílra kattintva pakoljuk át a jobb oldali ablakba (így lesz kiválasztva), majd kattintsunk az oké gombra! A táblázat részt hagyjuk úgy, ahogy van. Végül válasszuk ki, hogy milyen statisztikákat számoljon a képekre, és kattintsunk az okéra.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/sagagis/saga_gui_1.png&quot; class=&quot;large&quot; alt=&quot;Grid statisztikák mentése táblázatba eszköz&quot; /&gt;
&lt;br /&gt;
A létrehozott táblázatra kattintsunk jobb egérgombbal és válasszuk ki a &lt;strong&gt;„mentés mint”&lt;/strong&gt; opciót és mentsük el .txt formátumba. Ez utána könnyedén beilleszthető az MS Excel-be vagy más táblázatkezelő szoftverbe.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/sagagis/saga_gui_2.png&quot; class=&quot;large&quot; alt=&quot;A statisztikákat tartalmazó táblázat exportálása szöveges formátumba&quot; /&gt;
&lt;br /&gt;
Feltöltöttem nektek a Google Drive-ra a MODIS minta-adatbázisomat (&lt;a href=&quot;https://drive.google.com/open?id=0B8pLujeireG7YjBmWTMtbm85UzQ&quot;&gt;&lt;strong&gt;modis_sample_data.rar&lt;/strong&gt;&lt;/a&gt;, 561 MB, kitömörítve 2,71 GB), amin gyakorolhatjátok a parancssori adatfeldolgozást. A batch szkriptet megtaláljátok a &lt;a href=&quot;https://github.com/SalsaBoy990/saga_gis_batch&quot;&gt;&lt;strong&gt;saga_gis_batch&lt;/strong&gt;&lt;/a&gt; repository-mban.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;&lt;strong&gt;Házi feladat:&lt;/strong&gt; Készíts egy tudományos színvonalú elemzést egy tetszőlegesen választott mintaterület erdőiben (pl. Keszthelyi-hegység) bekövetkezett változásokról az NDVI adatok alapján, 2000 és 2016 között! Milyen kapcsolat áll fenn a megfigyelt változások és az éves meteorológiai viszonyok között? (A minta-adatbázisban az ország egész területére megvannak az NDVI-képek.) A Keszthelyi-hegységet azért ajánlom mintaterületnek, mert ott egy igen jelentős erdőpusztulás következett be 2011-től kezdődően. Ennek okainak feltárása egy nagyon jó BSc-s szakdolgozat témája lehet.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ajánlott-irodalom&quot;&gt;Ajánlott irodalom&lt;/h2&gt;

&lt;ul class=&quot;no-decoration-18px&quot;&gt;
    &lt;li&gt;&lt;em&gt;Gulácsi A. - Kovács F. (2015).&lt;/em&gt; &lt;a href=&quot;http://www.tajokologiailapok.szie.hu/pdf/201502/04_Gulacsi_Kovacs.pdf&quot;&gt;Aszályvizsgálat lehetősége MODIS műholdképekből számított spektrális indexekkel Magyarországon.&lt;/a&gt;Tájökológiai Lapok 13(2), pp. 235-248.
    &lt;/li&gt;
    &lt;li&gt;
    &lt;em&gt;Gulácsi A. - Kovács F. (2015).&lt;/em&gt; &lt;a href=&quot;http://publicatio.bibl.u-szeged.hu/11921/&quot;&gt;Drought monitoring with spectral indices calculated from MODIS satellite images in Hungary.&lt;/a&gt; Journal of Environmental Geography 8(3-4), pp. 11-20.
    &lt;/li&gt;
    &lt;li&gt;
    &lt;em&gt;Rouse, J. W. - Haas, H. R. - Schell, A. J. - Deering, W. D. (1973).&lt;/em&gt; &lt;a href=&quot;https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19740022614.pdf&quot;&gt;Monitoring vegetation systems in the Great Plains
with ERTS.&lt;/a&gt; Third ERTS Symposium, NASA SP-351 1. pp. 309–317. 
    &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 16 Sep 2017 20:50:00 +0200</pubDate>
        <link>http://localhost:4000//tudomany/2017/09/16/parancssor_a_geoinformatikaban.html</link>
        <guid isPermaLink="true">http://localhost:4000//tudomany/2017/09/16/parancssor_a_geoinformatikaban.html</guid>
      </item>
    
      <item>
        <title>Rövid elméleti bevezető a JavaScript nyelvbe, 2. rész.</title>
        <description>&lt;p&gt;Az &lt;a href=&quot;http://www.newgeographer.com/tudomany/2017/08/29/javascript_01.html&quot;&gt;előző részben&lt;/a&gt; az objektum-orientált paradigmáról írtam, valamint a JavaScript bemutatásába kezdtem bele. Az alábbi dolgokra tértem ki: a JavaScript interpretáló nyelv, vagyis a fordítás futási időben történik; az ECMAScript szabványok; gyengén típusos nyelv; két adattípus létezik: a primitív (változók) és a referencia (objektumok); a primitív típusok nem, míg a referencia típusok mutálódnak; az automatikus szemétgyűjtés miatt nem kell foglalkoznunk a dinamikus tárhelyek felszabadításával (nincsen destruktor), továbbá nincsenek mutatók, amiken keresztül hozzáférhetnénk a memóriacímekhez; egy tömb példáján keresztük rávilágítottam a sekély és a mély másolás különbségére; az implicit típuskonverziókra és a szigorú azonosság, illetve szigorú nemegyenlőség operátorokra is kitértem; leírtam, hogy a JS Unicode karakterkészletet használ, illetve a számokat 64 bites lebegőpontos formátumban tárolja el. Kitértem a hamisértékekre is.&lt;/p&gt;

&lt;p&gt;És most jön a folytatás, az alábbi részekkel, ebben a sorrendben:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;A &lt;strong&gt;függvény- és a blokkhatókör&lt;/strong&gt; közötti különbség, &lt;strong&gt;felemelés&lt;/strong&gt; (hoisting),&lt;/li&gt;
  &lt;li&gt;A globális objektum (&lt;code class=&quot;highlighter-rouge&quot;&gt;Window&lt;/code&gt;),&lt;/li&gt;
  &lt;li&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;use strict&quot;&lt;/code&gt; pragma,&lt;/li&gt;
  &lt;li&gt;Objektumok és függvények, illetve objektum literál és függvény szintaxis,&lt;/li&gt;
  &lt;li&gt;Tömbök és tömbszerű objektumok,&lt;/li&gt;
  &lt;li&gt;Hozzáférés az objektumok tulajdonságaihoz.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;a-függvényhatókör-és-a-felemelés-hoisting&quot;&gt;A függvényhatókör és a felemelés (hoisting)&lt;/h2&gt;

&lt;p&gt;Mi a függvényhatókör? Ezt néhány példával lehet a legegyszerűbben elmagyarázni. A blokkhatókört már megszokhattuk más nyelvekben, így például a C-ben, ezért furcsának tűnhet elsőre, amit bemutatok.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function foo () {
    console.log(&quot;i = &quot; + i); //=&amp;gt; i = undefined
    for (var i = 0; i &amp;lt; 10; i++) {
        /* üres ciklus */;
    }
    console.log(&quot;i = &quot; + i); //=&amp;gt; i = 10
}
foo();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; ciklus előtt és után is hozzáférhető az &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; változó. Ha blokk hatókör lenne érvényben, akkor az &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; kizárólag a for ciklus &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;/code&gt; blokkján belül lenne hozzáférhető, de ez a függvény hatókörnél nincsen így, ugyanis ebben az esetben a blokkon kívül is hozzáférhető &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;, az éppen aktuális függvényen belül.&lt;/p&gt;

&lt;p&gt;Mint említettem, a &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; ciklus előtt hozzáférhető az &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;, viszont az értéke &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt; lesz, mivel az értékadás csak  később, a &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; ciklusba ágyazottan történik (alapértelmezetten minden deklarált változó értéke &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;). &lt;strong&gt;Egy függvényen belül deklarált változó hatóköre kiterjed az egész függvényre&lt;/strong&gt; és a &lt;strong&gt;változók felemelése&lt;/strong&gt; (hoisting) történik a függvény első sorába. Az &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; változó felemelődik. Az előző kódrészlet egyenértékű ezzel:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function foo () {
    var i; // Felemelődés az első sorba.
    console.log(&quot;i = &quot; + i); //=&amp;gt; i = undefined
    for (i = 0; i &amp;lt; 10; i++) {
        /* üres ciklus */;
    }
    console.log(&quot;i = &quot; + i); //=&amp;gt; i = 10
}
foo();
console.log(&quot;i = &quot; + i); // Referenciahiba lesz.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Természetesen függvényen kívül nem elérhető az &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;. A kód utolsó sora referenciahibát fog dobni (&lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; nincs definiálva).&lt;/p&gt;

&lt;p&gt;A változó hatókör a kód azon régiója, amiben definiáltuk a változót. A globális változók globális hatókörrel rendelkeznek, tehát a forráskódban mindenhol definiálva vannak (hozzáférhetők). Ezzel szemben a függvényen belül deklarált változók lokálisak, és csak az adott függvényen (függvényhatókörön) belül hozzáférhetők. Kívülről nem.&lt;/p&gt;

&lt;p&gt;Ha ugyanolyan nevű lokális változót deklarálunk a függvényen belül, akkor az elrejti a globális változót, így a két &lt;code class=&quot;highlighter-rouge&quot;&gt;scope&lt;/code&gt; változó nem ugyanaz a változó:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var scope = &quot;globális&quot;;
function checkScope() {
    var scope = &quot;lokális&quot;;
    return scope;
}
checkScope(); //=&amp;gt; lokális
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;De mi történik ebben az esetben?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var scope = &quot;globális&quot;;
function checkScope() {
    scope = &quot;lokális&quot;;
    return scope;
}
checkScope(); //=&amp;gt; lokális
console.log(scope); //=&amp;gt; lokális
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A függvényen belül lehagytam a &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;-t, ezért az a &lt;code class=&quot;highlighter-rouge&quot;&gt;scope&lt;/code&gt; a globális változó, aminek az értékét sikeresen felülírtuk &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;lokális&quot;&lt;/code&gt;-ra.&lt;/p&gt;

&lt;p&gt;A lokális változókat tekinthetjük egy objektum tulajdonságainak. Minden kódrészlethez kapcsolódik egy &lt;strong&gt;hatókör-láncolat&lt;/strong&gt; (scope chain), ami objektumok egy listája, ami a hatókörökhöz tartozó változókat definiálja. Például amikor a JS egy &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; változó értékét keresi, akkor a hatókörlánc első objektumában keresi először. Ha ennek van &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; tulajdonsága, akkor azt használja. Ha nem található ilyen nevű változó, akkor a következő objektumban keresi, és így tovább, míg végül eljutunk a globális objektumig. Ha ott sem találja &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;-et, akkor referenciahiba lép fel (&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; nem található). Az előbbi példában a függvényen belül a &lt;code class=&quot;highlighter-rouge&quot;&gt;scope&lt;/code&gt; változó értékét módosítottuk. No de melyik &lt;code class=&quot;highlighter-rouge&quot;&gt;scope&lt;/code&gt; változót? A &lt;code class=&quot;highlighter-rouge&quot;&gt;checkScope()&lt;/code&gt; függvényen belül nincsen &lt;code class=&quot;highlighter-rouge&quot;&gt;scope&lt;/code&gt; változó deklarálva (nem használtuk a &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;-t). Ilyenkor a JS értelmező a következő, fölötte levő szinten keresi a &lt;code class=&quot;highlighter-rouge&quot;&gt;scope&lt;/code&gt;-ot. Ez a globális objektum, és itt megtalálja a globális &lt;code class=&quot;highlighter-rouge&quot;&gt;scope&lt;/code&gt; változót.&lt;/p&gt;

&lt;p&gt;A hatókörlánc a JS legfelső szintjén (az a kódrész, ami a függvénydefiníciókon kívül van) egyetlen objektumból áll: ez a globális objektum.&lt;/p&gt;

&lt;p&gt;Természetesen az &lt;strong&gt;ES6&lt;/strong&gt;-tól kezdődően a függvényhatókörű &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; helyett használhatjuk a blokkhatókörű &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;-et, így a függvényhatókörnél jelentkező szoktalan jelenségek nem lépnek fel. Szintén bevezetésre került a &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;, ami egy konstans, azaz állandó érték jelölésére szolgál. Egy konstansnak kötelező értéket adni annak deklarációjakor. Ezután az értéke semmilyen módon nem lesz megváltoztatható.&lt;/p&gt;

&lt;p&gt;Az előző részben említettem, hogy a webböngészők még nem implementálták az új nyelvi elemek  egy jó részét, tehát kliens oldali kódban nem biztos, hogy működni fognak. Szerver oldalon (pl. Node.js) már támogatottak, ott nyugodtan használd azokat, beleértve az egyszerűsített függvényszintaxist a callback függvényeknél! Az aszinkron függvényhívásról máskor írok.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;a-globális-objektum-window&quot;&gt;A globális objektum (Window)&lt;/h2&gt;

&lt;p&gt;Említettem többször is a &lt;strong&gt;globális objektum&lt;/strong&gt;ot. Ez egy szokványos JavaScript objektum, ami  rendkívül fontos szerepet játszik. &lt;strong&gt;A globális objektum tulajdonságai globálisan definiáltak&lt;/strong&gt;, vagyis hozzáférhetők a programunk számára:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;olyan globális tulajdonságok, mint például az &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;, az &lt;code class=&quot;highlighter-rouge&quot;&gt;Infinity&lt;/code&gt; és a &lt;code class=&quot;highlighter-rouge&quot;&gt;NaN&lt;/code&gt;,&lt;/li&gt;
  &lt;li&gt;olyan globális függvények mint az &lt;code class=&quot;highlighter-rouge&quot;&gt;isNaN()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;parseInt()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;eval()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;setTimeout()&lt;/code&gt; stb.,&lt;/li&gt;
  &lt;li&gt;konstruktor függvények: &lt;code class=&quot;highlighter-rouge&quot;&gt;Date()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;RegExp()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;String()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Object()&lt;/code&gt; és &lt;code class=&quot;highlighter-rouge&quot;&gt;Array()&lt;/code&gt;,&lt;/li&gt;
  &lt;li&gt;olyan globális objektumok, mint a &lt;code class=&quot;highlighter-rouge&quot;&gt;Math&lt;/code&gt; és a &lt;code class=&quot;highlighter-rouge&quot;&gt;JSON&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A kliens oldali JavaScript-ben a &lt;code class=&quot;highlighter-rouge&quot;&gt;Window&lt;/code&gt; objektum a böngészőablakban található összes JS kódunk globális objektumaként funkcionál. Például a &lt;code class=&quot;highlighter-rouge&quot;&gt;console&lt;/code&gt; objektum a megnyitott böngészőablakunk konzolja. Ennek a &lt;code class=&quot;highlighter-rouge&quot;&gt;log()&lt;/code&gt; metódusát szoktuk meghívni, ha a konzolra akarunk írni. A &lt;code class=&quot;highlighter-rouge&quot;&gt;console&lt;/code&gt; objektum is része a globális objektumnak. Így tudjuk lekérdezni a &lt;code class=&quot;highlighter-rouge&quot;&gt;Window&lt;/code&gt; objektum összes tulajdonságát:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* A window a Window objektum önmagát meghivatkozó tulajdonsága.
 * Ezen a referencián keresztül férünk hozzá a globális objektumhoz.
 */
for (var prop in window) {
    console.log(prop);
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;a-szigorú-mód-strict-mode-és-a-js-korlátozása&quot;&gt;A szigorú mód (“strict mode”) és a JS korlátozása&lt;/h2&gt;

&lt;p&gt;A JS-ben egyaránt vannak &lt;strong&gt;jó és rossz részek&lt;/strong&gt;. &lt;strong&gt;Douglas Crockford&lt;/strong&gt; (neves JS guru) szerint korlátozni kell a JS programozási nyelvet, és &lt;strong&gt;kizárólag csak a jó részeket&lt;/strong&gt; használni belőle. Ezzel jobb programokat írunk és jobb programozóvá is válunk. Crockford jóvoltából rendelkezésünkre áll a &lt;a href=&quot;http://www.jslint.com/&quot;&gt;JSLint&lt;/a&gt; kódellenőrző, ami megvizsgálja, hogy a programunk megfelel-e a szigorúbb követelményeknek (beleértve a szintaktikai megfontolásokat - magyarul hogyan nézzen ki a kód), és csak a jó részeket alkalmazza. Az ajánlott irodalomban feltüntettem Crockford könyvét. Akit bővebben érdekel, utánanézhet.&lt;/p&gt;

&lt;p&gt;Az egész korlátozás egyrészt a kód jobb értelmezhetőségét, másrészt pedig a biztonság növelését szolgálja. A kliens oldali JS sebezhető a támadásokkal szemben a hekkerek részéről, így célszerű olyan kódot írni, ami biztonságosabb. Például nem használ &lt;code class=&quot;highlighter-rouge&quot;&gt;eval&lt;/code&gt;-t ellenőrzés nélkül. Az &lt;code class=&quot;highlighter-rouge&quot;&gt;eval&lt;/code&gt; a JavaScript fordítót hívja meg egy sztringre, ami JavaSript kódot tartalmaz, amit végrehajt. Az &lt;code class=&quot;highlighter-rouge&quot;&gt;eval&lt;/code&gt; használatát lehetőség szerint kerüld el! Egyébként nagyon ritkán van szükség rá.&lt;/p&gt;

&lt;p&gt;Az alábbi kódrészlet állandóan egy felugró ablakot hoz létre egy végtelen ciklus segítségével:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Idegesítő kód.
var text = &quot;for (;;) alert(\&quot;Muhaha!!\&quot;);&quot;;
/* Nem vizsgálok rá a sztring tartalmára
 * és úgy hívom meg rá az eval-t. */
eval(text);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ha nem ismerjük a sztring tartalmát, akkor előfordulhatnak benne kártékony, vagy legalábbis kellemetlen kódrészletek. A fenti példát módosítva elkerülhetjük, hogy a kód lefusson:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var text = &quot;for(;;) alert(\&quot;Muhaha!!\&quot;);&quot;;

var pattern = /for/; // egy RegExp objektum.
// Most rávizsgálok a sztring tartalmára
var result = text.match(pattern);
if (result !== null) {
    throw &quot;A for ciklusok nem engedélyezettek!&quot;;
} else {
    eval(text);
} // Mi történik?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Egy &lt;code class=&quot;highlighter-rouge&quot;&gt;RegExp&lt;/code&gt; objektum (a következő részben bővebben) segítségével megkeresem a szövegben található &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; kulcsszót. A &lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt; jelek közötti kifejezést, vagyis a &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;for&quot;&lt;/code&gt;-t keressük a &lt;code class=&quot;highlighter-rouge&quot;&gt;RegExp&lt;/code&gt; objektum &lt;code class=&quot;highlighter-rouge&quot;&gt;match()&lt;/code&gt; metódusának segítségével. Ha nem talál a sztringünkben ilyet, akkor &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;-t ad vissza. Hibát dobok, ha találtam &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; ciklust, ami leállítja a kód futását. A hibakezelés a következő részben lesz kifejtve.&lt;/p&gt;

&lt;p&gt;Az ECMAScript5 szabványban bevezették a &lt;strong&gt;szigorú módot&lt;/strong&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;strict mode&quot;&lt;/code&gt;), ami bizonyos korlátozásokat vezetett be a biztonság növelésre. Több hibaellenőrzés is van benne (több hibát is jelez a fordító, ami leállítja a kód futását). Nagyon erősen ajánlott a használata, mivel rengeteg sérülékenység van a JS-ben, amit a hekkerek kihasználhatnak. Nem tekinthető jó kódnak, ami nem alkalmazza ezt a fontos korlátozást. Bővebb tájékoztatást a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;Mozilla honlapján&lt;/a&gt; találtok. A GEE kódszerkesztőjében is &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;strict mode&quot;&lt;/code&gt; van érvényben. Használata egyszerű, az utasítások elé kell beilleszteni:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&quot;use strict&quot;;
var v = &quot;Szigorú módban vagyok!&quot;;

// Referenciahibát dob a fordító:
x = &quot;A globális objektumnak nem adhatunk tulajdonságot&quot;;

// Függvényeknél:
var f = function (a) {
    &quot;use strict&quot;;
    /* utasítások */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;objektumok-és-függvények-létrehozása&quot;&gt;Objektumok és függvények létrehozása&lt;/h2&gt;

&lt;p&gt;Az egyik módja a függvények létrehozásának, ha egy &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; változóba tároljuk el a függvényt. Az objetum literál létrehozása &lt;code class=&quot;highlighter-rouge&quot;&gt;var o = { x: 0 };&lt;/code&gt; szintaxissal történik. Mivel ezek utasítások és nem kifejezések szükség van az utasítást záró &lt;code class=&quot;highlighter-rouge&quot;&gt;;&lt;/code&gt;-ra.&lt;/p&gt;

&lt;figcaption class=&quot;code-caption&quot;&gt;
Az 1. JavaScript példa: Objektum literál, tulajdonságok és metódusok.
&lt;/figcaption&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var square = function (x) {
    return x * x;
};
console.log(&quot;A megadott szám négyzete: &quot; + square(200));

var point = {
  x: 0,
  y: 0,
  print_1: function () {
     console.log(&quot;x: &quot; + point.x + &quot;, y: &quot; + point.y);
  } 
};
point.print_2 = function () {
  console.log(&quot;x: &quot; + point.x + &quot;, y: &quot; + point.y);
};
point.x = 5, point.y = 15;
point.print_1(); //=&amp;gt; x: 5, y: 15
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A függvény szintaxissal felírt függvények kifejezések, tehát nem kell ; utánuk. A példában szereplő &lt;code class=&quot;highlighter-rouge&quot;&gt;Point()&lt;/code&gt; függvény egy pont „osztály” konstruktora. A konstruktor egy olyan függvény, amit objektumok létrehozására, illetve azok tulajdonságainak inicializálására használunk. A prototípusos öröklést a következő részre tartogtatom. Az osztályt azért tettem idezőjelbe, mert mint már említettem, nincsenek igazi osztályok (&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;) a JS-ben.&lt;/p&gt;

&lt;figcaption class=&quot;code-caption&quot;&gt;A 2. JavaScript példa: Függvény szintaxis, konstruktor és osztály.&lt;/figcaption&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function square (x) {
    return x * x;
}
console.log(&quot;A megadott szám négyzete: &quot; + square(200));

/* Ez egy pont osztály konstruktora. */
function Point(x, y) {
    this.x = x || 0;
    this.y = x || 0;

    this.print = function () {
        console.log(&quot;x: &quot; + this.x + &quot;, y: &quot; + this.y);
    };
}
/* Az osztály példányosítása: egy változóban
 * eltároljuk az objektumot.
 */
var object = new Point(10, 20);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;this.x = x || 0;&lt;/code&gt; utasításban a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; az éppen aktuális objektumpéldányra mutat (egy referencia), amin keresztül hozzáférünk az éppen aktuális objektum tulajdonságaihoz. A konstruktor önmagában nem hoz létre egy új objektumot, hanem azt nekünk kell megtennünk a new kulcsszó használatával, például: &lt;code class=&quot;highlighter-rouge&quot;&gt;var object = new Point(10, 20);&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Ha nem adunk át egyetlen argumentumot sem a konstruktornak, akkor &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; lesz az &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; és &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; tulajdonság értéke. Miért? A logikai VAGY operátor (&lt;code class=&quot;highlighter-rouge&quot;&gt;||&lt;/code&gt;) abban az esetben, &lt;strong&gt;ha mindkét részkifejezése hamis, akkor a jobb oldali operandusz értékét adja vissza&lt;/strong&gt;, vagyis a nullát.&lt;/p&gt;

&lt;p&gt;A logikai operátorok (ÉS, VAGY) &lt;strong&gt;rövidzár kiértékelést&lt;/strong&gt; alkalmaznak. ÉS kapcsolat esetén (&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&amp;amp;&lt;/code&gt; operátor) akkor igaz az összetett kifejezés, ha mindegyik feltétel igaz (ha már a bal oldali részkifejezés hamis, akkor az egész kifejezés hamis - fölösleges megvizsgálni a jobb oldali részkifejezést). VAGY kapcsolat esetén legalább az egyik feltételnek igaznak kell lennie, hogy az egész kifejezés igaz legyen. A &lt;code class=&quot;highlighter-rouge&quot;&gt;x || 0;&lt;/code&gt; kifejezésben, ha igaz értéket adunk meg az x helyére, akkor a &lt;code class=&quot;highlighter-rouge&quot;&gt;||&lt;/code&gt; operátor már nem vizsgál rá a második kifejezésre, hanem visszadja az első kifejezés értékét. További információ a logikai operátorokról &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators&quot;&gt;itt található&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Felhívom itt a figyelmet arra, hogy vannak az úgynevezett &lt;strong&gt;„hamisértékek”&lt;/strong&gt; (falsy values), amelyek mindig &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;-nak értékelődnek ki, ezek: &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;&quot;&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;NaN&lt;/code&gt;! Ha ezek bármelyikét is megadnánk az &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; argumentum helyére, akkor is megfelelően működik ez a roppant hasznos technika.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Alapértelmezett függvényargumentumokat&lt;/strong&gt; az ES5-ben még nem implementálták (viszont egyes böngészők már támogathatják), de a fenti technikával megoldható. Az ES6 szintaxis így néz ki:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function Point(x = 0, y = 0) {
    this.x = x;
    this.y = y;
}
var p = new Point(45);
console.log(p); // Mit fog kiírni?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A Mozilla Firefox és a Google Chrome esetén működik. A többi böngészőnél nem néztem.&lt;/p&gt;

&lt;p&gt;Egy &lt;strong&gt;nagyon fontos különbség van&lt;/strong&gt; az objektum literál (illetve változó) szintaxis és a függvény/konstruktor szintaxis között. Ha objektum literál segítségével hozunk létre egy objektumot, akkor az a deklarációkor létrejön. A deklaráció előtt nem használható (ugyanúgy, mint egy egyszerű változó esetén). A konstruktor esetén viszon egy függvényt hozunk létre, amit ha meghívunk, létrehozzuk az objektum egy példányát (tetszőleges számú példányt hozhatunk létre). A függvény definíció előtt is létrehozhatunk objektum példányokat. A példa talán érthetőbb lesz:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Példányosítás a konstruktor definíciója előtt.
var x = new Point(233,455);
x.print();
function Point(x, y) {
    this.x = x || 0;
    this.y = x || 0;
    this.print = function () {
        console.log(&quot;x: &quot; + this.x + &quot;, y: &quot; + this.y);
    };
}

// Objektum literál esetén nem működik.
/* Típushibát dob, hiszen még a point objektum nem létezik,
 * a következő sorban hozzuk létre! */
point.print();
var point = {
  x: 0,
  y: 0,
  print: function () {
     console.log(&quot;x: &quot; + point.x + &quot;, y: &quot; + point.y);
  } 
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;tömbök-tömbszerű-objektumok-és-hozzáférés-az-objektumok-tulajdonságaihoz&quot;&gt;Tömbök, tömbszerű objektumok és hozzáférés az objektumok tulajdonságaihoz&lt;/h2&gt;

&lt;p&gt;A tömbök is objektumok. Az objektumok tulajdonságokból épülnek fel, amelyek lehetnek változók, tömbök, tömbszerű objektumok, objektumok és függvények. Értsétek ezt úgy, hogy tetszőlegesen egymásba ágyazhatók. &lt;strong&gt;A tulajdonságok azonosító-érték párok.&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;x: 6&lt;/code&gt; esetén az &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; azonosító a &lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt;-os értéket jelöli, amit valamelyik memóriacímen tároljuk. Emlékezzünk vissza, hogy az objektumok mind referenciák, amelyek a dinamikus memóriában lefoglalt tárhelyre hivatkoznak, ahol megtalálhatók az objektum tulajdonságai. Az objektumok tulajdonságaihoz a &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt; &lt;strong&gt;pont operátor&lt;/strong&gt; segítségével férhetünk hozzá (is), míg a tömbök esetén a &lt;code class=&quot;highlighter-rouge&quot;&gt;[0]&lt;/code&gt; &lt;strong&gt;tömbelem-hivatkozás&lt;/strong&gt; segítségével. A függvények esetén az érték maga a függvény teste, az azonosító pedig a függvény neve.&lt;/p&gt;

&lt;figcaption class=&quot;code-caption&quot;&gt;A 3. JavaScript példa: Tömbök, tömbszerű objektumok és az objektum tulajdonságok elérése.&lt;/figcaption&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// A tömbök.
var ures_tomb = [];
var tomb = [1, 2, 3, 4, 5];
console.log(tomb[0]);

/* Elemek hozzáadása a tömb végére. */
tomb.push(-200, 1552, 9999);
/* Az utolsó elem törlése. */
tomb.pop();
/* A tömb elemeinek kiíratása. */
for (var i = 0; i &amp;lt; tomb.length; i++) {
    console.log(&quot;A tömb &quot; + (i+1) + &quot;. eleme: &quot; + tomb[i]);
}
/* Ezzel a 4. index utáni elemeket törlöm. */
tomb.length = 4;

var array = [
    { x: 0 },
    &quot;kizomba&quot;,
    26,
    true,
    function(nev) { console.log(&quot;Helló, &quot; + nev + &quot;!&quot;); }
];
// Utolsó elem.
array[array.length-1];
// Hívjuk is meg a függvényt!
array[array.length-1](&quot;Jancsi&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A tömbök tulajdonságait a tömb &lt;strong&gt;elemeinek&lt;/strong&gt; hívjuk, amelyek azonosítója szám. Ezt a számot &lt;strong&gt;indexnek&lt;/strong&gt; nevezzük. &lt;strong&gt;A többi objektumnál a tulajdonságok azononosítói&lt;/strong&gt; nem számok, hanem &lt;strong&gt;sztringek&lt;/strong&gt;. A tömböknek van egy hossz / length tulajdonságuk, ami az éppen aktuális tömbelemek számát, a &lt;strong&gt;tömb méretét&lt;/strong&gt; tartalmazza. A fenti &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; ciklus helyett használhatunk &lt;strong&gt;for-in ciklust&lt;/strong&gt; is, ami egy változón keresztül iteráltatja egy objektum tulajdonságait:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* Ugyanaz, mint az előző, csak for-in ciklussal. */
var temp;
for (var p in tomb) {
  /* Számmá kellett konvertálni. */
  temp = Number(p)+1;
  console.log(&quot;A tömb &quot; + temp + &quot;. eleme: &quot; + tomb[p]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Tömbszerű objektumokat&lt;/strong&gt; is létrehozhatunk (ilyen az &lt;code class=&quot;highlighter-rouge&quot;&gt;arguments&lt;/code&gt; tulajdonság, ami egy tömbszerű objektum, de erről majd később), ha azonosítónak számot adunk meg, valamint szükség van az elemek számának eltárolására egy változóba (&lt;code class=&quot;highlighter-rouge&quot;&gt;length&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* Tömbszerű objektumok. */
/* Üres objektum. */
var a = {};
var i = 0;
while (i &amp;lt; 10) {
  a[i] = i * i;
  i++;
}
/* A tömböknek van hossz tulajdonsága. Itt is létrehozzuk. */
a.length = i;

var osszeg = 0;
for (var j = 0; j &amp;lt; a.length; j++) {
  osszeg += a[j];
}
console.log(osszeg);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Az előbbiekből következik, hogy az objektum tulajdonságok elérése kétféleképpen történhet: az &lt;code class=&quot;highlighter-rouge&quot;&gt;objektum.tulajdonsag&lt;/code&gt; és az &lt;code class=&quot;highlighter-rouge&quot;&gt;objektum[&quot;tulajdonsag&quot;]&lt;/code&gt; szintaxissal. A tömbök esetén csak a &lt;code class=&quot;highlighter-rouge&quot;&gt;[]&lt;/code&gt; zárójelek segítségével.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* A két példával ezelőtti &quot;a&quot;
 * tömbszerű objektum szerepel itt.
 * A`for in` ciklus a length tulajdonságot is kiírja a konzolra! */
for (var prop in a) {
    console.log(prop + &quot; = &quot; + a[prop]);
}
// Hozzáférés az objektumok tulajdonságaihoz.
var o = {};
o.x = 10, o.y = 25;
o.print = function () {
    console.log(&quot;x: &quot; + o.x + &quot;, y: &quot; + o.y);
};
console.log(o[&quot;x&quot;]);
console.log(o.y);
// A print metódus meghívása.
o[&quot;print&quot;]();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A következő rész tartalma:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Mi a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;, honnan származik?&lt;/li&gt;
  &lt;li&gt;Aszinkron programozás, bezárás (closure) és a privát hozzáférés&lt;/li&gt;
  &lt;li&gt;Egymásba ágyazott függvények&lt;/li&gt;
  &lt;li&gt;Kivételkezelés (exeption handling)&lt;/li&gt;
  &lt;li&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;RegExp&lt;/code&gt; objektumok&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ajánlott-irodalom&quot;&gt;Ajánlott irodalom&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Douglas Crockford (2008). &lt;a href=&quot;https://www.amazon.com/exec/obidos/ASIN/0596517742/wrrrldwideweb&quot;&gt;JavaScript: The Good Parts. 1th Edition.&lt;/a&gt; O’Reilly, USA.&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 03 Sep 2017 01:11:00 +0200</pubDate>
        <link>http://localhost:4000//tudomany/2017/09/03/javascript_02.html</link>
        <guid isPermaLink="true">http://localhost:4000//tudomany/2017/09/03/javascript_02.html</guid>
      </item>
    
      <item>
        <title>Rövid elméleti bevezető a JavaScript nyelvbe</title>
        <description>&lt;p&gt;A Google Earth Engine (GEE) felhő alapú platform általános bemutatása után (&lt;a href=&quot;http://www.newgeographer.com/tudomany/2017/08/07/google_earth_engine_01.html&quot;&gt;itt elérhető az 1. rész&lt;/a&gt;), ebben a részben egy rövid betekintést nyújtok az objektum-orientált programozásba és felhívom a figyelmet a JavaScript nyelv fontos jellemzőire, hogy hatékonyan ki tudjátok aknázni a GEE-ben rejlő lehetőségeket akár több száz GB-nyi adat gyors feldolgozására, minimális erőfeszítéssel.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Előzetes programozói tapasztalat erősen javallott&lt;/strong&gt;, különben nem sokat értetek meg az egészből. Teljesen mindegy, hogy milyen nyelvet ismersz. A programozói gondolkodás az, ami valóban számít. Az alapelvek, a vezérlési szerkezetek, az algoritmusok stb. mind ugyanazok, csak a szintaxis és a szabvány más.
Én a C nyelven keresztül tanultam meg a programozást, majd utána ismerkedtem meg a C++-szal és az objektum-orientált paradigmával. És csak ezt követően jött a &lt;a href=&quot;https://www.javascript.com/&quot;&gt;JavaScript&lt;/a&gt; (JS).&lt;/p&gt;

&lt;p&gt;A bejegyzésemben megadott kódrészleteket pedig próbáljátok ki! 
Használhatjátok valamelyik böngésző konzolját (Google Chrome esetén: &lt;code class=&quot;highlighter-rouge&quot;&gt;F12&lt;/code&gt;, Firefox esetén &lt;code class=&quot;highlighter-rouge&quot;&gt;CTRL+SHIFT+i&lt;/code&gt;) vagy a GEE kódszerkesztőjét (ebben “strict mode”-ban használhatjátok a JS-t)!&lt;/p&gt;

&lt;p&gt;A programrészleteket egyben letölthetitek &lt;a href=&quot;https://github.com/SalsaBoy990/EarthEngine/blob/master/tutorial2.js&quot;&gt;innen&lt;/a&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;bevezetés-az-objektum-orientált-programozásba&quot;&gt;Bevezetés az objektum-orientált programozásba&lt;/h2&gt;

&lt;p&gt;Ez bevezető csak egy nagyon kurta betekintést nyújt az objektum orientált szemléletbe.&lt;/p&gt;

&lt;p&gt;A programozás célja mindig egy összetett probléma megoldása a számítógép számítási kapacitásának a lehető leghatékonyabb kihasználásával. A programozás során ezt &lt;strong&gt;az összetett problémát fel kell bontanunk kisebb részproblémákra/részlépésekre&lt;/strong&gt; (például az adatok bekérése, a bemenet ellenőrzése, különböző műveletek, amelyeket az adatokon végzünk, adatok mentése stb.), amelyek megoldására külön függvényeket írunk. Ezáltal átláthatóvá válik számunkra a program működése.&lt;/p&gt;

&lt;p&gt;A “hagyományos” nyelvekben (mint például a C-ben) megtanultuk, hogy &lt;strong&gt;a változókat és a függvényeket külön kezeljük&lt;/strong&gt;, valamint a függvényeket a változók argumentumként való átadásával hívjuk meg. (Az argumentum az az érték, amit bemenő paraméterként megadunk egy függvénynek.). Lehet érték szerint, mutató szerint és referencia szerint paramétert átadni. A JavaScript-ben &lt;strong&gt;kizárólag érték szerinti paraméterátadás&lt;/strong&gt; létezik (az objektum referenciák is érték szerint adódnak át)!&lt;/p&gt;

&lt;p&gt;Az objektum orientált nyelveknek három alapelve van:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;egységbezárás&lt;/strong&gt; / enkapszuláció (encapsulation)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;öröklés&lt;/strong&gt; (inheritance)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;többalakúság&lt;/strong&gt; / polimorfizmus (polymorphism)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A klasszikus öröklés (és a polimorfizmus) JavaScript-ben is imitálható, de valójában kizárólag csak &lt;strong&gt;prototípusos öröklés&lt;/strong&gt; létezik a JS-ben. Öröklés helyett &lt;strong&gt;kompozíció&lt;/strong&gt;t is alkalmazhatunk. A prototípusos öröklésről majd máskor írok.&lt;/p&gt;

&lt;p&gt;Csak az &lt;strong&gt;egységbe foglalás&lt;/strong&gt;ba megyünk itt bele: &lt;strong&gt;az objektum-orientált paradigma lényege, hogy együtt kezeljük a változókat és a rájuk meghívandó függvényeket egy osztályban&lt;/strong&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;). Meglepően hangzik, de a JS-ben nincsenek tényleges osztályok, bár úgy programozunk, mintha lennének. Helyesebb inkább objektumokról beszélni (a függvények és a tömbök is objektumok).&lt;/p&gt;

&lt;p&gt;A C++-ban a hozzáférési szintek (&lt;strong&gt;public&lt;/strong&gt;, &lt;strong&gt;protected&lt;/strong&gt; és &lt;strong&gt;private&lt;/strong&gt;) segítségével szabályozhatjuk a tagváltozók és tagfüggvények külső hozzáférését. A C++-ban az osztályok esetén alapértelmezetten privát a hozzáférés, és csak az általunk írt publikus hozzáférésű metódusokon keresztül férhetünk hozzá a tagváltozókhoz. Ez a biztonságot szolgálja. A JavaScript-ben &lt;strong&gt;minden tagváltozó és metódus kívülről hozzáférhető&lt;/strong&gt; és módosítható. A &lt;strong&gt;bezárás&lt;/strong&gt; (&lt;strong&gt;closure&lt;/strong&gt;) alkalmazásával tehetjük priváttá (tehát kívülről nem hozzáférhetővé) az objektumok tulajdonságait.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;belekóstolás-a-javascript-programozási-nyelvbe&quot;&gt;Belekóstolás a JavaScript programozási nyelvbe&lt;/h2&gt;

&lt;p&gt;Ez a nagyon rövid bemutatás csak felületesen érinti a JS néhány jellemzőjét.&lt;/p&gt;

&lt;p&gt;A JavaScript (a későbbiekben: JS), a web nyelve, ECMAScript néven lett szabványosítva. A nevével ellentétben nincs köze a Java-hoz, és nem egyszerű szkriptnyelv, hanem sokkal több annál: egy dinamikus, objektum-orientált, általános célú programozási nyelv.&lt;/p&gt;

&lt;p&gt;A JavaScript &lt;strong&gt;interpretáló nyelv&lt;/strong&gt;, tehát a &lt;strong&gt;fordítás futási időben történik&lt;/strong&gt;: a JS értelmező sorról-sorra halad végig az utasításokon, értelmezi és végrehajtja azokat. Nincsen main() függvény. Ilyen egyszerű. Míg a C esetén először lefordítjuk a forrásfájlt, bináris, futtatható állományt készítve belőle (.exe Windows esetén), majd utána lefuttatunk.&lt;/p&gt;

&lt;p&gt;A legújabb szabvány az &lt;strong&gt;ECMAScript 2017&lt;/strong&gt; (ES8), tavaly az ES7, két éve az ES6 jelent meg. A &lt;strong&gt;webböngészők&lt;/strong&gt; az &lt;strong&gt;ECMAScript5&lt;/strong&gt;-nél újabb szabványokat még nem nagyon implementálták, éppen ezért kocázatos az újabb szabványok szerint kliens oldali kódot írni a webböngészők számára. Minden webböngésző tartalmaz &lt;strong&gt;JavaScript fordító&lt;/strong&gt;t (fordítómotornak is szokták hívni). A &lt;strong&gt;Node.js&lt;/strong&gt; szerver oldali JS keretrendszer például a Google Chrome V8 fordítómotorját használja. Később tervezek foglalkozni ezzel a framework-kkel is.&lt;/p&gt;

&lt;p&gt;A szerver oldalon viszont lehet ES6 szabvány szerint programozni. Például az egyszerűsített függvényszintaxis is használható: &lt;code class=&quot;highlighter-rouge&quot;&gt;(args) =&amp;gt; { /* utasítások */ }&lt;/code&gt; a &lt;code class=&quot;highlighter-rouge&quot;&gt;function (args) { /* utasítások */ }&lt;/code&gt; helyett. Ez az úgynevezett &lt;strong&gt;callback függvényeknél&lt;/strong&gt; hasznos, amelyeknek ugyanis nem kell nevet adni.&lt;/p&gt;

&lt;p&gt;A JS-ben &lt;strong&gt;nincsen &lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt; függvény&lt;/strong&gt;, bár lehet ilyen néven függvényt létrehozni. A &lt;strong&gt;változók típusa változhat&lt;/strong&gt;, ugyanis a JS gyengén típusos nyelv. Azonban a típusos nyelveknél, mint például a C vagy a C++, mindig meg kell adni a változók típusát:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;char&lt;/code&gt; (karakter, ASCII)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt; (egész szám)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt; (lebegőpontos, vagyis törtszám)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt; (kétszeres pontosságú lebegőpontos szám)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt; (sztring, szöveg típusú).&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt; (logikai: &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A JS-ben a &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;&lt;/strong&gt; kulcsszóval hozhatunk létre változókat, amelyekhez bármilyen típusú értéket, objektumot és függvényt is rendelhetünk. Az objektum tulajdonságainál alapértelmezett a &lt;strong&gt;public&lt;/strong&gt; hozzáférés, vagyis kívülről elérhetők és módosíthatók, de ez a viselkedés megváltoztatható. Private hozzáférés is lehetséges a JS-ben a &lt;strong&gt;bezárás&lt;/strong&gt;nak, illetve angulul &lt;strong&gt;closure&lt;/strong&gt;-nek nevezett eljárással.&lt;/p&gt;

&lt;p&gt;Az ES6-ban már lehet használni a &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; helyett a &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;&lt;/strong&gt;-et, aminek már &lt;strong&gt;blokkhatóköre van&lt;/strong&gt;, így egy csomó nem várt “mellékhatástól” megkímél bennünket. Például magának a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;-nek az értéke a kontextustól függ, azonban nem kötődik &lt;strong&gt;függvényhatókör&lt;/strong&gt;höz! A függvényhatókörről és a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;-ről a következő részben lesz szó.&lt;/p&gt;

&lt;p&gt;A JS-ben az aposztróf &lt;code class=&quot;highlighter-rouge&quot;&gt;'&lt;/code&gt; és az idézőjel &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;&lt;/code&gt; egyenértékű és a sztringek jelölésére használatos. De keverni ne keverjük őket! A &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;dupla idézőjeleket&quot;&lt;/code&gt; használjuk inkább. &lt;strong&gt;Unicode karakterkészletet használ&lt;/strong&gt; a JS, így majnem minden írott nyelvet támogat (az Unicode tábla maximum 1 millió 114 ezer 112 különféle betűt és jelet képes  eltárolni, jelenleg több mint 136 ezer karaktert tartalmaz). Ez hatalmas előny. A változónevekben és a függvény nevekben lehet ékezetes karakter is, de ez nem ajánlott programozói gyakorlat. Sőt lehetséges &lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt; nevű függvény/változó is: gondoljunk itt a &lt;strong&gt;jQuery&lt;/strong&gt; keretrendszerre, ahol van egy &lt;code class=&quot;highlighter-rouge&quot;&gt;$()&lt;/code&gt; nevű függvény. Az ékezetes karakterekkel nincsen probléma a JavaScript-ben, mert nem a szörnyű ASCII karaktertáblát használjunk.&lt;/p&gt;

&lt;p&gt;A JS-ben &lt;strong&gt;automatikus szemétgyűjtés&lt;/strong&gt; van (automatic garbage collection), tehát nem kell felszabadítanunk a lefoglalt tárhelyet (a C/C++ esetén csak a &lt;strong&gt;dinamikus memóriakezelés&lt;/strong&gt; esetén kell explicit, azaz magunknak elvégezni a lefoglalt memóraterület felszabadítását), hanem a fordító automatikusan elvégzi: ha egy objektum már nem elérhető – amikor a program már nem tud hivatkozni rá – a fordító automatikusan felszabadítja a lefoglalt memóriaterületet. Éppen ezért &lt;strong&gt;nincsen destruktor&lt;/strong&gt; függvény a JS-ben. &lt;strong&gt;Mutatók sincsenek&lt;/strong&gt;, tehát nem férhetünk hozzá a memóriacímekhez. Helyette &lt;strong&gt;referenciák vannak&lt;/strong&gt;, amiről a JS gondoskodik nekünk.&lt;/p&gt;

&lt;figcaption class=&quot;code-caption&quot;&gt;Az 1. JavaScript programod: Változók és függvények.&lt;/figcaption&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var valtozo = 10;
valtozo = &quot;Helló&quot;;
var f = function (s) {
    console.log(s + &quot;, világ!&quot;);
};
f(valtozo); //=&amp;gt; Helló, világ!
var nev = prompt(&quot;Add meg a keresztneved!&quot;);
console.log(&quot;Szia &quot; + nev + &quot;!&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A JavaScript-ben a &lt;strong&gt;primitív adattípusok&lt;/strong&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, logikai, szám és sztring) &lt;strong&gt;nem mutálódnak&lt;/strong&gt; (immutable), azaz létrehozásuk után az értékük már nem megváltoztatható! Ezek a nyelv legalacsonyabb szintű elemei.&lt;/p&gt;

&lt;p&gt;Hiába hívjuk meg a &lt;code class=&quot;highlighter-rouge&quot;&gt;toUpperCase()&lt;/code&gt; globális metódust (nagybetűssé alakítja a szöveget) a &lt;code class=&quot;highlighter-rouge&quot;&gt;nev&lt;/code&gt; változóra, a &lt;code class=&quot;highlighter-rouge&quot;&gt;nev&lt;/code&gt; változó értékét nem változtatja meg. Ha primitívekre hívunk meg függvényeket, illetve paraméterként átadjuk azokat függvénynek, akkor lokális másolat készül róluk (lefoglalódik számukra új memóriaterület) és a módosítások azokon hajtódnak végre. Az eredeti változó értéke változatlan marad:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var nev = &quot;Juliska&quot;;
console.log(nev.toUpperCase()); //=&amp;gt; JULISKA
console.log(nev); //=&amp;gt; Juliska
nev = nev.toUpperCase();
console.log(nev); //=&amp;gt; JULISKA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Az eredeti változó értéke nem változott! Egyetlen sztring metódus sem képes megváltoztatni azt, hanem egy új sztring értéket adnak vissza (“JULISKA”). Viszont új értéket adhatunk a &lt;code class=&quot;highlighter-rouge&quot;&gt;nev&lt;/code&gt; változónak. A megváltoztathatatlanság nem az értékadásra vonatkozik.&lt;/p&gt;

&lt;p&gt;A primitíveket érték szerint hasonlítjuk össze: &lt;strong&gt;két primitív azonos, ha értékük megegyezik&lt;/strong&gt; (két sztring egyenlő, ha hosszuk és minden egyes karakterük megegyezik):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;console.log(101 === 101); //=&amp;gt; true
console.log(false === false); //=&amp;gt; true
console.log(&quot;róka&quot; === &quot;róka&quot;); //=&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Az &lt;strong&gt;objektumok (beleértve a tömböket és a függvényeket)&lt;/strong&gt; másként viselkednek, mint a primitív típusok, ugyanis ezek &lt;strong&gt;mutálódnak&lt;/strong&gt; (mutable), azaz &lt;strong&gt;értékük megváltoztatható&lt;/strong&gt;. A primitív típusoknál:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var a = 3.14;
var b = a; // Az a változó értékét egy új változóba másoljuk.
a = 4; // Új értéket adunk az eredeti változónak.
alert(b) // 3.14-et ír ki, b nem változott meg.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;De mi a helyzet az objektumoknál, amelyeket &lt;strong&gt;referencia típus&lt;/strong&gt;oknak is nevezünk:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var a = [1, 2, 3]; // Egy 3 elemű tömb létrehozása.
var b = a; // A 'b' tömb ugyanarra a tömbre hivatkozik.
a[0] = 99; // Módosítsuk az eredeti tömböt!
alert(b); // A 'b' elemei is változnak: [99, 2, 3].
console.log(a === b); //=&amp;gt; true
// 'a' és 'b' ugyanarra a tömbre hivatkozik.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Amikor a &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;-hez rendeljük az &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; tömböt, akkor nem egy új másolat jön létre az &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; tömb objektumról, hanem csupán egy referencia, pontosabban a &lt;strong&gt;referencia egy másolata&lt;/strong&gt;, adódik át, ami az &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; tömb címére mutat. Tehát a &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; ugyanarra a tömbre egy második referencia. Tulajdonképpen &lt;strong&gt;sekély másolás&lt;/strong&gt; történik. Mély másolat készítéséhez explicite kell másolnunk az erdeti tömb összes elemét egy újabb memóraterületre (új tömböt hozunk létre):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var a = [1, 2, 3];
var b = [];
for(var i = 0; i &amp;lt; a.length; i++) {
    b[i] = a[i];
}
console.log(a === b); //=&amp;gt; false: különböző tömbök sosem egyenlők.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Az objektumokat &lt;strong&gt;referencia szerint&lt;/strong&gt; különböztetjük meg egymástól: &lt;strong&gt;két objektum akkor sem egyenlő, ha ugyanazokkal a tulajdonságokkal és értékekkel rendelkeznek&lt;/strong&gt;. Két tömb sem egyenlő, mégha megegyezik az összes elemük, és azok sorrendje is. &lt;strong&gt;Csak akkor azonos&lt;/strong&gt; két objektum érték, &lt;strong&gt;ha ugyanarra az objektumra hivatkoznak&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Referencia szerinti értékadás van az objektumok esetén, vagyis nem új másolatokat (magát az objektumot), hanem referenciákat adunk értékül ugyanarról az objektumról. A függvényeknek nem maguk az objektumok adódnak át, hanem csupán a rájuk mutató referenciák másolatai, amin keresztül a függvény hozzáférhet az objektumok megváltoztatható értékeihez. A primitív típusok értékei a &lt;strong&gt;verem&lt;/strong&gt;be (&lt;strong&gt;call stack&lt;/strong&gt;) kerülnek. Ha meghívunk egy függvényt egy primitív változóra, akkor egy lokális másolat készül róla, ami a függvény visszatérése után felszabadul. Az eredeti érték nem változik.&lt;/p&gt;

&lt;p&gt;Az objektumokat a &lt;strong&gt;heap&lt;/strong&gt;-ben (a &lt;strong&gt;dinamikusan lefoglalt&lt;/strong&gt; adatok tárterülete a memóriában) tároljuk el. Például tekintsük a &lt;code class=&quot;highlighter-rouge&quot;&gt;var o = { x:0 };&lt;/code&gt; kifejezést! Mi történik a futáskor? A heap-ben megfelelő méretű tárhely foglalódik le az objektum &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;x:0&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt; tárolására, majd az értékek inicializálódnak. A kifejezés értéke az objektumra mutató hivatkozás lesz &lt;code class=&quot;highlighter-rouge&quot;&gt;o&lt;/code&gt;-n keresztül. Az &lt;code class=&quot;highlighter-rouge&quot;&gt;o&lt;/code&gt; tehát nem magát az objektumot, csak egy referenciát tárol.&lt;/p&gt;

&lt;figcaption class=&quot;code-caption&quot;&gt;A 2. JavaScript példa: Az objektumok mutálódnak, míg a primitívek nem.&lt;/figcaption&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var s = &quot;Alma&quot;;
var o = { nev: &quot;Alma&quot; };

var foo = function (arg) {
    if(arg instanceof Object) { // Objektum-e az arg.
        arg.nev = &quot;Körte&quot;;
    } else {
        arg = &quot;Körte&quot;;
    }
};
foo(s);
foo(o);
console.log(s); //=&amp;gt; &quot;Alma&quot;
console.log(o); //=&amp;gt; &quot;{ nev: &quot;Körte&quot; }&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Összefoglalva tehát, &lt;strong&gt;a Javascript-ben kizárólag érték szerinti paraméterátadás van!&lt;/strong&gt; Az objektumoknál a &lt;strong&gt;referenciák másolatai&lt;/strong&gt; érték szerint adódnak át a függvényeknek (az objektum értékei mutálódnak), míg a primitív típusoknál &lt;strong&gt;lokális másolat&lt;/strong&gt; készül a változók értékeiről (az eredeti értékek nem mutálódnak).&lt;/p&gt;

&lt;p&gt;A JS-ben számos implicit (rejtett) típuskonverzió van. A változók típusa változhat a program futása során, amit az implicit típuskonverziók tesznek lehetővé:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var szam = 101, szoveg = &quot; kiskutya&quot;;
/* A + operátor az n számot sztringgé konvertálja
 * és összefűzi s-sel.
 */
var eredmeny = szam + szoveg;
console.log(eredmeny); //=&amp;gt; 101 kiskutya

/* A '-' operátor a sztringet számmá konvertálja/castolja
 * (ha tudja, különben undefined lesz) és kivonja belőle a 10-et.
 */
var x = &quot;62&quot; - 10; //=&amp;gt; 52

// De explicite mi is végezhetünk típuskonverziót.
var y = &quot;1500&quot;;
y = Number(y); // Számmá castoljuk a sztringet.
console.log(x + y); //=&amp;gt; 1552
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Amikor az egyenlőség és az egyenlőtlenség operátorokat használjuk, akkor életbevágóan fontos tisztában lenni az implicit típuskonverziókkal. Létezik az egyenlőség operátor (&lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt;) és a szigorú egyenlőség operátor (&lt;code class=&quot;highlighter-rouge&quot;&gt;===&lt;/code&gt;). Az utóbbi az azonosság szigorú definícióját használja és az alapján határozza meg a két operanduszának az azonosságát. A “sima” egyenlőség operátor (&lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt;) sokkal megengedőbb, hiszen engedélyezi a típuskonverziókat. A nemegyenlőség operátorból szintén kettő van: a “sima” (&lt;code class=&quot;highlighter-rouge&quot;&gt;!=&lt;/code&gt;) és szigorú (&lt;code class=&quot;highlighter-rouge&quot;&gt;!==&lt;/code&gt;) változat. Egy rövid kódrészleten bemutatva ez világosabb lesz:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;console.log(60 == &quot;60&quot;); //=&amp;gt; true, a &quot;60&quot;-ból szám lesz
console.log(60 === &quot;60&quot;); //=&amp;gt; false; szám és sztring különbözik
console.log(1 == true); //=&amp;gt; true
console.log(1 === true); //=&amp;gt; false; szám !== logikai érték
console.log(NaN == NaN); //=&amp;gt; false
console.log(NaN === NaN); //=&amp;gt; false

/* Ezzel a függvénnyel meghatározható, hogy NaN-e a vizsgált érték. */
console.log(isNaN(NaN)); //=&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A NaN érték (not-a-number) a “nem szám” jelölésére való. Akkor kapjuk értékül például, ha számot osztunk sztringgel: &lt;code class=&quot;highlighter-rouge&quot;&gt;10/&quot;a&quot;&lt;/code&gt;. Ez nyilvánvalóan értelmetlen eredményre vezet. A NaN semmilyen másik értékkel, de még önmagával sem azonos!&lt;/p&gt;

&lt;p&gt;A JS-ben az összes számot &lt;strong&gt;64-bites lebegőpontos formátum&lt;/strong&gt;ban reprezentálja az &lt;strong&gt;IEEE 754 szabvány&lt;/strong&gt; szerint. Ez azt jelenti, hogy maximum az olyan nagy számot képes eltárolni, mint a &lt;code class=&quot;highlighter-rouge&quot;&gt;±1.7976931348623157 x 10^308&lt;/code&gt;, és olyan kicsit, mint &lt;code class=&quot;highlighter-rouge&quot;&gt;5 x 10^-324&lt;/code&gt; (
&lt;strong&gt;alulcsordulás&lt;/strong&gt; történik amikor olyan kicsi a szám, hogy a számítógép nem tudja megkülönböztetni a 0-tól). A túlcsordulást szerinten nem kell magyaráznom.
A JavaScript számformátuma pontosan reprezentálja az egész számokat &lt;code class=&quot;highlighter-rouge&quot;&gt;-9007199254740992&lt;/code&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;-2^53&lt;/code&gt;) és &lt;code class=&quot;highlighter-rouge&quot;&gt;9007199254740992&lt;/code&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;2^53&lt;/code&gt;) között. Bizonyos operátorok viszont (mint például a tömbök indexelése vagy a bitenkénti műveletek) 32-bites egész számokkal működnek.&lt;/p&gt;

&lt;p&gt;A &lt;strong&gt;hexadecimális számok is támogatottak&lt;/strong&gt; az ECMAScript szabványban, viszont az oktális számok nem!&lt;/p&gt;

&lt;p&gt;Legyetek tisztában azzal is, hogy &lt;strong&gt;a lebegőpontos értékek bizonyos esetekben nem pontosak&lt;/strong&gt;, így ne lepődjetek meg, ha ezt tapasztaljátok:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;console.log(0.1 + 0.2); //=&amp;gt; 0.30000000000000004
console.log(0.1 + 0.2 == 0.3); //=&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;

&lt;p class=&quot;update&quot;&gt;Apró kiegészítés: két fontos dolgot kell itt pótolnom. Az egyik a változók elnevezési konvenciója. Ha a változó egyszerű szó, akkor nincs probléma, mivel minden betűjét kisbetűvel írjuk. Az összetett szavak esetén az első tagot mindig kisbetűvel írjuk, viszont az utána következő tagokat nagy kezdőbetűvel írjuk: &lt;code class=&quot;highlighter-rouge&quot;&gt;likeThis&lt;/code&gt;, illetve használhatunk egy alulvonást is a tagok elválasztására: &lt;code class=&quot;highlighter-rouge&quot;&gt;like_this&lt;/code&gt;. Ezt nem kötelező betartani, de erősen ajánlott. A másik dolog az úgynevezett &lt;strong&gt;“hamisértékek”&lt;/strong&gt; (falsy values) bevezetése a JS-ben. Ezek közé tartozik: a &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;, a &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, a &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, az &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;,  az &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;&quot;&lt;/code&gt; (üres sztring) és a &lt;code class=&quot;highlighter-rouge&quot;&gt;NaN&lt;/code&gt;. Ezek a kifejezésekben &lt;strong&gt;mindig hamisnak&lt;/strong&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;) &lt;strong&gt;értékelődnek ki&lt;/strong&gt; a szabvány szerint. (2017. augusztus 31.)&lt;/p&gt;

&lt;p&gt;Szerintem ennyi érdekesség elég.&lt;/p&gt;

&lt;p&gt;Egy részbe elég ennyi, majd a folytatom ezt az oktató sorozatot. A következő részekben ezekről tervezek írni:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;a függvényhatókör és blokkhatókör&lt;/li&gt;
  &lt;li&gt;a bezárás (closure)&lt;/li&gt;
  &lt;li&gt;a tömbök és a tömbszerű objektumok&lt;/li&gt;
  &lt;li&gt;hozzáférés az objektum tulajdonságaihoz&lt;/li&gt;
  &lt;li&gt;a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; érték&lt;/li&gt;
  &lt;li&gt;objektumok és függvények létrehozása&lt;/li&gt;
  &lt;li&gt;a prototípusos öröklés&lt;/li&gt;
  &lt;li&gt;a JSON (JavaScript Object Notation)&lt;/li&gt;
  &lt;li&gt;a RegExp objektumok&lt;/li&gt;
  &lt;li&gt;a funkcionális programozás (&lt;code class=&quot;highlighter-rouge&quot;&gt;map()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;reduce()&lt;/code&gt; és &lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;a “use strict” pragma&lt;/li&gt;
  &lt;li&gt;a globális objektum (Window)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ez a cikksorozat csak bevezető jellegű. Ez alapján elindulhattok a JavaScript mélyebb megismeréséhez vezető úton.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;erősen-ajánlott-irodalom&quot;&gt;Erősen ajánlott irodalom&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;David Flanagan (2011). &lt;a href=&quot;http://shop.oreilly.com/product/9780596805531.do&quot;&gt;JavaScript: The Definitive Guide. 6th Edition.&lt;/a&gt; O’Reilly, USA.&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 29 Aug 2017 19:49:00 +0200</pubDate>
        <link>http://localhost:4000//tudomany/2017/08/29/javascript_01.html</link>
        <guid isPermaLink="true">http://localhost:4000//tudomany/2017/08/29/javascript_01.html</guid>
      </item>
    
  </channel>
</rss>