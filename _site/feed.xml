<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gulácsi András</title>
    <description>Gulácsi András vagyok. Geoinformatikusként a legújabb web-alapú megoldásokat alkalmazom a földrajzi kutatásban, a földrajzi adatok feldolgozására és megjelenítésére a JavaScript nyelv erejével. Az alacsony színvonalú, elavult egyetemi tömegoktatás nem képes megfelelni
 a jelen kihívásainak és nem aknázza ki a legújabb IT-technológiákban rejlő nagy
 lehetőségeket. A tudásom 90%-át nem az egyetemen szereztem, programozni is magamtól
 tanultam meg. Az írásaimban és a készülő könyvemben az ideológiai alapú, utópisztikus
 gondolkodás ellen veszem fel a küzdelmet a tények, a tapasztalatok és a józan ész
 segítségével, hogy ne váljon a pusztító ideológiák martalékává a társadalom,
 szenvedést és nyomort hagyva maga után. A New Geographer – Új Geográfus blog
 egy újszerű szemléletben egyesíti a földrajzot az informatikával és a webfejlesztéssel.
</description>
    <link>http://localhost:4000</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>SAGA GIS és GDAL: Földrajzi adatfeldolgozás a parancssorban</title>
        <description>&lt;h2 id=&quot;1-bevezetés&quot;&gt;1. Bevezetés&lt;/h2&gt;

&lt;p&gt;A SAGA mozaikszó a System for Automated Geoscientific Analyses (Automatizált Földtudományi Elemző Rendszer) rövidítése.
A SAGA GIS egy C++-ban írt szabad forráskódú térinformatikai szoftver. A legújabb verzió az &lt;strong&gt;5.0&lt;/strong&gt;. Bővebb információért keressétek fel a program &lt;a href=&quot;http://www.saga-gis.org/en/index.html&quot;&gt;honlapját&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A &lt;strong&gt;SAGA GIS térinformatikai szoftver&lt;/strong&gt; kifejlesztésének elképzelése az 1990-es évek végén született meg a németországi Göttingeni Egyetem Természetföldrajzi Tanszékén. A kutatási projektek középpontjában a raszteres adatok, azon belül is kifejezetten a digitális domborzatmodellek, elemzése volt, amit többek közt a talajtulajdonságok, terep által irányított folyamatok, valamint éghajlati paraméterek modellezésére, előrejelzésére használtak. A SAGA GIS fejlesztése Jürgen Böhner és Olaf Conrad vezetésével történt és történik napjainkban is.&lt;/p&gt;

&lt;p&gt;A kereskedelmi szoftverek közül az ERDAS Imagine ingyenes alternatívája lehet a SAGA GIS.&lt;/p&gt;

&lt;p&gt;A &lt;a href=&quot;http://www.gdal.org/&quot;&gt;GDAL&lt;/a&gt; (Geospatial Data Abstraction Library) egy szabad forrású földrajzi adatfeldolgozó szoftverkönyvtár, ami számos vektoros és raszteres adatokat manipuláló modult tartalmaz, amelyek a paranccssorban vagy valamilyen héjalkalmazáson (&lt;a href=&quot;https://trac.osgeo.org/osgeo4w/&quot;&gt;OSGeo4W Shell&lt;/a&gt;) keresztül érhetők el. A gépemen lévő változat a &lt;a href=&quot;http://www.qgis.org/hu/site/&quot;&gt;Quantum GIS (QGIS)&lt;/a&gt; szabad forráskódú térinformatikai szoftver mellett települ fel (ugyanis a QGIS is használja a GDAL moduljait), és az &lt;strong&gt;OSGeo4W Shell&lt;/strong&gt; héjalkalmazáson keresztül futtatom. A &lt;strong&gt;GDAL verzióm: 1.11.2&lt;/strong&gt; (2015. február 10.). A QGIS 2.8.1-Wien változatot telepítettem fel. A legújabb kiadáshoz már biztosan egy újabb GDAL verzió jár. Ezzel nem teszteltem le a szkriptjeimet.&lt;/p&gt;

&lt;p&gt;A fenti verziókat használtam a parancssori szkriptek futtatására, tehát más verziókkal nem 100%, hogy tökéletesen működnek.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-adat-és-módszer&quot;&gt;2. Adat és módszer&lt;/h2&gt;

&lt;p&gt;Egy 15 éves 2000 és 2015 közötti műholdas adatsort használtam fel a parancssori földrajzi adatfeldolgozás demostrálására. A Terra műhold MODIS szenzorának &lt;a href=&quot;https://lpdaac.usgs.gov/dataset_discovery/modis/modis_products_table/mod13q1_v006&quot;&gt;250 méteres felbontású, 16 napos EVI és NDVI kompozitképeit&lt;/a&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;MOD13Q1: MODIS/Terra Vegetation Indices 16-Day L3 Global 250 m SIN Grid V005&lt;/code&gt;) elemeztem a Duna-Tisza-közi erdőterületekre, amelyek az Európai Uniós &lt;a href=&quot;https://www.eea.europa.eu/publications/COR0-landcover&quot;&gt;CORINE&lt;/a&gt; (Coordination of Information on the Environment) felszínborítási adatbázis segítségével lettek lehatárolva.
Az EU tagállamok nagyjából 6 évente felmérik a felszínborítás változásait különböző felszínborítási kategóriák szerint, 1:100 000-es méretarányban. A CLC_2000 (a 2000-05 közötti), a CLC_2006 (a 2006-11 közötti) és a CLC_2012 (2012-től kezdődő műholdképekre) adatok alapján határoltuk le az erdőket.&lt;/p&gt;

&lt;p&gt;Azokat a 250*250 méteres cellákat válogattuk le, aminek legalább 2/3 részét erdő borította. Külön vizsgáljuk a lomb-, a tűlevelű és az elegyes erdőket. A cél a vegetáció egészségi állapotának monitorozása a szárazodó Homokhátságon március vége és szeptember vége között. Az 1970-es évektől számítva a talajvízkút-hálózat mérései szerint átlagosan 3 méterrel süllyedt a régióban a talajvízszint (a magasabban fekvő térségekben ennél nagyobb csökkenés is megfigyelhető).&lt;/p&gt;

&lt;p&gt;A 16 napos kompozitképeket úgy kell érteni, hogy a 16 nap alatt készült összes felvételből raknak össze egy képet: a legjobb minőségű, azaz tiszta, felhőktől mentes értékeket használják fel minden egyes cellára (pixelre). A legnagyobb hátulütője az optikai (a látható és az infravörös tartományban mérő) szenzoroknak, hogy a felhőkön nem látnak át, szemben a lézeres vagy radaros mérésekkel szemben. A kompozit készítésével sokkal teljesebb adatokat kapunk, hiszen egy hosszabb időszakra nézve valószínűbb, hogy lesznek olyan felhőmentes képek, amelyek lefedik a földfelszín nagy részét, így használható információkat nyerhetünk.&lt;/p&gt;

&lt;p&gt;Mik azok a spektrális indexek?&lt;/p&gt;

&lt;p&gt;NDVI = (ρNIR − ρred) / (ρNIR + ρred)
NDWI = (ρNIR − ρSWIR) / (ρNIR + ρSWIR)	
ahol NDVI normalizált differenciált vegetációindex, NDWI normalizált differenciált vízindex, ami a növényzeti nedvességtartalmat fejezi ki, ρred a látható vörös sáv (620-670 nm), ρNIR a közeli infravörös sáv (841-876 nm), és ρSWIR az egyik középső infravörös sáv (2105-2155 nm).&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-feldolgozás-a-parancssorban&quot;&gt;3. Feldolgozás a parancssorban&lt;/h2&gt;

&lt;p&gt;A Windows parancssorban úgynevezett &lt;a href=&quot;https://hu.wikipedia.org/wiki/K%C3%B6tegelt_%C3%A1llom%C3%A1ny&quot;&gt;&lt;strong&gt;kötegelt állományokat&lt;/strong&gt;&lt;/a&gt; futtatok. Egyszerű és hatékony kis programokat lehet batch-ban írni. Az általában .cmd vagy .bat kiterjesztésű kötegelt állományokat (angolból átvett néven &lt;a href=&quot;https://hu.wikipedia.org/wiki/Batch_programoz%C3%A1s&quot;&gt;batch fájlokat&lt;/a&gt;) Windows, OS/2, és MS-DOS rendszerekben szokták használni. Formailag egy szövegfájlhoz hasonlítanak, tartalmuk pedig parancsok (DOS/Windows parancsok) egymásutánja. Futtatásuk a tartalom sorról sorra való olvasásával történik például a &lt;strong&gt;cmd.exe&lt;/strong&gt;-vel a Windows operációs rendszer alatt. A SAGA GIS parancssorban is futtatható, de célszerű kötegelt fájlkánt futtatni az utasítások sorozatát.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;31-saga-gis-saga_cmd&quot;&gt;3.1. SAGA GIS (saga_cmd)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-batch&quot;&gt;REM @ECHO OFF
ECHO
REM *****************************************************************
REM Create mean and median images and clip them with polygons
REM Author: András Gulácsi
REM E-mail: admin@newgeographer.com
REM Date: September 10th, 2017
REM SAGA GIS és GDAL: Földrajzi adatfeldolgozás a parancssorban
REM link
REM *****************************************************************
REM *************** PATHS ******************
REM Path to saga_cmd.exe
set PATH=%PATH%;g:\saga-5.0.0_x64\

REM Path to working dir
SET WORK=g:\modis\2005\EOV_2005\ndvi\
SET RESULT=g:\modis\TEMP
SET SHAPES=g:\modis\
SET POLYGON=00_l_250_66sz_poli.shp
SET POSTFIX=_00_l
REM ****************************************
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;saga_cmd io_gdal 0&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-batch&quot;&gt;FOR /F %%i IN ('dir /b %WORK%\*.tif') DO (

REM Tool: Import Raster

saga_cmd io_gdal 0 ^
-GRIDS=%WORK%\%%i.sgrd ^
-FILES=%WORK%\%%i ^
-TRANSFORM=0

)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/sagagis/excel.png&quot; class=&quot;large&quot; alt=&quot;Elérési utak, fájlnevek generálása az ÖSSZEFŰZ() függvény segítségével&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ha van egy bonyolult probléma és ha lehetséges, akkor mindig térj vissza egy olyan megoldáshoz, amit már ismersz!&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-batch&quot;&gt;REM Tool: Statistics for Grids

saga_cmd statistics_grid 4 ^
-GRIDS=%WORK%\NDVI2005081_eov_kiv.tif.sgrd;%WORK%\NDVI2005097_eov_kiv.tif.sgrd;%WORK%\NDVI2005113_eov_kiv.tif.sgrd;%WORK%\NDVI2005129_eov_kiv.tif.sgrd;%WORK%\NDVI2005145_eov_kiv.tif.sgrd;%WORK%\NDVI2005161_eov_kiv.tif.sgrd;%WORK%\NDVI2005177_eov_kiv.tif.sgrd;%WORK%\NDVI2005193_eov_kiv.tif.sgrd;%WORK%\NDVI2005209_eov_kiv.tif.sgrd;%WORK%\NDVI2005225_eov_kiv.tif.sgrd;%WORK%\NDVI2005241_eov_kiv.tif.sgrd;%WORK%\NDVI2005257_eov_kiv.tif.sgrd;%WORK%\NDVI2005273_eov_kiv.tif.sgrd ^
-MEAN=%RESULT%\atlag.sgrd ^
-PCTL=%RESULT%\median.sgrd ^
-PCTL_VAL=50
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-batch&quot;&gt;REM Tool: Clip Grid with Polygon

saga_cmd shapes_grid 7 ^
-INPUT=%RESULT%\atlag.sgrd ^
-OUTPUT=%RESULT%\atlag%POSTFIX%.sgrd ^
-POLYGONS=%SHAPES%\%POLYGON% ^
-EXTENT=0

saga_cmd shapes_grid 7 ^
-INPUT=%RESULT%\median.sgrd ^
-OUTPUT=%RESULT%\median%POSTFIX%.sgrd ^
-POLYGONS=%SHAPES%\%POLYGON% ^
-EXTENT=0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/sagagis/saga_results.png&quot; class=&quot;large&quot; alt=&quot;A mintaterületek sikeresen kivágva az átlagképből&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-batch&quot;&gt;REM Tool: Export GeoTIFF

saga_cmd io_gdal 2 ^
-GRIDS=%RESULT%\atlag%POSTFIX%.sgrd ^
-FILE=%RESULT%\atlag%POSTFIX%.tif

saga_cmd io_gdal 2 ^
-GRIDS=%RESULT%\median%POSTFIX%.sgrd ^
-FILE=%RESULT%\median%POSTFIX%.tif


PAUSE
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;32-virtuális-raszter-készítése-gdal-ban&quot;&gt;3.2. Virtuális raszter készítése GDAL-ban&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/sagagis/shell.png&quot; class=&quot;image3&quot; alt=&quot;Az OSGeo4W Shell felülete: a gdalbuildvrt használati útmutatója kiíratva&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;összefoglalás&quot;&gt;Összefoglalás&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 11 Sep 2017 02:22:05 +0200</pubDate>
        <link>http://localhost:4000//tudomany/2017/09/11/parancssor_a_geoinformatikaban.html</link>
        <guid isPermaLink="true">http://localhost:4000//tudomany/2017/09/11/parancssor_a_geoinformatikaban.html</guid>
      </item>
    
      <item>
        <title>Rövid elméleti bevezető a JavaScript nyelvbe, 2. rész.</title>
        <description>&lt;p&gt;Az &lt;a href=&quot;http://www.newgeographer.com/tudomany/2017/08/29/javascript_01.html&quot;&gt;előző részben&lt;/a&gt; az objektum-orientált paradigmáról írtam, valamint a JavaScript bemutatásába kezdtem bele. Az alábbi dolgokra tértem ki: a JavaScript interpretáló nyelv, vagyis a fordítás futási időben történik; az ECMAScript szabványok; gyengén típusos nyelv; két adattípus létezik: a primitív (változók) és a referencia (objektumok); a primitív típusok nem, míg a referencia típusok mutálódnak; az automatikus szemétgyűjtés miatt nem kell foglalkoznunk a dinamikus tárhelyek felszabadításával (nincsen destruktor), továbbá nincsenek mutatók, amiken keresztül hozzáférhetnénk a memóriacímekhez; egy tömb példáján keresztük rávilágítottam a sekély és a mély másolás különbségére; az implicit típuskonverziókra és a szigorú azonosság, illetve szigorú nemegyenlőség operátorokra is kitértem; leírtam, hogy a JS Unicode karakterkészletet használ, illetve a számokat 64 bites lebegőpontos formátumban tárolja el. Kitértem a hamisértékekre is.&lt;/p&gt;

&lt;p&gt;És most jön a folytatás, az alábbi részekkel, ebben a sorrendben:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;A &lt;strong&gt;függvény- és a blokkhatókör&lt;/strong&gt; közötti különbség, &lt;strong&gt;felemelés&lt;/strong&gt; (hoisting),&lt;/li&gt;
  &lt;li&gt;A globális objektum (&lt;code class=&quot;highlighter-rouge&quot;&gt;Window&lt;/code&gt;),&lt;/li&gt;
  &lt;li&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;use strict&quot;&lt;/code&gt; pragma,&lt;/li&gt;
  &lt;li&gt;Objektumok és függvények, illetve objektum literál és függvény szintaxis,&lt;/li&gt;
  &lt;li&gt;Tömbök és tömbszerű objektumok,&lt;/li&gt;
  &lt;li&gt;Hozzáférés az objektumok tulajdonságaihoz.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;a-függvényhatókör-és-a-felemelés-hoisting&quot;&gt;A függvényhatókör és a felemelés (hoisting)&lt;/h2&gt;

&lt;p&gt;Mi a függvényhatókör? Ezt néhány példával lehet a legegyszerűbben elmagyarázni. A blokkhatókört már megszokhattuk más nyelvekben, így például a C-ben, ezért furcsának tűnhet elsőre, amit bemutatok.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function foo () {
    console.log(&quot;i = &quot; + i); //=&amp;gt; i = undefined
    for (var i = 0; i &amp;lt; 10; i++) {
        /* üres ciklus */;
    }
    console.log(&quot;i = &quot; + i); //=&amp;gt; i = 10
}
foo();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; ciklus előtt és után is hozzáférhető az &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; változó. Ha blokk hatókör lenne érvényben, akkor az &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; kizárólag a for ciklus &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;/code&gt; blokkján belül lenne hozzáférhető, de ez a függvény hatókörnél nincsen így, ugyanis ebben az esetben a blokkon kívül is hozzáférhető &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;, az éppen aktuális függvényen belül.&lt;/p&gt;

&lt;p&gt;Mint említettem, a &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; ciklus előtt hozzáférhető az &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;, viszont az értéke &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt; lesz, mivel az értékadás csak  később, a &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; ciklusba ágyazottan történik (alapértelmezetten minden deklarált változó értéke &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;). &lt;strong&gt;Egy függvényen belül deklarált változó hatóköre kiterjed az egész függvényre&lt;/strong&gt; és a &lt;strong&gt;változók felemelése&lt;/strong&gt; (hoisting) történik a függvény első sorába. Az &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; változó felemelődik. Az előző kódrészlet egyenértékű ezzel:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function foo () {
    var i; // Felemelődés az első sorba.
    console.log(&quot;i = &quot; + i); //=&amp;gt; i = undefined
    for (i = 0; i &amp;lt; 10; i++) {
        /* üres ciklus */;
    }
    console.log(&quot;i = &quot; + i); //=&amp;gt; i = 10
}
foo();
console.log(&quot;i = &quot; + i); // Referenciahiba lesz.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Természetesen függvényen kívül nem elérhető az &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;. A kód utolsó sora referenciahibát fog dobni (&lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; nincs definiálva).&lt;/p&gt;

&lt;p&gt;A változó hatókör a kód azon régiója, amiben definiáltuk a változót. A globális változók globális hatókörrel rendelkeznek, tehát a forráskódban mindenhol definiálva vannak (hozzáférhetők). Ezzel szemben a függvényen belül deklarált változók lokálisak, és csak az adott függvényen (függvényhatókörön) belül hozzáférhetők. Kívülről nem.&lt;/p&gt;

&lt;p&gt;Ha ugyanolyan nevű lokális változót deklarálunk a függvényen belül, akkor az elrejti a globális változót, így a két &lt;code class=&quot;highlighter-rouge&quot;&gt;scope&lt;/code&gt; változó nem ugyanaz a változó:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var scope = &quot;globális&quot;;
function checkScope() {
    var scope = &quot;lokális&quot;;
    return scope;
}
checkScope(); //=&amp;gt; lokális
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;De mi történik ebben az esetben?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var scope = &quot;globális&quot;;
function checkScope() {
    scope = &quot;lokális&quot;;
    return scope;
}
checkScope(); //=&amp;gt; lokális
console.log(scope); //=&amp;gt; lokális
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A függvényen belül lehagytam a &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;-t, ezért az a &lt;code class=&quot;highlighter-rouge&quot;&gt;scope&lt;/code&gt; a globális változó, aminek az értékét sikeresen felülírtuk &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;lokális&quot;&lt;/code&gt;-ra.&lt;/p&gt;

&lt;p&gt;A lokális változókat tekinthetjük egy objektum tulajdonságainak. Minden kódrészlethez kapcsolódik egy &lt;strong&gt;hatókör-láncolat&lt;/strong&gt; (scope chain), ami objektumok egy listája, ami a hatókörökhöz tartozó változókat definiálja. Például amikor a JS egy &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; változó értékét keresi, akkor a hatókörlánc első objektumában keresi először. Ha ennek van &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; tulajdonsága, akkor azt használja. Ha nem található ilyen nevű változó, akkor a következő objektumban keresi, és így tovább, míg végül eljutunk a globális objektumig. Ha ott sem találja &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;-et, akkor referenciahiba lép fel (&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; nem található). Az előbbi példában a függvényen belül a &lt;code class=&quot;highlighter-rouge&quot;&gt;scope&lt;/code&gt; változó értékét módosítottuk. No de melyik &lt;code class=&quot;highlighter-rouge&quot;&gt;scope&lt;/code&gt; változót? A &lt;code class=&quot;highlighter-rouge&quot;&gt;checkScope()&lt;/code&gt; függvényen belül nincsen &lt;code class=&quot;highlighter-rouge&quot;&gt;scope&lt;/code&gt; változó deklarálva (nem használtuk a &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;-t). Ilyenkor a JS értelmező a következő, fölötte levő szinten keresi a &lt;code class=&quot;highlighter-rouge&quot;&gt;scope&lt;/code&gt;-ot. Ez a globális objektum, és itt megtalálja a globális &lt;code class=&quot;highlighter-rouge&quot;&gt;scope&lt;/code&gt; változót.&lt;/p&gt;

&lt;p&gt;A hatókörlánc a JS legfelső szintjén (az a kódrész, ami a függvénydefiníciókon kívül van) egyetlen objektumból áll: ez a globális objektum.&lt;/p&gt;

&lt;p&gt;Természetesen az &lt;strong&gt;ES6&lt;/strong&gt;-tól kezdődően a függvényhatókörű &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; helyett használhatjuk a blokkhatókörű &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;-et, így a függvényhatókörnél jelentkező szoktalan jelenségek nem lépnek fel. Szintén bevezetésre került a &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;, ami egy konstans, azaz állandó érték jelölésére szolgál. Egy konstansnak kötelező értéket adni annak deklarációjakor. Ezután az értéke semmilyen módon nem lesz megváltoztatható.&lt;/p&gt;

&lt;p&gt;Az előző részben említettem, hogy a webböngészők még nem implementálták az új nyelvi elemek  egy jó részét, tehát kliens oldali kódban nem biztos, hogy működni fognak. Szerver oldalon (pl. Node.js) már támogatottak, ott nyugodtan használd azokat, beleértve az egyszerűsített függvényszintaxist a callback függvényeknél! Az aszinkron függvényhívásról máskor írok.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;a-globális-objektum-window&quot;&gt;A globális objektum (Window)&lt;/h2&gt;

&lt;p&gt;Említettem többször is a &lt;strong&gt;globális objektum&lt;/strong&gt;ot. Ez egy szokványos JavaScript objektum, ami  rendkívül fontos szerepet játszik. &lt;strong&gt;A globális objektum tulajdonságai globálisan definiáltak&lt;/strong&gt;, vagyis hozzáférhetők a programunk számára:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;olyan globális tulajdonságok, mint például az &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;, az &lt;code class=&quot;highlighter-rouge&quot;&gt;Infinity&lt;/code&gt; és a &lt;code class=&quot;highlighter-rouge&quot;&gt;NaN&lt;/code&gt;,&lt;/li&gt;
  &lt;li&gt;olyan globális függvények mint az &lt;code class=&quot;highlighter-rouge&quot;&gt;isNaN()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;parseInt()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;eval()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;setTimeout()&lt;/code&gt; stb.,&lt;/li&gt;
  &lt;li&gt;konstruktor függvények: &lt;code class=&quot;highlighter-rouge&quot;&gt;Date()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;RegExp()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;String()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Object()&lt;/code&gt; és &lt;code class=&quot;highlighter-rouge&quot;&gt;Array()&lt;/code&gt;,&lt;/li&gt;
  &lt;li&gt;olyan globális objektumok, mint a &lt;code class=&quot;highlighter-rouge&quot;&gt;Math&lt;/code&gt; és a &lt;code class=&quot;highlighter-rouge&quot;&gt;JSON&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A kliens oldali JavaScript-ben a &lt;code class=&quot;highlighter-rouge&quot;&gt;Window&lt;/code&gt; objektum a böngészőablakban található összes JS kódunk globális objektumaként funkcionál. Például a &lt;code class=&quot;highlighter-rouge&quot;&gt;console&lt;/code&gt; objektum a megnyitott böngészőablakunk konzolja. Ennek a &lt;code class=&quot;highlighter-rouge&quot;&gt;log()&lt;/code&gt; metódusát szoktuk meghívni, ha a konzolra akarunk írni. A &lt;code class=&quot;highlighter-rouge&quot;&gt;console&lt;/code&gt; objektum is része a globális objektumnak. Így tudjuk lekérdezni a &lt;code class=&quot;highlighter-rouge&quot;&gt;Window&lt;/code&gt; objektum összes tulajdonságát:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* A window a Window objektum önmagát meghivatkozó tulajdonsága.
 * Ezen a referencián keresztül férünk hozzá a globális objektumhoz.
 */
for (var prop in window) {
    console.log(prop);
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;a-szigorú-mód-strict-mode-és-a-js-korlátozása&quot;&gt;A szigorú mód (“strict mode”) és a JS korlátozása&lt;/h2&gt;

&lt;p&gt;A JS-ben egyaránt vannak &lt;strong&gt;jó és rossz részek&lt;/strong&gt;. &lt;strong&gt;Douglas Crockford&lt;/strong&gt; (neves JS guru) szerint korlátozni kell a JS programozási nyelvet, és &lt;strong&gt;kizárólag csak a jó részeket&lt;/strong&gt; használni belőle. Ezzel jobb programokat írunk és jobb programozóvá is válunk. Crockford jóvoltából rendelkezésünkre áll a &lt;a href=&quot;http://www.jslint.com/&quot;&gt;JSLint&lt;/a&gt; kódellenőrző, ami megvizsgálja, hogy a programunk megfelel-e a szigorúbb követelményeknek (beleértve a szintaktikai megfontolásokat - magyarul hogyan nézzen ki a kód), és csak a jó részeket alkalmazza. Az ajánlott irodalomban feltüntettem Crockford könyvét. Akit bővebben érdekel, utánanézhet.&lt;/p&gt;

&lt;p&gt;Az egész korlátozás egyrészt a kód jobb értelmezhetőségét, másrészt pedig a biztonság növelését szolgálja. A kliens oldali JS sebezhető a támadásokkal szemben a hekkerek részéről, így célszerű olyan kódot írni, ami biztonságosabb. Például nem használ &lt;code class=&quot;highlighter-rouge&quot;&gt;eval&lt;/code&gt;-t ellenőrzés nélkül. Az &lt;code class=&quot;highlighter-rouge&quot;&gt;eval&lt;/code&gt; a JavaScript fordítót hívja meg egy sztringre, ami JavaSript kódot tartalmaz, amit végrehajt. Az &lt;code class=&quot;highlighter-rouge&quot;&gt;eval&lt;/code&gt; használatát lehetőség szerint kerüld el! Egyébként nagyon ritkán van szükség rá.&lt;/p&gt;

&lt;p&gt;Az alábbi kódrészlet állandóan egy felugró ablakot hoz létre egy végtelen ciklus segítségével:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Idegesítő kód.
var text = &quot;for (;;) alert(\&quot;Muhaha!!\&quot;);&quot;;
/* Nem vizsgálok rá a sztring tartalmára
 * és úgy hívom meg rá az eval-t. */
eval(text);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ha nem ismerjük a sztring tartalmát, akkor előfordulhatnak benne kártékony, vagy legalábbis kellemetlen kódrészletek. A fenti példát módosítva elkerülhetjük, hogy a kód lefusson:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var text = &quot;for(;;) alert(\&quot;Muhaha!!\&quot;);&quot;;

var pattern = /for/; // egy RegExp objektum.
// Most rávizsgálok a sztring tartalmára
var result = text.match(pattern);
if (result !== null) {
    throw &quot;A for ciklusok nem engedélyezettek!&quot;;
} else {
    eval(text);
} // Mi történik?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Egy &lt;code class=&quot;highlighter-rouge&quot;&gt;RegExp&lt;/code&gt; objektum (a következő részben bővebben) segítségével megkeresem a szövegben található &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; kulcsszót. A &lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt; jelek közötti kifejezést, vagyis a &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;for&quot;&lt;/code&gt;-t keressük a &lt;code class=&quot;highlighter-rouge&quot;&gt;RegExp&lt;/code&gt; objektum &lt;code class=&quot;highlighter-rouge&quot;&gt;match()&lt;/code&gt; metódusának segítségével. Ha nem talál a sztringünkben ilyet, akkor &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;-t ad vissza. Hibát dobok, ha találtam &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; ciklust, ami leállítja a kód futását. A hibakezelés a következő részben lesz kifejtve.&lt;/p&gt;

&lt;p&gt;Az ECMAScript5 szabványban bevezették a &lt;strong&gt;szigorú módot&lt;/strong&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;strict mode&quot;&lt;/code&gt;), ami bizonyos korlátozásokat vezetett be a biztonság növelésre. Több hibaellenőrzés is van benne (több hibát is jelez a fordító, ami leállítja a kód futását). Nagyon erősen ajánlott a használata, mivel rengeteg sérülékenység van a JS-ben, amit a hekkerek kihasználhatnak. Nem tekinthető jó kódnak, ami nem alkalmazza ezt a fontos korlátozást. Bővebb tájékoztatást a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;Mozilla honlapján&lt;/a&gt; találtok. A GEE kódszerkesztőjében is &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;strict mode&quot;&lt;/code&gt; van érvényben. Használata egyszerű, az utasítások elé kell beilleszteni:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&quot;use strict&quot;;
var v = &quot;Szigorú módban vagyok!&quot;;

// Referenciahibát dob a fordító:
x = &quot;A globális objektumnak nem adhatunk tulajdonságot&quot;;

// Függvényeknél:
var f = function (a) {
    &quot;use strict&quot;;
    /* utasítások */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;objektumok-és-függvények-létrehozása&quot;&gt;Objektumok és függvények létrehozása&lt;/h2&gt;

&lt;p&gt;Az egyik módja a függvények létrehozásának, ha egy &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; változóba tároljuk el a függvényt. Az objetum literál létrehozása &lt;code class=&quot;highlighter-rouge&quot;&gt;var o = { x: 0 };&lt;/code&gt; szintaxissal történik. Mivel ezek utasítások és nem kifejezések szükség van az utasítást záró &lt;code class=&quot;highlighter-rouge&quot;&gt;;&lt;/code&gt;-ra.&lt;/p&gt;

&lt;figcaption class=&quot;code-caption&quot;&gt;
Az 1. JavaScript példa: Objektum literál, tulajdonságok és metódusok.
&lt;/figcaption&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var square = function (x) {
    return x * x;
};
console.log(&quot;A megadott szám négyzete: &quot; + square(200));

var point = {
  x: 0,
  y: 0,
  print_1: function () {
     console.log(&quot;x: &quot; + point.x + &quot;, y: &quot; + point.y);
  } 
};
point.print_2 = function () {
  console.log(&quot;x: &quot; + point.x + &quot;, y: &quot; + point.y);
};
point.x = 5, point.y = 15;
point.print_1(); //=&amp;gt; x: 5, y: 15
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A függvény szintaxissal felírt függvények kifejezések, tehát nem kell ; utánuk. A példában szereplő &lt;code class=&quot;highlighter-rouge&quot;&gt;Point()&lt;/code&gt; függvény egy pont „osztály” konstruktora. A konstruktor egy olyan függvény, amit objektumok létrehozására, illetve azok tulajdonságainak inicializálására használunk. A prototípusos öröklést a következő részre tartogtatom. Az osztályt azért tettem idezőjelbe, mert mint már említettem, nincsenek igazi osztályok (&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;) a JS-ben.&lt;/p&gt;

&lt;figcaption class=&quot;code-caption&quot;&gt;A 2. JavaScript példa: Függvény szintaxis, konstruktor és osztály.&lt;/figcaption&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function square (x) {
    return x * x;
}
console.log(&quot;A megadott szám négyzete: &quot; + square(200));

/* Ez egy pont osztály konstruktora. */
function Point(x, y) {
    this.x = x || 0;
    this.y = x || 0;

    this.print = function () {
        console.log(&quot;x: &quot; + this.x + &quot;, y: &quot; + this.y);
    };
}
/* Az osztály példányosítása: egy változóban
 * eltároljuk az objektumot.
 */
var object = new Point(10, 20);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;this.x = x || 0;&lt;/code&gt; utasításban a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; az éppen aktuális objektumpéldányra mutat (egy referencia), amin keresztül hozzáférünk az éppen aktuális objektum tulajdonságaihoz. A konstruktor önmagában nem hoz létre egy új objektumot, hanem azt nekünk kell megtennünk a new kulcsszó használatával, például: &lt;code class=&quot;highlighter-rouge&quot;&gt;var object = new Point(10, 20);&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Ha nem adunk át egyetlen argumentumot sem a konstruktornak, akkor &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; lesz az &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; és &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; tulajdonság értéke. Miért? A logikai VAGY operátor (&lt;code class=&quot;highlighter-rouge&quot;&gt;||&lt;/code&gt;) abban az esetben, &lt;strong&gt;ha mindkét részkifejezése hamis, akkor a jobb oldali operandusz értékét adja vissza&lt;/strong&gt;, vagyis a nullát.&lt;/p&gt;

&lt;p&gt;A logikai operátorok (ÉS, VAGY) &lt;strong&gt;rövidzár kiértékelést&lt;/strong&gt; alkalmaznak. ÉS kapcsolat esetén (&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&amp;amp;&lt;/code&gt; operátor) akkor igaz az összetett kifejezés, ha mindegyik feltétel igaz (ha már a bal oldali részkifejezés hamis, akkor az egész kifejezés hamis - fölösleges megvizsgálni a jobb oldali részkifejezést). VAGY kapcsolat esetén legalább az egyik feltételnek igaznak kell lennie, hogy az egész kifejezés igaz legyen. A &lt;code class=&quot;highlighter-rouge&quot;&gt;x || 0;&lt;/code&gt; kifejezésben, ha igaz értéket adunk meg az x helyére, akkor a &lt;code class=&quot;highlighter-rouge&quot;&gt;||&lt;/code&gt; operátor már nem vizsgál rá a második kifejezésre, hanem visszadja az első kifejezés értékét. További információ a logikai operátorokról &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators&quot;&gt;itt található&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Felhívom itt a figyelmet arra, hogy vannak az úgynevezett &lt;strong&gt;„hamisértékek”&lt;/strong&gt; (falsy values), amelyek mindig &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;-nak értékelődnek ki, ezek: &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;&quot;&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;NaN&lt;/code&gt;! Ha ezek bármelyikét is megadnánk az &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; argumentum helyére, akkor is megfelelően működik ez a roppant hasznos technika.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Alapértelmezett függvényargumentumokat&lt;/strong&gt; az ES5-ben még nem implementálták (viszont egyes böngészők már támogathatják), de a fenti technikával megoldható. Az ES6 szintaxis így néz ki:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function Point(x = 0, y = 0) {
    this.x = x;
    this.y = y;
}
var p = new Point(45);
console.log(p); // Mit fog kiírni?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A Mozilla Firefox és a Google Chrome esetén működik. A többi böngészőnél nem néztem.&lt;/p&gt;

&lt;p&gt;Egy &lt;strong&gt;nagyon fontos különbség van&lt;/strong&gt; az objektum literál (illetve változó) szintaxis és a függvény/konstruktor szintaxis között. Ha objektum literál segítségével hozunk létre egy objektumot, akkor az a deklarációkor létrejön. A deklaráció előtt nem használható (ugyanúgy, mint egy egyszerű változó esetén). A konstruktor esetén viszon egy függvényt hozunk létre, amit ha meghívunk, létrehozzuk az objektum egy példányát (tetszőleges számú példányt hozhatunk létre). A függvény definíció előtt is létrehozhatunk objektum példányokat. A példa talán érthetőbb lesz:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Példányosítás a konstruktor definíciója előtt.
var x = new Point(233,455);
x.print();
function Point(x, y) {
    this.x = x || 0;
    this.y = x || 0;
    this.print = function () {
        console.log(&quot;x: &quot; + this.x + &quot;, y: &quot; + this.y);
    };
}

// Objektum literál esetén nem működik.
/* Típushibát dob, hiszen még a point objektum nem létezik,
 * a következő sorban hozzuk létre! */
point.print();
var point = {
  x: 0,
  y: 0,
  print: function () {
     console.log(&quot;x: &quot; + point.x + &quot;, y: &quot; + point.y);
  } 
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;tömbök-tömbszerű-objektumok-és-hozzáférés-az-objektumok-tulajdonságaihoz&quot;&gt;Tömbök, tömbszerű objektumok és hozzáférés az objektumok tulajdonságaihoz&lt;/h2&gt;

&lt;p&gt;A tömbök is objektumok. Az objektumok tulajdonságokból épülnek fel, amelyek lehetnek változók, tömbök, tömbszerű objektumok, objektumok és függvények. Értsétek ezt úgy, hogy tetszőlegesen egymásba ágyazhatók. &lt;strong&gt;A tulajdonságok azonosító-érték párok.&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;x: 6&lt;/code&gt; esetén az &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; azonosító a &lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt;-os értéket jelöli, amit valamelyik memóriacímen tároljuk. Emlékezzünk vissza, hogy az objektumok mind referenciák, amelyek a dinamikus memóriában lefoglalt tárhelyre hivatkoznak, ahol megtalálhatók az objektum tulajdonságai. Az objektumok tulajdonságaihoz a &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt; &lt;strong&gt;pont operátor&lt;/strong&gt; segítségével férhetünk hozzá (is), míg a tömbök esetén a &lt;code class=&quot;highlighter-rouge&quot;&gt;[0]&lt;/code&gt; &lt;strong&gt;tömbelem-hivatkozás&lt;/strong&gt; segítségével. A függvények esetén az érték maga a függvény teste, az azonosító pedig a függvény neve.&lt;/p&gt;

&lt;figcaption class=&quot;code-caption&quot;&gt;A 3. JavaScript példa: Tömbök, tömbszerű objektumok és az objektum tulajdonságok elérése.&lt;/figcaption&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// A tömbök.
var ures_tomb = [];
var tomb = [1, 2, 3, 4, 5];
console.log(tomb[0]);

/* Elemek hozzáadása a tömb végére. */
tomb.push(-200, 1552, 9999);
/* Az utolsó elem törlése. */
tomb.pop();
/* A tömb elemeinek kiíratása. */
for (var i = 0; i &amp;lt; tomb.length; i++) {
    console.log(&quot;A tömb &quot; + (i+1) + &quot;. eleme: &quot; + tomb[i]);
}
/* Ezzel a 4. index utáni elemeket törlöm. */
tomb.length = 4;

var array = [
    { x: 0 },
    &quot;kizomba&quot;,
    26,
    true,
    function(nev) { console.log(&quot;Helló, &quot; + nev + &quot;!&quot;); }
];
// Utolsó elem.
array[array.length-1];
// Hívjuk is meg a függvényt!
array[array.length-1](&quot;Jancsi&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A tömbök tulajdonságait a tömb &lt;strong&gt;elemeinek&lt;/strong&gt; hívjuk, amelyek azonosítója szám. Ezt a számot &lt;strong&gt;indexnek&lt;/strong&gt; nevezzük. &lt;strong&gt;A többi objektumnál a tulajdonságok azononosítói&lt;/strong&gt; nem számok, hanem &lt;strong&gt;sztringek&lt;/strong&gt;. A tömböknek van egy hossz / length tulajdonságuk, ami az éppen aktuális tömbelemek számát, a &lt;strong&gt;tömb méretét&lt;/strong&gt; tartalmazza. A fenti &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; ciklus helyett használhatunk &lt;strong&gt;for-in ciklust&lt;/strong&gt; is, ami egy változón keresztül iteráltatja egy objektum tulajdonságait:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* Ugyanaz, mint az előző, csak for-in ciklussal. */
var temp;
for (var p in tomb) {
  /* Számmá kellett konvertálni. */
  temp = Number(p)+1;
  console.log(&quot;A tömb &quot; + temp + &quot;. eleme: &quot; + tomb[p]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Tömbszerű objektumokat&lt;/strong&gt; is létrehozhatunk (ilyen az &lt;code class=&quot;highlighter-rouge&quot;&gt;arguments&lt;/code&gt; tulajdonság, ami egy tömbszerű objektum, de erről majd később), ha azonosítónak számot adunk meg, valamint szükség van az elemek számának eltárolására egy változóba (&lt;code class=&quot;highlighter-rouge&quot;&gt;length&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* Tömbszerű objektumok. */
/* Üres objektum. */
var a = {};
var i = 0;
while (i &amp;lt; 10) {
  a[i] = i * i;
  i++;
}
/* A tömböknek van hossz tulajdonsága. Itt is létrehozzuk. */
a.length = i;

var osszeg = 0;
for (var j = 0; j &amp;lt; a.length; j++) {
  osszeg += a[j];
}
console.log(osszeg);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Az előbbiekből következik, hogy az objektum tulajdonságok elérése kétféleképpen történhet: az &lt;code class=&quot;highlighter-rouge&quot;&gt;objektum.tulajdonsag&lt;/code&gt; és az &lt;code class=&quot;highlighter-rouge&quot;&gt;objektum[&quot;tulajdonsag&quot;]&lt;/code&gt; szintaxissal. A tömbök esetén csak a &lt;code class=&quot;highlighter-rouge&quot;&gt;[]&lt;/code&gt; zárójelek segítségével.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/* A két példával ezelőtti &quot;a&quot;
 * tömbszerű objektum szerepel itt.
 * A`for in` ciklus a length tulajdonságot is kiírja a konzolra! */
for (var prop in a) {
    console.log(prop + &quot; = &quot; + a[prop]);
}
// Hozzáférés az objektumok tulajdonságaihoz.
var o = {};
o.x = 10, o.y = 25;
o.print = function () {
    console.log(&quot;x: &quot; + o.x + &quot;, y: &quot; + o.y);
};
console.log(o[&quot;x&quot;]);
console.log(o.y);
// A print metódus meghívása.
o[&quot;print&quot;]();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A következő rész tartalma:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Mi a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;, honnan származik?&lt;/li&gt;
  &lt;li&gt;Aszinkron programozás, bezárás (closure) és a privát hozzáférés&lt;/li&gt;
  &lt;li&gt;Egymásba ágyazott függvények&lt;/li&gt;
  &lt;li&gt;Kivételkezelés (exeption handling)&lt;/li&gt;
  &lt;li&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;RegExp&lt;/code&gt; objektumok&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ajánlott-irodalom&quot;&gt;Ajánlott irodalom&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Douglas Crockford (2008). &lt;a href=&quot;https://www.amazon.com/exec/obidos/ASIN/0596517742/wrrrldwideweb&quot;&gt;JavaScript: The Good Parts. 1th Edition.&lt;/a&gt; O’Reilly, USA.&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 03 Sep 2017 01:11:00 +0200</pubDate>
        <link>http://localhost:4000//tudomany/2017/09/03/javascript_02.html</link>
        <guid isPermaLink="true">http://localhost:4000//tudomany/2017/09/03/javascript_02.html</guid>
      </item>
    
      <item>
        <title>Rövid elméleti bevezető a JavaScript nyelvbe</title>
        <description>&lt;p&gt;A Google Earth Engine (GEE) felhő alapú platform általános bemutatása után (&lt;a href=&quot;http://www.newgeographer.com/tudomany/2017/08/07/google_earth_engine_01.html&quot;&gt;itt elérhető az 1. rész&lt;/a&gt;), ebben a részben egy rövid betekintést nyújtok az objektum-orientált programozásba és felhívom a figyelmet a JavaScript nyelv fontos jellemzőire, hogy hatékonyan ki tudjátok aknázni a GEE-ben rejlő lehetőségeket akár több száz GB-nyi adat gyors feldolgozására, minimális erőfeszítéssel.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Előzetes programozói tapasztalat erősen javallott&lt;/strong&gt;, különben nem sokat értetek meg az egészből. Teljesen mindegy, hogy milyen nyelvet ismersz. A programozói gondolkodás az, ami valóban számít. Az alapelvek, a vezérlési szerkezetek, az algoritmusok stb. mind ugyanazok, csak a szintaxis és a szabvány más.
Én a C nyelven keresztül tanultam meg a programozást, majd utána ismerkedtem meg a C++-szal és az objektum-orientált paradigmával. És csak ezt követően jött a &lt;a href=&quot;https://www.javascript.com/&quot;&gt;JavaScript&lt;/a&gt; (JS).&lt;/p&gt;

&lt;p&gt;A bejegyzésemben megadott kódrészleteket pedig próbáljátok ki! 
Használhatjátok valamelyik böngésző konzolját (Google Chrome esetén: &lt;code class=&quot;highlighter-rouge&quot;&gt;F12&lt;/code&gt;, Firefox esetén &lt;code class=&quot;highlighter-rouge&quot;&gt;CTRL+SHIFT+i&lt;/code&gt;) vagy a GEE kódszerkesztőjét (ebben “strict mode”-ban használhatjátok a JS-t)!&lt;/p&gt;

&lt;p&gt;A programrészleteket egyben letölthetitek &lt;a href=&quot;https://github.com/SalsaBoy990/EarthEngine/blob/master/tutorial2.js&quot;&gt;innen&lt;/a&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;bevezetés-az-objektum-orientált-programozásba&quot;&gt;Bevezetés az objektum-orientált programozásba&lt;/h2&gt;

&lt;p&gt;Ez bevezető csak egy nagyon kurta betekintést nyújt az objektum orientált szemléletbe.&lt;/p&gt;

&lt;p&gt;A programozás célja mindig egy összetett probléma megoldása a számítógép számítási kapacitásának a lehető leghatékonyabb kihasználásával. A programozás során ezt &lt;strong&gt;az összetett problémát fel kell bontanunk kisebb részproblémákra/részlépésekre&lt;/strong&gt; (például az adatok bekérése, a bemenet ellenőrzése, különböző műveletek, amelyeket az adatokon végzünk, adatok mentése stb.), amelyek megoldására külön függvényeket írunk. Ezáltal átláthatóvá válik számunkra a program működése.&lt;/p&gt;

&lt;p&gt;A “hagyományos” nyelvekben (mint például a C-ben) megtanultuk, hogy &lt;strong&gt;a változókat és a függvényeket külön kezeljük&lt;/strong&gt;, valamint a függvényeket a változók argumentumként való átadásával hívjuk meg. (Az argumentum az az érték, amit bemenő paraméterként megadunk egy függvénynek.). Lehet érték szerint, mutató szerint és referencia szerint paramétert átadni. A JavaScript-ben &lt;strong&gt;kizárólag érték szerinti paraméterátadás&lt;/strong&gt; létezik (az objektum referenciák is érték szerint adódnak át)!&lt;/p&gt;

&lt;p&gt;Az objektum orientált nyelveknek három alapelve van:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;egységbezárás&lt;/strong&gt; / enkapszuláció (encapsulation)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;öröklés&lt;/strong&gt; (inheritance)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;többalakúság&lt;/strong&gt; / polimorfizmus (polymorphism)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A klasszikus öröklés (és a polimorfizmus) JavaScript-ben is imitálható, de valójában kizárólag csak &lt;strong&gt;prototípusos öröklés&lt;/strong&gt; létezik a JS-ben. Öröklés helyett &lt;strong&gt;kompozíció&lt;/strong&gt;t is alkalmazhatunk. A prototípusos öröklésről majd máskor írok.&lt;/p&gt;

&lt;p&gt;Csak az &lt;strong&gt;egységbe foglalás&lt;/strong&gt;ba megyünk itt bele: &lt;strong&gt;az objektum-orientált paradigma lényege, hogy együtt kezeljük a változókat és a rájuk meghívandó függvényeket egy osztályban&lt;/strong&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;). Meglepően hangzik, de a JS-ben nincsenek tényleges osztályok, bár úgy programozunk, mintha lennének. Helyesebb inkább objektumokról beszélni (a függvények és a tömbök is objektumok).&lt;/p&gt;

&lt;p&gt;A C++-ban a hozzáférési szintek (&lt;strong&gt;public&lt;/strong&gt;, &lt;strong&gt;protected&lt;/strong&gt; és &lt;strong&gt;private&lt;/strong&gt;) segítségével szabályozhatjuk a tagváltozók és tagfüggvények külső hozzáférését. A C++-ban az osztályok esetén alapértelmezetten privát a hozzáférés, és csak az általunk írt publikus hozzáférésű metódusokon keresztül férhetünk hozzá a tagváltozókhoz. Ez a biztonságot szolgálja. A JavaScript-ben &lt;strong&gt;minden tagváltozó és metódus kívülről hozzáférhető&lt;/strong&gt; és módosítható. A &lt;strong&gt;bezárás&lt;/strong&gt; (&lt;strong&gt;closure&lt;/strong&gt;) alkalmazásával tehetjük priváttá (tehát kívülről nem hozzáférhetővé) az objektumok tulajdonságait.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;belekóstolás-a-javascript-programozási-nyelvbe&quot;&gt;Belekóstolás a JavaScript programozási nyelvbe&lt;/h2&gt;

&lt;p&gt;Ez a nagyon rövid bemutatás csak felületesen érinti a JS néhány jellemzőjét.&lt;/p&gt;

&lt;p&gt;A JavaScript (a későbbiekben: JS), a web nyelve, ECMAScript néven lett szabványosítva. A nevével ellentétben nincs köze a Java-hoz, és nem egyszerű szkriptnyelv, hanem sokkal több annál: egy dinamikus, objektum-orientált, általános célú programozási nyelv.&lt;/p&gt;

&lt;p&gt;A JavaScript &lt;strong&gt;interpretáló nyelv&lt;/strong&gt;, tehát a &lt;strong&gt;fordítás futási időben történik&lt;/strong&gt;: a JS értelmező sorról-sorra halad végig az utasításokon, értelmezi és végrehajtja azokat. Nincsen main() függvény. Ilyen egyszerű. Míg a C esetén először lefordítjuk a forrásfájlt, bináris, futtatható állományt készítve belőle (.exe Windows esetén), majd utána lefuttatunk.&lt;/p&gt;

&lt;p&gt;A legújabb szabvány az &lt;strong&gt;ECMAScript 2017&lt;/strong&gt; (ES8), tavaly az ES7, két éve az ES6 jelent meg. A &lt;strong&gt;webböngészők&lt;/strong&gt; az &lt;strong&gt;ECMAScript5&lt;/strong&gt;-nél újabb szabványokat még nem nagyon implementálták, éppen ezért kocázatos az újabb szabványok szerint kliens oldali kódot írni a webböngészők számára. Minden webböngésző tartalmaz &lt;strong&gt;JavaScript fordító&lt;/strong&gt;t (fordítómotornak is szokták hívni). A &lt;strong&gt;Node.js&lt;/strong&gt; szerver oldali JS keretrendszer például a Google Chrome V8 fordítómotorját használja. Később tervezek foglalkozni ezzel a framework-kkel is.&lt;/p&gt;

&lt;p&gt;A szerver oldalon viszont lehet ES6 szabvány szerint programozni. Például az egyszerűsített függvényszintaxis is használható: &lt;code class=&quot;highlighter-rouge&quot;&gt;(args) =&amp;gt; { /* utasítások */ }&lt;/code&gt; a &lt;code class=&quot;highlighter-rouge&quot;&gt;function (args) { /* utasítások */ }&lt;/code&gt; helyett. Ez az úgynevezett &lt;strong&gt;callback függvényeknél&lt;/strong&gt; hasznos, amelyeknek ugyanis nem kell nevet adni.&lt;/p&gt;

&lt;p&gt;A JS-ben &lt;strong&gt;nincsen &lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt; függvény&lt;/strong&gt;, bár lehet ilyen néven függvényt létrehozni. A &lt;strong&gt;változók típusa változhat&lt;/strong&gt;, ugyanis a JS gyengén típusos nyelv. Azonban a típusos nyelveknél, mint például a C vagy a C++, mindig meg kell adni a változók típusát:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;char&lt;/code&gt; (karakter, ASCII)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt; (egész szám)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt; (lebegőpontos, vagyis törtszám)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt; (kétszeres pontosságú lebegőpontos szám)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt; (sztring, szöveg típusú).&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt; (logikai: &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A JS-ben a &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;&lt;/strong&gt; kulcsszóval hozhatunk létre változókat, amelyekhez bármilyen típusú értéket, objektumot és függvényt is rendelhetünk. Az objektum tulajdonságainál alapértelmezett a &lt;strong&gt;public&lt;/strong&gt; hozzáférés, vagyis kívülről elérhetők és módosíthatók, de ez a viselkedés megváltoztatható. Private hozzáférés is lehetséges a JS-ben a &lt;strong&gt;bezárás&lt;/strong&gt;nak, illetve angulul &lt;strong&gt;closure&lt;/strong&gt;-nek nevezett eljárással.&lt;/p&gt;

&lt;p&gt;Az ES6-ban már lehet használni a &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; helyett a &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;&lt;/strong&gt;-et, aminek már &lt;strong&gt;blokkhatóköre van&lt;/strong&gt;, így egy csomó nem várt “mellékhatástól” megkímél bennünket. Például magának a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;-nek az értéke a kontextustól függ, azonban nem kötődik &lt;strong&gt;függvényhatókör&lt;/strong&gt;höz! A függvényhatókörről és a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;-ről a következő részben lesz szó.&lt;/p&gt;

&lt;p&gt;A JS-ben az aposztróf &lt;code class=&quot;highlighter-rouge&quot;&gt;'&lt;/code&gt; és az idézőjel &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;&lt;/code&gt; egyenértékű és a sztringek jelölésére használatos. De keverni ne keverjük őket! A &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;dupla idézőjeleket&quot;&lt;/code&gt; használjuk inkább. &lt;strong&gt;Unicode karakterkészletet használ&lt;/strong&gt; a JS, így majnem minden írott nyelvet támogat (az Unicode tábla maximum 1 millió 114 ezer 112 különféle betűt és jelet képes  eltárolni, jelenleg több mint 136 ezer karaktert tartalmaz). Ez hatalmas előny. A változónevekben és a függvény nevekben lehet ékezetes karakter is, de ez nem ajánlott programozói gyakorlat. Sőt lehetséges &lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt; nevű függvény/változó is: gondoljunk itt a &lt;strong&gt;jQuery&lt;/strong&gt; keretrendszerre, ahol van egy &lt;code class=&quot;highlighter-rouge&quot;&gt;$()&lt;/code&gt; nevű függvény. Az ékezetes karakterekkel nincsen probléma a JavaScript-ben, mert nem a szörnyű ASCII karaktertáblát használjunk.&lt;/p&gt;

&lt;p&gt;A JS-ben &lt;strong&gt;automatikus szemétgyűjtés&lt;/strong&gt; van (automatic garbage collection), tehát nem kell felszabadítanunk a lefoglalt tárhelyet (a C/C++ esetén csak a &lt;strong&gt;dinamikus memóriakezelés&lt;/strong&gt; esetén kell explicit, azaz magunknak elvégezni a lefoglalt memóraterület felszabadítását), hanem a fordító automatikusan elvégzi: ha egy objektum már nem elérhető – amikor a program már nem tud hivatkozni rá – a fordító automatikusan felszabadítja a lefoglalt memóriaterületet. Éppen ezért &lt;strong&gt;nincsen destruktor&lt;/strong&gt; függvény a JS-ben. &lt;strong&gt;Mutatók sincsenek&lt;/strong&gt;, tehát nem férhetünk hozzá a memóriacímekhez. Helyette &lt;strong&gt;referenciák vannak&lt;/strong&gt;, amiről a JS gondoskodik nekünk.&lt;/p&gt;

&lt;figcaption class=&quot;code-caption&quot;&gt;Az 1. JavaScript programod: Változók és függvények.&lt;/figcaption&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var valtozo = 10;
valtozo = &quot;Helló&quot;;
var f = function (s) {
    console.log(s + &quot;, világ!&quot;);
};
f(valtozo); //=&amp;gt; Helló, világ!
var nev = prompt(&quot;Add meg a keresztneved!&quot;);
console.log(&quot;Szia &quot; + nev + &quot;!&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A JavaScript-ben a &lt;strong&gt;primitív adattípusok&lt;/strong&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, logikai, szám és sztring) &lt;strong&gt;nem mutálódnak&lt;/strong&gt; (immutable), azaz létrehozásuk után az értékük már nem megváltoztatható! Ezek a nyelv legalacsonyabb szintű elemei.&lt;/p&gt;

&lt;p&gt;Hiába hívjuk meg a &lt;code class=&quot;highlighter-rouge&quot;&gt;toUpperCase()&lt;/code&gt; globális metódust (nagybetűssé alakítja a szöveget) a &lt;code class=&quot;highlighter-rouge&quot;&gt;nev&lt;/code&gt; változóra, a &lt;code class=&quot;highlighter-rouge&quot;&gt;nev&lt;/code&gt; változó értékét nem változtatja meg. Ha primitívekre hívunk meg függvényeket, illetve paraméterként átadjuk azokat függvénynek, akkor lokális másolat készül róluk (lefoglalódik számukra új memóriaterület) és a módosítások azokon hajtódnak végre. Az eredeti változó értéke változatlan marad:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var nev = &quot;Juliska&quot;;
console.log(nev.toUpperCase()); //=&amp;gt; JULISKA
console.log(nev); //=&amp;gt; Juliska
nev = nev.toUpperCase();
console.log(nev); //=&amp;gt; JULISKA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Az eredeti változó értéke nem változott! Egyetlen sztring metódus sem képes megváltoztatni azt, hanem egy új sztring értéket adnak vissza (“JULISKA”). Viszont új értéket adhatunk a &lt;code class=&quot;highlighter-rouge&quot;&gt;nev&lt;/code&gt; változónak. A megváltoztathatatlanság nem az értékadásra vonatkozik.&lt;/p&gt;

&lt;p&gt;A primitíveket érték szerint hasonlítjuk össze: &lt;strong&gt;két primitív azonos, ha értékük megegyezik&lt;/strong&gt; (két sztring egyenlő, ha hosszuk és minden egyes karakterük megegyezik):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;console.log(101 === 101); //=&amp;gt; true
console.log(false === false); //=&amp;gt; true
console.log(&quot;róka&quot; === &quot;róka&quot;); //=&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Az &lt;strong&gt;objektumok (beleértve a tömböket és a függvényeket)&lt;/strong&gt; másként viselkednek, mint a primitív típusok, ugyanis ezek &lt;strong&gt;mutálódnak&lt;/strong&gt; (mutable), azaz &lt;strong&gt;értékük megváltoztatható&lt;/strong&gt;. A primitív típusoknál:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var a = 3.14;
var b = a; // Az a változó értékét egy új változóba másoljuk.
a = 4; // Új értéket adunk az eredeti változónak.
alert(b) // 3.14-et ír ki, b nem változott meg.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;De mi a helyzet az objektumoknál, amelyeket &lt;strong&gt;referencia típus&lt;/strong&gt;oknak is nevezünk:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var a = [1, 2, 3]; // Egy 3 elemű tömb létrehozása.
var b = a; // A 'b' tömb ugyanarra a tömbre hivatkozik.
a[0] = 99; // Módosítsuk az eredeti tömböt!
alert(b); // A 'b' elemei is változnak: [99, 2, 3].
console.log(a === b); //=&amp;gt; true
// 'a' és 'b' ugyanarra a tömbre hivatkozik.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Amikor a &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;-hez rendeljük az &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; tömböt, akkor nem egy új másolat jön létre az &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; tömb objektumról, hanem csupán egy referencia, pontosabban a &lt;strong&gt;referencia egy másolata&lt;/strong&gt;, adódik át, ami az &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; tömb címére mutat. Tehát a &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; ugyanarra a tömbre egy második referencia. Tulajdonképpen &lt;strong&gt;sekély másolás&lt;/strong&gt; történik. Mély másolat készítéséhez explicite kell másolnunk az erdeti tömb összes elemét egy újabb memóraterületre (új tömböt hozunk létre):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var a = [1, 2, 3];
var b = [];
for(var i = 0; i &amp;lt; a.length; i++) {
    b[i] = a[i];
}
console.log(a === b); //=&amp;gt; false: különböző tömbök sosem egyenlők.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Az objektumokat &lt;strong&gt;referencia szerint&lt;/strong&gt; különböztetjük meg egymástól: &lt;strong&gt;két objektum akkor sem egyenlő, ha ugyanazokkal a tulajdonságokkal és értékekkel rendelkeznek&lt;/strong&gt;. Két tömb sem egyenlő, mégha megegyezik az összes elemük, és azok sorrendje is. &lt;strong&gt;Csak akkor azonos&lt;/strong&gt; két objektum érték, &lt;strong&gt;ha ugyanarra az objektumra hivatkoznak&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Referencia szerinti értékadás van az objektumok esetén, vagyis nem új másolatokat (magát az objektumot), hanem referenciákat adunk értékül ugyanarról az objektumról. A függvényeknek nem maguk az objektumok adódnak át, hanem csupán a rájuk mutató referenciák másolatai, amin keresztül a függvény hozzáférhet az objektumok megváltoztatható értékeihez. A primitív típusok értékei a &lt;strong&gt;verem&lt;/strong&gt;be (&lt;strong&gt;call stack&lt;/strong&gt;) kerülnek. Ha meghívunk egy függvényt egy primitív változóra, akkor egy lokális másolat készül róla, ami a függvény visszatérése után felszabadul. Az eredeti érték nem változik.&lt;/p&gt;

&lt;p&gt;Az objektumokat a &lt;strong&gt;heap&lt;/strong&gt;-ben (a &lt;strong&gt;dinamikusan lefoglalt&lt;/strong&gt; adatok tárterülete a memóriában) tároljuk el. Például tekintsük a &lt;code class=&quot;highlighter-rouge&quot;&gt;var o = { x:0 };&lt;/code&gt; kifejezést! Mi történik a futáskor? A heap-ben megfelelő méretű tárhely foglalódik le az objektum &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;x:0&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt; tárolására, majd az értékek inicializálódnak. A kifejezés értéke az objektumra mutató hivatkozás lesz &lt;code class=&quot;highlighter-rouge&quot;&gt;o&lt;/code&gt;-n keresztül. Az &lt;code class=&quot;highlighter-rouge&quot;&gt;o&lt;/code&gt; tehát nem magát az objektumot, csak egy referenciát tárol.&lt;/p&gt;

&lt;figcaption class=&quot;code-caption&quot;&gt;A 2. JavaScript példa: Az objektumok mutálódnak, míg a primitívek nem.&lt;/figcaption&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var s = &quot;Alma&quot;;
var o = { nev: &quot;Alma&quot; };

var foo = function (arg) {
    if(arg instanceof Object) { // Objektum-e az arg.
        arg.nev = &quot;Körte&quot;;
    } else {
        arg = &quot;Körte&quot;;
    }
};
foo(s);
foo(o);
console.log(s); //=&amp;gt; &quot;Alma&quot;
console.log(o); //=&amp;gt; &quot;{ nev: &quot;Körte&quot; }&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Összefoglalva tehát, &lt;strong&gt;a Javascript-ben kizárólag érték szerinti paraméterátadás van!&lt;/strong&gt; Az objektumoknál a &lt;strong&gt;referenciák másolatai&lt;/strong&gt; érték szerint adódnak át a függvényeknek (az objektum értékei mutálódnak), míg a primitív típusoknál &lt;strong&gt;lokális másolat&lt;/strong&gt; készül a változók értékeiről (az eredeti értékek nem mutálódnak).&lt;/p&gt;

&lt;p&gt;A JS-ben számos implicit (rejtett) típuskonverzió van. A változók típusa változhat a program futása során, amit az implicit típuskonverziók tesznek lehetővé:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var szam = 101, szoveg = &quot; kiskutya&quot;;
/* A + operátor az n számot sztringgé konvertálja
 * és összefűzi s-sel.
 */
var eredmeny = szam + szoveg;
console.log(eredmeny); //=&amp;gt; 101 kiskutya

/* A '-' operátor a sztringet számmá konvertálja/castolja
 * (ha tudja, különben undefined lesz) és kivonja belőle a 10-et.
 */
var x = &quot;62&quot; - 10; //=&amp;gt; 52

// De explicite mi is végezhetünk típuskonverziót.
var y = &quot;1500&quot;;
y = Number(y); // Számmá castoljuk a sztringet.
console.log(x + y); //=&amp;gt; 1552
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Amikor az egyenlőség és az egyenlőtlenség operátorokat használjuk, akkor életbevágóan fontos tisztában lenni az implicit típuskonverziókkal. Létezik az egyenlőség operátor (&lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt;) és a szigorú egyenlőség operátor (&lt;code class=&quot;highlighter-rouge&quot;&gt;===&lt;/code&gt;). Az utóbbi az azonosság szigorú definícióját használja és az alapján határozza meg a két operanduszának az azonosságát. A “sima” egyenlőség operátor (&lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt;) sokkal megengedőbb, hiszen engedélyezi a típuskonverziókat. A nemegyenlőség operátorból szintén kettő van: a “sima” (&lt;code class=&quot;highlighter-rouge&quot;&gt;!=&lt;/code&gt;) és szigorú (&lt;code class=&quot;highlighter-rouge&quot;&gt;!==&lt;/code&gt;) változat. Egy rövid kódrészleten bemutatva ez világosabb lesz:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;console.log(60 == &quot;60&quot;); //=&amp;gt; true, a &quot;60&quot;-ból szám lesz
console.log(60 === &quot;60&quot;); //=&amp;gt; false; szám és sztring különbözik
console.log(1 == true); //=&amp;gt; true
console.log(1 === true); //=&amp;gt; false; szám !== logikai érték
console.log(NaN == NaN); //=&amp;gt; false
console.log(NaN === NaN); //=&amp;gt; false

/* Ezzel a függvénnyel meghatározható, hogy NaN-e a vizsgált érték. */
console.log(isNaN(NaN)); //=&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A NaN érték (not-a-number) a “nem szám” jelölésére való. Akkor kapjuk értékül például, ha számot osztunk sztringgel: &lt;code class=&quot;highlighter-rouge&quot;&gt;10/&quot;a&quot;&lt;/code&gt;. Ez nyilvánvalóan értelmetlen eredményre vezet. A NaN semmilyen másik értékkel, de még önmagával sem azonos!&lt;/p&gt;

&lt;p&gt;A JS-ben az összes számot &lt;strong&gt;64-bites lebegőpontos formátum&lt;/strong&gt;ban reprezentálja az &lt;strong&gt;IEEE 754 szabvány&lt;/strong&gt; szerint. Ez azt jelenti, hogy maximum az olyan nagy számot képes eltárolni, mint a &lt;code class=&quot;highlighter-rouge&quot;&gt;±1.7976931348623157 x 10^308&lt;/code&gt;, és olyan kicsit, mint &lt;code class=&quot;highlighter-rouge&quot;&gt;5 x 10^-324&lt;/code&gt; (
&lt;strong&gt;alulcsordulás&lt;/strong&gt; történik amikor olyan kicsi a szám, hogy a számítógép nem tudja megkülönböztetni a 0-tól). A túlcsordulást szerinten nem kell magyaráznom.
A JavaScript számformátuma pontosan reprezentálja az egész számokat &lt;code class=&quot;highlighter-rouge&quot;&gt;-9007199254740992&lt;/code&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;-2^53&lt;/code&gt;) és &lt;code class=&quot;highlighter-rouge&quot;&gt;9007199254740992&lt;/code&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;2^53&lt;/code&gt;) között. Bizonyos operátorok viszont (mint például a tömbök indexelése vagy a bitenkénti műveletek) 32-bites egész számokkal működnek.&lt;/p&gt;

&lt;p&gt;A &lt;strong&gt;hexadecimális számok is támogatottak&lt;/strong&gt; az ECMAScript szabványban, viszont az oktális számok nem!&lt;/p&gt;

&lt;p&gt;Legyetek tisztában azzal is, hogy &lt;strong&gt;a lebegőpontos értékek bizonyos esetekben nem pontosak&lt;/strong&gt;, így ne lepődjetek meg, ha ezt tapasztaljátok:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;console.log(0.1 + 0.2); //=&amp;gt; 0.30000000000000004
console.log(0.1 + 0.2 == 0.3); //=&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;

&lt;p class=&quot;update&quot;&gt;Apró kiegészítés: két fontos dolgot kell itt pótolnom. Az egyik a változók elnevezési konvenciója. Ha a változó egyszerű szó, akkor nincs probléma, mivel minden betűjét kisbetűvel írjuk. Az összetett szavak esetén az első tagot mindig kisbetűvel írjuk, viszont az utána következő tagokat nagy kezdőbetűvel írjuk: &lt;code class=&quot;highlighter-rouge&quot;&gt;likeThis&lt;/code&gt;, illetve használhatunk egy alulvonást is a tagok elválasztására: &lt;code class=&quot;highlighter-rouge&quot;&gt;like_this&lt;/code&gt;. Ezt nem kötelező betartani, de erősen ajánlott. A másik dolog az úgynevezett &lt;strong&gt;“hamisértékek”&lt;/strong&gt; (falsy values) bevezetése a JS-ben. Ezek közé tartozik: a &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;, a &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, a &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, az &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;,  az &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;&quot;&lt;/code&gt; (üres sztring) és a &lt;code class=&quot;highlighter-rouge&quot;&gt;NaN&lt;/code&gt;. Ezek a kifejezésekben &lt;strong&gt;mindig hamisnak&lt;/strong&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;) &lt;strong&gt;értékelődnek ki&lt;/strong&gt; a szabvány szerint. (2017. augusztus 31.)&lt;/p&gt;

&lt;p&gt;Szerintem ennyi érdekesség elég.&lt;/p&gt;

&lt;p&gt;Egy részbe elég ennyi, majd a folytatom ezt az oktató sorozatot. A következő részekben ezekről tervezek írni:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;a függvényhatókör és blokkhatókör&lt;/li&gt;
  &lt;li&gt;a bezárás (closure)&lt;/li&gt;
  &lt;li&gt;a tömbök és a tömbszerű objektumok&lt;/li&gt;
  &lt;li&gt;hozzáférés az objektum tulajdonságaihoz&lt;/li&gt;
  &lt;li&gt;a &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; érték&lt;/li&gt;
  &lt;li&gt;objektumok és függvények létrehozása&lt;/li&gt;
  &lt;li&gt;a prototípusos öröklés&lt;/li&gt;
  &lt;li&gt;a JSON (JavaScript Object Notation)&lt;/li&gt;
  &lt;li&gt;a RegExp objektumok&lt;/li&gt;
  &lt;li&gt;a funkcionális programozás (&lt;code class=&quot;highlighter-rouge&quot;&gt;map()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;reduce()&lt;/code&gt; és &lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;a “use strict” pragma&lt;/li&gt;
  &lt;li&gt;a globális objektum (Window)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ez a cikksorozat csak bevezető jellegű. Ez alapján elindulhattok a JavaScript mélyebb megismeréséhez vezető úton.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;erősen-ajánlott-irodalom&quot;&gt;Erősen ajánlott irodalom&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;David Flanagan (2011). &lt;a href=&quot;http://shop.oreilly.com/product/9780596805531.do&quot;&gt;JavaScript: The Definitive Guide. 6th Edition.&lt;/a&gt; O’Reilly, USA.&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 29 Aug 2017 19:49:00 +0200</pubDate>
        <link>http://localhost:4000//tudomany/2017/08/29/javascript_01.html</link>
        <guid isPermaLink="true">http://localhost:4000//tudomany/2017/08/29/javascript_01.html</guid>
      </item>
    
      <item>
        <title>A kommentelési szabályzat és a szerzői jogok</title>
        <description>&lt;p class=&quot;update&quot;&gt;&lt;strong&gt;Frissítés&lt;/strong&gt;: Ha nem tudományos céllal idézel az írásaimból, akkor az idézet mellett kötelező feltüntetni a cikkre mutató linket! Ha a tudományos publikációdhoz idézel részeket, akkor  a tudományos hivatkozás szabályainak megfelelően hivatkozz a cikkre! Például így: &lt;em&gt;Gulácsi A. (2017). A cikk címe. A cikkre mutató weblink.&lt;/em&gt; Teljes cikk átvételéhez a saját írásos beleegyezésem szükséges. A hatályos jogszabály: az &lt;a href=&quot;https://net.jogtar.hu/jr/gen/hjegy_doc.cgi?docid=99900076.TV&quot;&gt;1999. évi LXXVI. törvény a szerzői jogokról.&lt;/a&gt; A bejegyzés címe is módosult. (2017. augusztus 27.)&lt;/p&gt;

&lt;p&gt;Ezeket a kommentelési szabályokat vezetem be a honlapomon:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Csak a témához kötődő hozzászólások engedélyezettek.&lt;/li&gt;
  &lt;li&gt;Pontosan „idézd”, hogy a bejegyzés mely részével (vagy részeivel) nem értesz egyet!&lt;/li&gt;
  &lt;li&gt;A személyeskedést, a trollkodást és a spammelést moderálással szankcionálom.&lt;/li&gt;
  &lt;li&gt;Mindent tudok a csaló érvelési technikákról (szalmabáb és társai). Ne is próbálkozz ilyenekkel!&lt;/li&gt;
  &lt;li&gt;A reklámokat és a nem biztonságos honlapokra mutató linkeket automatikusan eltávolítom. Egyébként lehet hasznos linkeket megosztani.&lt;/li&gt;
  &lt;li&gt;Itt nincsen semmilyen “politikai korrektség” (cenzúra, kettős mérce és társai), mint a liberális oldalakon.&lt;/li&gt;
  &lt;li&gt;Előmoderációt nem alkalmazok. Utólag ellenőrzöm a kommenteket.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;
A fenti pontokban lefektetett szabályok kötelező érvényűek mindenkire, kivétel nélkül.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Kelt: Szeged, 2017. augusztus 18.&lt;/p&gt;
</description>
        <pubDate>Fri, 18 Aug 2017 19:08:00 +0200</pubDate>
        <link>http://localhost:4000//2017/08/18/kommentelesi_szabalyzat.html</link>
        <guid isPermaLink="true">http://localhost:4000//2017/08/18/kommentelesi_szabalyzat.html</guid>
      </item>
    
      <item>
        <title>Hány cigány él Magyarországon?</title>
        <description>&lt;p&gt;A népszámlálások adataiból az derül ki, hogy Magyarországon 2001 és 2011 között 53%-kal, 205 720 főről 315 583 főre nőtt a cigányok száma. A Központi Statisztikai Hivatal (KSH) népszámlálásai a nemzetiségre, az anyanyelvre, a családi, baráti közösségben használt nyelvre, és a kulturális kötődésre kérdeznek rá, de ezekre a válaszadás megtagadható. A nemzetiségi hovatartozásukról nem nyilatkozók száma 2001 és 2011 között két és félszeresére, 543 317 főről 1 398 731 főre emelkedett.&lt;/p&gt;

&lt;p&gt;Az 1. táblázatban az 1893-2003 közötti időszakban végzett mintavételek, cigányösszeírások eredményeit foglaltam össze. A reprezentatív szociológiai mintavételek a cigányok tényleges, a lakókörnyezet minősítése által meghatározott számát becsülték meg 1971-ben, 1993-ban és 2003-ban. Az 1893. évi cigányösszeírás egyedülálló a maga nevében, mivel hazánkban a mai napig nem történt ehhez hasonló, kifejezetten a cigányok számbavételét célzó kutatás.&lt;/p&gt;

&lt;figcaption&gt;
1. táblázat: A magyarországi cigányok száma az 1893. évi cigányösszeírás és a szociológiai adatfelvételek alapján (Kertesi G. – Kézdi G. 1998, Kemény I. 2004). * A trianoni határokon belül.
&lt;/figcaption&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Év
        &lt;/th&gt;
        &lt;th&gt;Felmérések, ezer fő (középérték)
        &lt;/th&gt;
        &lt;th&gt;A modell szerint (ezer fő)
        &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;1893&lt;/td&gt;
        &lt;td&gt;59,982*&lt;/td&gt;
        &lt;td&gt;60&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;1971&lt;/td&gt;
        &lt;td&gt;270-370 (320)&lt;/td&gt;
        &lt;td&gt;300&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;1993&lt;/td&gt;
        &lt;td&gt;449-461 (455)&lt;/td&gt;
        &lt;td&gt;472&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;2003&lt;/td&gt;
        &lt;td&gt;520-650 (585)&lt;/td&gt;
        &lt;td&gt;580&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;2015&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;743&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;2020&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;823&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;A cigányság száma &lt;strong&gt;az elmúlt 110 évben megtízszereződött&lt;/strong&gt;: &lt;strong&gt;60 ezer főről 600 ezer főre gyarapodott 2003-ig&lt;/strong&gt;. 2003-ban az össznépesség 10 millió 142 ezer fő volt, melynek &lt;strong&gt;6%&lt;/strong&gt;-a a cigány nemzetiséghez tartozott. A népszámlálások kétszeresen alábecsülték a magyarországi cigányság tényleges számát!&lt;/p&gt;

&lt;p&gt;A cigányság 2015. évi számának becslésére és 2020-ig való előrejelzésére, egy egyszerű modellt készítettem. A rendelkezésre álló adatfelvételek adatpontjaira egy exponenciális függvényt illesztettem (1. ábra).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/Cigany_modell-min.jpg&quot; alt=&quot;A cigányok számának előrejelzése 2020-ig&quot; class=&quot;image2&quot; /&gt;&lt;/p&gt;
&lt;figcaption&gt;1. ábra: A cigányfelmérések eredményeire számolt exponenciális függvény (Hablicsek L. 2007). (Az R-ben írt kódot lásd az &lt;a href=&quot;https://github.com/SalsaBoy990/R-codes&quot; target=&quot;_blank&quot;&gt;R-codes&lt;/a&gt; gyűjteményemben.)
&lt;/figcaption&gt;

&lt;p&gt;Szépen látható, hogy a modell teljesen reprodukálja az 1893. évi összeírás értékét (60 ezer fő). &lt;strong&gt;A cigányság 2015-ös létszámára 743 ezer jött ki, míg 2020-ra meg fogja haladni a 800 ezer főt.&lt;/strong&gt; Az 1. táblázatban közöltem a modell alapján visszaszámolt értékeket, amelyek kitűnő egyezést mutatnak a valós értékekkel (r&lt;sup&gt;2&lt;/sup&gt;=0,99, p&amp;lt;0,001).&lt;/p&gt;

&lt;p&gt;A teljes termékenységi arányszám, vagyis az egy szülőképes korú (15-49 év) nőre eső gyerekszám, jó mutatja, hogy 1970 óta a magyar nők kevesebb gyereket szülnek (&lt;strong&gt;a teljes népesség körében 1,3 gyerek/nő&lt;/strong&gt;, de ebbe a cigányok is beletartoznak), mint amennyi a népességszám szinten tartásához (2,1 gyerek/szülőképes nő) elegendő lenne. Ezzel szemben, kizárólag &lt;strong&gt;a cigány nők esetén&lt;/strong&gt;, a termékenységi arányszám még mindig jelentősen meghaladja az átlagot (&lt;strong&gt;3,0&lt;/strong&gt;). A cigányság gyerekszáma gyorsabban nő, mint a magyaroké. A születő magyar gyerekek száma viszont az elöregedő magyar társadalom halálozási ütemét nem képes ellensúlyozni. A cigányság számaránya a népességen belül pedig tovább növekszik, de szerencsére &lt;strong&gt;az utóbbi tíz évben a cigány nők termékenységi arányszáma is lassan csökkenésnek indult&lt;/strong&gt; (2. táblázat).&lt;/p&gt;

&lt;figcaption&gt;
2. táblázat: A teljes női lakosság és a cigány nők termékenységi arányszámai, 1930-31 és 1999-2002 között (Janky B. 2005)
&lt;/figcaption&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Időszak
        &lt;/th&gt;
        &lt;th&gt;A teljes lakosság körében
        &lt;/th&gt;
        &lt;th&gt;A cigány nők körében
        &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;1930-31&lt;/td&gt;
        &lt;td&gt;2,8&lt;/td&gt;
        &lt;td&gt;n/a&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;1969-70&lt;/td&gt;
        &lt;td&gt;2,0&lt;/td&gt;
        &lt;td&gt;n/a&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;1990-93&lt;/td&gt;
        &lt;td&gt;1,8&lt;/td&gt;
        &lt;td&gt;3,3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;1995-98&lt;/td&gt;
        &lt;td&gt;1,4&lt;/td&gt;
        &lt;td&gt;3,3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;1999-2002&lt;/td&gt;
        &lt;td&gt;1,3&lt;/td&gt;
        &lt;td&gt;3,0&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Kizárólag a magyar nők esetén az egy szülőképes nőre jutó gyerekszám katasztrofálisan alacsony: 1,3 alatt van, mivel a cigányok szaporasága javít a statisztikán. Sajnos nem áll rendelkezésemre külön, csak a magyarokra vonatkozó adat. Így is egészen ritka adatokat adok közre.&lt;/p&gt;

&lt;p&gt;A teljes népesség és a cigányság élveszületési számának és arányának változásából kiderül, hogy &lt;strong&gt;2003-ban már minden hatodik újszülött cigány volt&lt;/strong&gt; (3. táblázat) (Kemény I. 2004). A cigányság korösszetétele is teljesen eltér a magyarságétól: &lt;strong&gt;a 15 év alattiak aránya a cigányok esetén megközelíti a 37%-ot&lt;/strong&gt;, míg &lt;strong&gt;a 60 éven felüliek aránya 3,9%&lt;/strong&gt;-ot tesz ki. Ez fiatalos korszerkezetet jelent. Az össznépesség esetén azonban, a cigányokhoz képest, &lt;strong&gt;a 15 éven aluliak aránya kevesebb, mint feleakkora&lt;/strong&gt; (16,1%), illetve &lt;strong&gt;a 60 éven felüliek aránya több, mint ötször akkora&lt;/strong&gt; (20,8%). A tizenöt éven aluliak aránya meghaladja a hatvan éven felüliekét, ami elöregedő korszerkezetre utal (4. táblázat).&lt;/p&gt;

&lt;figcaption&gt;
3. táblázat: Az élveszületések számának és arányának változása a teljes népesség és a cigányság körében 1971-2003 (Kemény I. 2004)
&lt;/figcaption&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Év
        &lt;/th&gt;
        &lt;th&gt;A teljes lakosság körében (ezer fő)
        &lt;/th&gt;
        &lt;th&gt;A cigány népesség körében
        &lt;/th&gt;
        &lt;th&gt;A cigány születések aránya
        &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;1971&lt;/td&gt;
        &lt;td&gt;151&lt;/td&gt;
        &lt;td&gt;10&lt;/td&gt;
        &lt;td&gt;&amp;lt;7%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;1993&lt;/td&gt;
        &lt;td&gt;116&lt;/td&gt;
        &lt;td&gt;13&lt;/td&gt;
        &lt;td&gt;&amp;gt;11%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;2003&lt;/td&gt;
        &lt;td&gt;94,647&lt;/td&gt;
        &lt;td&gt;15&lt;/td&gt;
        &lt;td&gt;15,8%&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;figcaption&gt;
4. táblázat: A cigány háztartásokban élő és az országos népesség a 0-14 év közötti és a 60 év feletti korcsoportjainak százalékos megoszlása 2003-ban (Kemény I. 2004)
&lt;/figcaption&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Korcsoport
        &lt;/th&gt;
        &lt;th&gt;A teljes népesség esetén
        &lt;/th&gt;
        &lt;th&gt;A cigányok körében
        &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;15 éven aluliak&lt;/td&gt;
        &lt;td&gt;16,1&lt;/td&gt;
        &lt;td&gt;36,8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;60 éven felüliek&lt;/td&gt;
        &lt;td&gt;20,8&lt;/td&gt;
        &lt;td&gt;3,9&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;A könnyebb összehasonlíthatóság kedvéért, a 2-3. ábrákon megjelenítettem a cigány és a magyar korfát a 2001. évi népszámlálás adatainak felhasználásával. Megjegyzés: a vízszintes tengely beosztása a két korfán eltérő. A magyar lakosság esetén 39 év az átlagéletkor, míg a cigányoknál csupán 25.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/Cigany_korfa-min.jpg&quot; alt=&quot;A cigányok számának előrejelzése 2020-ig&quot; class=&quot;image2&quot; /&gt;&lt;/p&gt;
&lt;figcaption&gt;2. ábra: A cigányságot jellemző korfa piramis alakú (KSH alapján). (Az R-ben írt kódot lásd az &lt;a href=&quot;https://github.com/SalsaBoy990/R-codes&quot; target=&quot;_blank&quot;&gt;R-codes&lt;/a&gt; gyűjteményemben.)
&lt;/figcaption&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/Magyar_korfa-min.jpg&quot; alt=&quot;A cigányok számának előrejelzése 2020-ig&quot; class=&quot;image2&quot; /&gt;&lt;/p&gt;
&lt;figcaption&gt;3. ábra: A magyarság korfája elöregedő korszerkezetet tükröz, urna alakú (KSH alapján). (Az R-ben írt kódot lásd az &lt;a href=&quot;https://github.com/SalsaBoy990/R-codes&quot; target=&quot;_blank&quot;&gt;R-codes&lt;/a&gt; gyűjteményemben.)
&lt;/figcaption&gt;

&lt;p&gt;&lt;strong&gt;A cigányok 86,9%-ának végzettsége általános iskola&lt;/strong&gt; (8 évfolyam vagy annál kevesebb), &lt;strong&gt;egyetemi, főiskolai végzettséggel mindössze 2607 fő rendelkezett&lt;/strong&gt; 2011-ben (5. táblázat).&lt;/p&gt;

&lt;figcaption&gt;
5. táblázat: A magyar és a cigány népesség megoszlása a legmagasabb befejezett iskolai végzettség szerint, 2011-ben (KSH alapján).
&lt;/figcaption&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Legmagasabb iskolai végzettség
        &lt;/th&gt;
        &lt;th&gt;Magyar (%)
        &lt;/th&gt;
        &lt;th&gt;Cigány (%)
        &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;8 évfolyamnál alacsonyabb&lt;/td&gt;
        &lt;td&gt;18,1&lt;/td&gt;
        &lt;td&gt;47,5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;8 évfolyam&lt;/td&gt;
        &lt;td&gt;23,5&lt;/td&gt;
        &lt;td&gt;39,4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Középfokú iskola érettségi nélkül,
szakmai oklevéllel&lt;/td&gt;
        &lt;td&gt;18,0&lt;/td&gt;
        &lt;td&gt;8,8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Érettségi&lt;/td&gt;
        &lt;td&gt;25,6&lt;/td&gt;
        &lt;td&gt;3,4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Főiskola, egyetem&lt;/td&gt;
        &lt;td&gt;14,7&lt;/td&gt;
        &lt;td&gt;0,8&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;A 6. táblázatból világossá válik, hogy a szocializmus időszakában a cigányok foglalkoztatottsága (különösen a férfiak) jóval magasabb volt, egészen a rendszerváltozásig. Onnantól kezdve drasztikusan leesett a cigányok foglalkoztatottsága, és az adatok szerint 2003-ig változatlan volt. &lt;strong&gt;1987-1993 között a férfiak esetén 45,6, a nők esetén 33, míg együtt 39,4%-kal csökkent a dolgozók aránya.&lt;/strong&gt;&lt;/p&gt;

&lt;figcaption&gt;
6. táblázat: A cigány férfiak és nők foglalkoztatottsága 1971-2003 között százalékban (Janky B. 2005). * Az 1971-es, 1993-as és 2003-as országos reprezentatív cigányvizsgálat alapján. N: a minta nagysága, az adatok a 15–54 éves nők és 15–59 éves férfiak százalékában értendők.
&lt;/figcaption&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;
        &lt;/th&gt;
        &lt;th&gt;1971
        &lt;/th&gt;
        &lt;th&gt;1978
        &lt;/th&gt;
        &lt;th&gt;1987
        &lt;/th&gt;
        &lt;th&gt;1993
        &lt;/th&gt;
        &lt;th&gt;2003
        &lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Férfiak&lt;/td&gt;
        &lt;td&gt;85,2&lt;/td&gt;
        &lt;td&gt;77,3&lt;/td&gt;
        &lt;td&gt;74,4&lt;/td&gt;
        &lt;td&gt;28,8&lt;/td&gt;
        &lt;td&gt;29,2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Nők&lt;/td&gt;
        &lt;td&gt;30,3&lt;/td&gt;
        &lt;td&gt;47,0&lt;/td&gt;
        &lt;td&gt;49,3&lt;/td&gt;
        &lt;td&gt;16,3&lt;/td&gt;
        &lt;td&gt;16,3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Együtt&lt;/td&gt;
        &lt;td&gt;n/a&lt;/td&gt;
        &lt;td&gt;62,0&lt;/td&gt;
        &lt;td&gt;62,0&lt;/td&gt;
        &lt;td&gt;22,6&lt;/td&gt;
        &lt;td&gt;22,7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;N&lt;/td&gt;
        &lt;td&gt;n/a&lt;/td&gt;
        &lt;td&gt;2875&lt;/td&gt;
        &lt;td&gt;3888&lt;/td&gt;
        &lt;td&gt;4842&lt;/td&gt;
        &lt;td&gt;3081&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;h2 id=&quot;végszó&quot;&gt;Végszó&lt;/h2&gt;
&lt;p&gt;A szocializmus alatt kevés volt a „közveszélyes munkakerülő”. A nehézipar, a bányászat sok alacsonyan képzett munkaerőt szívott fel, ami munkát adott, a cigányoknak is. Viszont a rendszerváltoztatás során szétbomlasztották a magyar ipart, jelentősen megnövelve ezzel a munkanélküliséget. Ma a szociális ellátórendszeren élősködnek az indiából származó cigányok (megélhetési gyerekcsinálók). A cigányokkal pedig csak keményen lehet bánni, hiszen a többségük csak az erőszakból ért.&lt;/p&gt;

&lt;p&gt;A cigányok beilleszkedési képtelenségét a cigányok viselkedésében kell keresni. Nem a magyarok szegregálják a cigányokat, hanem a cigányok magukat, mert &lt;strong&gt;nem akarnak integrálódni&lt;/strong&gt;!&lt;/p&gt;

&lt;p&gt;A bőnözőket nem luxusbörtönbe kell zárni, hanem kemény munkatáborba, hogy társadalmilag hasznos tevékenységet folytassanak. Ez majd lelohasztja a cigányok bűnözésre való hajlamát.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;felhasznált-irodalom&quot;&gt;Felhasznált irodalom&lt;/h2&gt;

&lt;ul class=&quot;no-decoration-18px&quot;&gt;
    &lt;li&gt;Hablicsek L. (2007). &lt;a href=&quot;http://demografia.hu/kiadvanyokonline/index.php/demografia/article/viewFile/540/483&quot; target=&quot;_blank&quot;&gt;Kísérleti számítások a roma lakosság területi jellemzőinek alakulására és 2021-ig történő előrebecslésére.&lt;/a&gt; – Demográfia 50(1), pp. 7-54. &lt;/li&gt;
    &lt;li&gt;Janky B. (2005). &lt;a href=&quot;www.szmm.gov.hu/download.php?ctag=download&amp;amp;docID=20471&quot; target=&quot;_blank&quot;&gt;A cigány nők társadalmi helyzete és termékenysége.&lt;/a&gt; – In. Nagy I. – Pongrácz T. –Tóth I. Gy. (szerk.): Szerepváltozások. Jelentés a nők és férfiak helyzetéről, 2005. – TÁRKI, Ifjúsági, Családügyi, Szociális és Esélyegyenlőségi Minisztérium, Budapest. pp. 136–148.&lt;/li&gt;
    &lt;li&gt;Kemény I. 2004: &lt;a href=&quot;http://www.demografia.hu/kiadvanyokonline/index.php/demografia/article/download/615/427&quot; target=&quot;_blank&quot;&gt;A magyarországi cigány népesség demográfiája.&lt;/a&gt; – Demográfia 47(3-4), pp. 335-346. &lt;/li&gt;
    &lt;li&gt;Kertesi G. – Kézdi G. 1998: &lt;a href=&quot;http://econ.core.hu/file/download/Kertesi_Kezdi/A_cigany_nepesseg_Mo-n.pdf&quot; target=&quot;_blank&quot;&gt;A cigány népesség Magyarországon.&lt;/a&gt; (Dokumentáció és adattár.) – Socio-typo, Budapest. 467 p. &lt;/li&gt;
    &lt;li&gt;&lt;br /&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.nepszamlalas2001.hu/hun/kotetek/04/tabhun/tabl01/load01.html&quot; target=&quot;_blank&quot;&gt;KSH 2001. évi népszámlálás. 1.1.  Nemzetiség.&lt;/a&gt; (letöltve: 2015-05-27)&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.nepszamlalas2001.hu/hun/kotetek/24/tables/loadcig2_1.html&quot; target=&quot;_blank&quot;&gt;KSH 2001. évi népszámlálás. Cigány, roma:
2.1. A népesség korév és nemek szerint, a nemek aránya.&lt;/a&gt; (letöltve: 2015-05-25)&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.nepszamlalas2001.hu/hun/kotetek/24/tables/loadmagy2_1.html&quot; target=&quot;_blank&quot;&gt;KSH 2001. évi népszámlálás. Magyar: 
2.1. A népesség korév és nemek szerint, a nemek aránya.&lt;/a&gt; (letöltve: 2015-05-25)&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.ksh.hu/nepszamlalas/docs/tablak/nemzetiseg/09_02_15_01.xls&quot; target=&quot;_blank&quot;&gt;KSH 2011. évi népszámlálás. 2.15.1. A népesség korcsoport, településtípus és nemek szerint, a nemek aránya, 2011.
&lt;/a&gt; (letöltve: 2015-05-27)&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.ksh.hu/nepszamlalas/docs/tablak/teruleti/00/00_2_1_6_1.xls&quot; target=&quot;_blank&quot;&gt;KSH 2011. évi népszámlálás. 2.1.6.1. A népesség nemzetiség, korcsoport, legmagasabb befejezett iskolai végzettség és nemek szerint, 2011.
&lt;/a&gt; (letöltve: 2015-05-26)&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.ksh.hu/nepszamlalas/docs/tablak/nemzetiseg/09_01_01.xls&quot; target=&quot;_blank&quot;&gt;KSH 2011. 1.1. A népesség a nemzetiségi hovatartozást befolyásoló tényezők szerint
&lt;/a&gt; (letöltve: 2015-05-27)&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 07 Aug 2017 17:27:00 +0200</pubDate>
        <link>http://localhost:4000//tudomany/2017/08/07/ciganyok_magyarorszagon.html</link>
        <guid isPermaLink="true">http://localhost:4000//tudomany/2017/08/07/ciganyok_magyarorszagon.html</guid>
      </item>
    
  </channel>
</rss>