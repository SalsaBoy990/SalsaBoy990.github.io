<!DOCTYPE html> <html lang="hu"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <meta http-equiv="X-UA-Compatible" content="ie=edge"> <title>Rövid elméleti bevezető a JavaScript nyelvbe</title> <meta name="description" content="A Google Earth Engine (GEE) felhő alapú platform általános bemutatása után, ebben a részben egy rövid betekintést nyújtok az objektum-orientált programozásba..."> <meta lang="hu-HU"> <meta property="og:title" content="Rövid elméleti bevezető a JavaScript nyelvbe"> <meta property="og:url" content="http://localhost:4000/tudomany/2017/08/29/javascript_01.html"> <meta property="og:site_name" content="Gulácsi András"> <meta property="og:description" content="A Google Earth Engine (GEE) felhő alapú platform általános bemutatása után, ebben a részben egy rövid betekintést nyújtok az objektum-orientált programozásba..."> <meta property="og:image" content="http://i346.photobucket.com/albums/p406/salsa990/android-chrome-512x512_zpsp4waxcic.png"> <meta property="og:type" content="website"> <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicon/apple-touch-icon.png"> <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon/favicon-32x32.png"> <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon/favicon-16x16.png"> <link rel="manifest" href="/assets/favicon/manifest.json"> <link rel="mask-icon" href="/assets/favicon/safari-pinned-tab.svg" color="#5bbad5"> <meta name="theme-color" content="#ffffff"> <link rel="canonical" href="http://localhost:4000/tudomany/2017/08/29/javascript_01.html"> <link rel="alternate" type="application/rss+xml" title="New Geographer" href="http://localhost:4000/feed.xml"> <link href="https://fonts.googleapis.com/css?family=PT+Serif|Playfair+Display:400,700&amp;subset=latin-ext" rel="stylesheet" type="text/css"> <!-- CSS style. New Geographer Redux theme (version: 6.2).--> <!--<link rel="stylesheet" type="text/css" href="/css/style-min.css"/>--> <link rel="stylesheet" type="text/css" href="/css/basic.css"/> <link rel="stylesheet" type="text/css" href="/css/classes.css"/> <link rel="stylesheet" type="text/css" href="/css/media.css"/> <link rel="stylesheet" type="text/css" href="/css/prism.css"/> <style>/** * Earth globe */ .globe { overflow: hidden; position: absolute; height: 140px; width: 140px; left: 50%; top: 90px; margin-bottom: 0px; border: 0.0625rem solid rgba(130, 130, 130, 0.5); border-radius: 50%; -webkit-transform: translate(-50%, -50%); transform: translate(-50%, -50%); } .globe svg { -webkit-animation: rotation 30s linear 0s infinite; animation: rotation 30s linear 0s infinite; } .globe svg path { stroke: rgba(255, 99, 0, 0.5); } @-webkit-keyframes rotation { from { -webkit-transform: translateX(0); transform: translateX(0); } from { -webkit-transform: translateX(-50%); transform: translateX(-50%); } } @keyframes rotation { from { -webkit-transform: translateX(0); transform: translateX(0); } from { -webkit-transform: translateX(-50%); transform: translateX(-50%); } } </style> <!-- Important JavaScript code comes here if there is any. --> <script src="/js/prism.js"></script> </head> <body> <div class="page-content"> <div class="wrapper"> <article class="post"> <header class="post-header"> <h1 class="post-title">Rövid elméleti bevezető a JavaScript nyelvbe</h1> <div class="post-date">Írta <a href="/about">Gulácsi András</a>. Dátum: 2017. augusztus 29.</div> </header> <div class="post-content"> <p>A Google Earth Engine (GEE) felhő alapú platform általános bemutatása után (<a href="http://www.newgeographer.com/tudomany/2017/08/07/google_earth_engine_01.html">itt elérhető az 1. rész</a>), ebben a részben egy rövid betekintést nyújtok az objektum-orientált programozásba és felhívom a figyelmet a JavaScript nyelv fontos jellemzőire, hogy hatékonyan ki tudjátok aknázni a GEE-ben rejlő lehetőségeket akár több száz GB-nyi adat gyors feldolgozására, minimális erőfeszítéssel.</p> <p><strong>Előzetes programozói tapasztalat erősen javallott</strong>, különben nem sokat értetek meg az egészből. Teljesen mindegy, hogy milyen nyelvet ismersz. A programozói gondolkodás az, ami valóban számít. Az alapelvek, a vezérlési szerkezetek, az algoritmusok stb. mind ugyanazok, csak a szintaxis és a szabvány más. Én a C nyelven keresztül tanultam meg a programozást, majd utána ismerkedtem meg a C++-szal és az objektum-orientált paradigmával. És csak ezt követően jött a <a href="https://www.javascript.com/">JavaScript</a> (JS).</p> <p>A bejegyzésemben megadott kódrészleteket pedig próbáljátok ki! Használhatjátok valamelyik böngésző konzolját (Google Chrome esetén: <code class="highlighter-rouge">F12</code>, Firefox esetén <code class="highlighter-rouge">CTRL+SHIFT+i</code>) vagy a GEE kódszerkesztőjét (ebben “strict mode”-ban használhatjátok a JS-t)!</p> <p>A programrészleteket egyben letölthetitek <a href="https://github.com/SalsaBoy990/EarthEngine/blob/master/tutorial2.js">innen</a>.</p> <h2 id="bevezetés-az-objektum-orientált-programozásba">Bevezetés az objektum-orientált programozásba</h2> <p>Ez bevezető csak egy nagyon kurta betekintést nyújt az objektum orientált szemléletbe.</p> <p>A programozás célja mindig egy összetett probléma megoldása a számítógép számítási kapacitásának a lehető leghatékonyabb kihasználásával. A programozás során ezt <strong>az összetett problémát fel kell bontanunk kisebb részproblémákra/részlépésekre</strong> (például az adatok bekérése, a bemenet ellenőrzése, különböző műveletek, amelyeket az adatokon végzünk, adatok mentése stb.), amelyek megoldására külön függvényeket írunk. Ezáltal átláthatóvá válik számunkra a program működése.</p> <p>A “hagyományos” nyelvekben (mint például a C-ben) megtanultuk, hogy <strong>a változókat és a függvényeket külön kezeljük</strong>, valamint a függvényeket a változók argumentumként való átadásával hívjuk meg. (Az argumentum az az érték, amit bemenő paraméterként megadunk egy függvénynek.). Lehet érték szerint, mutató szerint és referencia szerint paramétert átadni. A JavaScript-ben <strong>kizárólag érték szerinti paraméterátadás</strong> létezik (az objektum referenciák is érték szerint adódnak át)!</p> <p>Az objektum orientált nyelveknek három alapelve van:</p> <ol> <li><strong>egységbezárás</strong> / enkapszuláció (encapsulation)</li> <li><strong>öröklés</strong> (inheritance)</li> <li><strong>többalakúság</strong> / polimorfizmus (polymorphism)</li> </ol> <p>A klasszikus öröklés (és a polimorfizmus) JavaScript-ben is imitálható, de valójában kizárólag csak <strong>prototípusos öröklés</strong> létezik a JS-ben. Öröklés helyett <strong>kompozíció</strong>t is alkalmazhatunk. A prototípusos öröklésről majd máskor írok.</p> <p>Csak az <strong>egységbe foglalás</strong>ba megyünk itt bele: <strong>az objektum-orientált paradigma lényege, hogy együtt kezeljük a változókat és a rájuk meghívandó függvényeket egy osztályban</strong> (<code class="highlighter-rouge">class</code>). Meglepően hangzik, de a JS-ben nincsenek tényleges osztályok, bár úgy programozunk, mintha lennének. Helyesebb inkább objektumokról beszélni (a függvények és a tömbök is objektumok).</p> <p>A C++-ban a hozzáférési szintek (<strong>public</strong>, <strong>protected</strong> és <strong>private</strong>) segítségével szabályozhatjuk a tagváltozók és tagfüggvények külső hozzáférését. A C++-ban az osztályok esetén alapértelmezetten privát a hozzáférés, és csak az általunk írt publikus hozzáférésű metódusokon keresztül férhetünk hozzá a tagváltozókhoz. Ez a biztonságot szolgálja. A JavaScript-ben <strong>minden tagváltozó és metódus kívülről hozzáférhető</strong> és módosítható. A <strong>bezárás</strong> (<strong>closure</strong>) alkalmazásával tehetjük priváttá (tehát kívülről nem hozzáférhetővé) az objektumok tulajdonságait.</p> <h2 id="belekóstolás-a-javascript-programozási-nyelvbe">Belekóstolás a JavaScript programozási nyelvbe</h2> <p>Ez a nagyon rövid bemutatás csak felületesen érinti a JS néhány jellemzőjét.</p> <p>A JavaScript (a későbbiekben: JS), a web nyelve, ECMAScript néven lett szabványosítva. A nevével ellentétben nincs köze a Java-hoz, és nem egyszerű szkriptnyelv, hanem sokkal több annál: egy dinamikus, objektum-orientált, általános célú programozási nyelv.</p> <p>A JavaScript <strong>interpretáló nyelv</strong>, tehát a <strong>fordítás futási időben történik</strong>: a JS értelmező sorról-sorra halad végig az utasításokon, értelmezi és végrehajtja azokat. Nincsen main() függvény. Ilyen egyszerű. Míg a C esetén először lefordítjuk a forrásfájlt, bináris, futtatható állományt készítve belőle (.exe Windows esetén), majd utána lefuttatunk.</p> <p>A legújabb szabvány az <strong>ECMAScript 2017</strong> (ES8), tavaly az ES7, két éve az ES6 jelent meg. A <strong>webböngészők</strong> az <strong>ECMAScript5</strong>-nél újabb szabványokat még nem nagyon implementálták, éppen ezért kocázatos az újabb szabványok szerint kliens oldali kódot írni a webböngészők számára. Minden webböngésző tartalmaz <strong>JavaScript fordító</strong>t (fordítómotornak is szokták hívni). A <strong>Node.js</strong> szerver oldali JS keretrendszer például a Google Chrome V8 fordítómotorját használja. Később tervezek foglalkozni ezzel a framework-kkel is.</p> <p>A szerver oldalon viszont lehet ES6 szabvány szerint programozni. Például az egyszerűsített függvényszintaxis is használható: <code class="highlighter-rouge">(args) =&gt; { /* utasítások */ }</code> a <code class="highlighter-rouge">function (args) { /* utasítások */ }</code> helyett. Ez az úgynevezett <strong>callback függvényeknél</strong> hasznos, amelyeknek ugyanis nem kell nevet adni.</p> <p>A JS-ben <strong>nincsen <code class="highlighter-rouge">main()</code> függvény</strong>, bár lehet ilyen néven függvényt létrehozni. A <strong>változók típusa változhat</strong>, ugyanis a JS gyengén típusos nyelv. Azonban a típusos nyelveknél, mint például a C vagy a C++, mindig meg kell adni a változók típusát:</p> <ul> <li><code class="highlighter-rouge">char</code> (karakter, ASCII)</li> <li><code class="highlighter-rouge">int</code> (egész szám)</li> <li><code class="highlighter-rouge">float</code> (lebegőpontos, vagyis törtszám)</li> <li><code class="highlighter-rouge">double</code> (kétszeres pontosságú lebegőpontos szám)</li> <li><code class="highlighter-rouge">string</code> (sztring, szöveg típusú).</li> <li><code class="highlighter-rouge">bool</code> (logikai: <code class="highlighter-rouge">true</code>/<code class="highlighter-rouge">false</code>)</li> </ul> <p>A JS-ben a <strong><code class="highlighter-rouge">var</code></strong> kulcsszóval hozhatunk létre változókat, amelyekhez bármilyen típusú értéket, objektumot és függvényt is rendelhetünk. Az objektum tulajdonságainál alapértelmezett a <strong>public</strong> hozzáférés, vagyis kívülről elérhetők és módosíthatók, de ez a viselkedés megváltoztatható. Private hozzáférés is lehetséges a JS-ben a <strong>bezárás</strong>nak, illetve angulul <strong>closure</strong>-nek nevezett eljárással.</p> <p>Az ES6-ban már lehet használni a <code class="highlighter-rouge">var</code> helyett a <strong><code class="highlighter-rouge">let</code></strong>-et, aminek már <strong>blokkhatóköre van</strong>, így egy csomó nem várt “mellékhatástól” megkímél bennünket. Például magának a <code class="highlighter-rouge">this</code>-nek az értéke a kontextustól függ, azonban nem kötődik <strong>függvényhatókör</strong>höz! A függvényhatókörről és a <code class="highlighter-rouge">this</code>-ről a következő részben lesz szó.</p> <p>A JS-ben az aposztróf <code class="highlighter-rouge">'</code> és az idézőjel <code class="highlighter-rouge">"</code> egyenértékű és a sztringek jelölésére használatos. De keverni ne keverjük őket! A <code class="highlighter-rouge">"dupla idézőjeleket"</code> használjuk inkább. <strong>Unicode karakterkészletet használ</strong> a JS, így majnem minden írott nyelvet támogat (az Unicode tábla maximum 1 millió 114 ezer 112 különféle betűt és jelet képes eltárolni, jelenleg több mint 136 ezer karaktert tartalmaz). Ez hatalmas előny. A változónevekben és a függvény nevekben lehet ékezetes karakter is, de ez nem ajánlott programozói gyakorlat. Sőt lehetséges <code class="highlighter-rouge">$</code> nevű függvény/változó is: gondoljunk itt a <strong>jQuery</strong> keretrendszerre, ahol van egy <code class="highlighter-rouge">$()</code> nevű függvény. Az ékezetes karakterekkel nincsen probléma a JavaScript-ben, mert nem a szörnyű ASCII karaktertáblát használjunk.</p> <p>A JS-ben <strong>automatikus szemétgyűjtés</strong> van (automatic garbage collection), tehát nem kell felszabadítanunk a lefoglalt tárhelyet (a C/C++ esetén csak a <strong>dinamikus memóriakezelés</strong> esetén kell explicit, azaz magunknak elvégezni a lefoglalt memóraterület felszabadítását), hanem a fordító automatikusan elvégzi: ha egy objektum már nem elérhető – amikor a program már nem tud hivatkozni rá – a fordító automatikusan felszabadítja a lefoglalt memóriaterületet. Éppen ezért <strong>nincsen destruktor</strong> függvény a JS-ben. <strong>Mutatók sincsenek</strong>, tehát nem férhetünk hozzá a memóriacímekhez. Helyette <strong>referenciák vannak</strong>, amiről a JS gondoskodik nekünk.</p> <figcaption class="code-caption">Az 1. JavaScript programod: Változók és függvények.</figcaption><pre><code class="language-javascript">var valtozo = 10;
valtozo = "Helló";
var f = function (s) {
    console.log(s + ", világ!");
};
f(valtozo); //=&gt; Helló, világ!
var nev = prompt("Add meg a keresztneved!");
console.log("Szia " + nev + "!");
</code></pre><p>A JavaScript-ben a <strong>primitív adattípusok</strong> (<code class="highlighter-rouge">undefined</code>, <code class="highlighter-rouge">null</code>, logikai, szám és sztring) <strong>nem mutálódnak</strong> (immutable), azaz létrehozásuk után az értékük már nem megváltoztatható! Ezek a nyelv legalacsonyabb szintű elemei.</p> <p>Hiába hívjuk meg a <code class="highlighter-rouge">toUpperCase()</code> globális metódust (nagybetűssé alakítja a szöveget) a <code class="highlighter-rouge">nev</code> változóra, a <code class="highlighter-rouge">nev</code> változó értékét nem változtatja meg. Ha primitívekre hívunk meg függvényeket, illetve paraméterként átadjuk azokat függvénynek, akkor lokális másolat készül róluk (lefoglalódik számukra új memóriaterület) és a módosítások azokon hajtódnak végre. Az eredeti változó értéke változatlan marad:</p><pre><code class="language-javascript">var nev = "Juliska";
console.log(nev.toUpperCase()); //=&gt; JULISKA
console.log(nev); //=&gt; Juliska
nev = nev.toUpperCase();
console.log(nev); //=&gt; JULISKA
</code></pre><p>Az eredeti változó értéke nem változott! Egyetlen sztring metódus sem képes megváltoztatni azt, hanem egy új sztring értéket adnak vissza (“JULISKA”). Viszont új értéket adhatunk a <code class="highlighter-rouge">nev</code> változónak. A megváltoztathatatlanság nem az értékadásra vonatkozik.</p> <p>A primitíveket érték szerint hasonlítjuk össze: <strong>két primitív azonos, ha értékük megegyezik</strong> (két sztring egyenlő, ha hosszuk és minden egyes karakterük megegyezik):</p><pre><code class="language-javascript">console.log(101 === 101); //=&gt; true
console.log(false === false); //=&gt; true
console.log("róka" === "róka"); //=&gt; true
</code></pre><p>Az <strong>objektumok (beleértve a tömböket és a függvényeket)</strong> másként viselkednek, mint a primitív típusok, ugyanis ezek <strong>mutálódnak</strong> (mutable), azaz <strong>értékük megváltoztatható</strong>. A primitív típusoknál:</p><pre><code class="language-javascript">var a = 3.14;
var b = a; // Az a változó értékét egy új változóba másoljuk.
a = 4; // Új értéket adunk az eredeti változónak.
alert(b) // 3.14-et ír ki, b nem változott meg.
</code></pre><p>De mi a helyzet az objektumoknál, amelyeket <strong>referencia típus</strong>oknak is nevezünk:</p><pre><code class="language-javascript">var a = [1, 2, 3]; // Egy 3 elemű tömb létrehozása.
var b = a; // A 'b' tömb ugyanarra a tömbre hivatkozik.
a[0] = 99; // Módosítsuk az eredeti tömböt!
alert(b); // A 'b' elemei is változnak: [99, 2, 3].
console.log(a === b); //=&gt; true
// 'a' és 'b' ugyanarra a tömbre hivatkozik.
</code></pre><p>Amikor a <code class="highlighter-rouge">b</code>-hez rendeljük az <code class="highlighter-rouge">a</code> tömböt, akkor nem egy új másolat jön létre az <code class="highlighter-rouge">a</code> tömb objektumról, hanem csupán egy referencia, pontosabban a <strong>referencia egy másolata</strong>, adódik át, ami az <code class="highlighter-rouge">a</code> tömb címére mutat. Tehát a <code class="highlighter-rouge">b</code> ugyanarra a tömbre egy második referencia. Tulajdonképpen <strong>sekély másolás</strong> történik. Mély másolat készítéséhez explicite kell másolnunk az erdeti tömb összes elemét egy újabb memóraterületre (új tömböt hozunk létre):</p><pre><code class="language-javascript">var a = [1, 2, 3];
var b = [];
for(var i = 0; i &lt; a.length; i++) {
    b[i] = a[i];
}
console.log(a === b); //=&gt; false: különböző tömbök sosem egyenlők.
</code></pre><p>Az objektumokat <strong>referencia szerint</strong> különböztetjük meg egymástól: <strong>két objektum akkor sem egyenlő, ha ugyanazokkal a tulajdonságokkal és értékekkel rendelkeznek</strong>. Két tömb sem egyenlő, mégha megegyezik az összes elemük, és azok sorrendje is. <strong>Csak akkor azonos</strong> két objektum érték, <strong>ha ugyanarra az objektumra hivatkoznak</strong>.</p> <p>Referencia szerinti értékadás van az objektumok esetén, vagyis nem új másolatokat (magát az objektumot), hanem referenciákat adunk értékül ugyanarról az objektumról. A függvényeknek nem maguk az objektumok adódnak át, hanem csupán a rájuk mutató referenciák másolatai, amin keresztül a függvény hozzáférhet az objektumok megváltoztatható értékeihez. A primitív típusok értékei a <strong>verem</strong>be (<strong>call stack</strong>) kerülnek. Ha meghívunk egy függvényt egy primitív változóra, akkor egy lokális másolat készül róla, ami a függvény visszatérése után felszabadul. Az eredeti érték nem változik.</p> <p>Az objektumokat a <strong>heap</strong>-ben (a <strong>dinamikusan lefoglalt</strong> adatok tárterülete a memóriában) tároljuk el. Például tekintsük a <code class="highlighter-rouge">var o = { x:0 };</code> kifejezést! Mi történik a futáskor? A heap-ben megfelelő méretű tárhely foglalódik le az objektum <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">x:0</span><span class="w"> </span><span class="p">}</span></code> tárolására, majd az értékek inicializálódnak. A kifejezés értéke az objektumra mutató hivatkozás lesz <code class="highlighter-rouge">o</code>-n keresztül. Az <code class="highlighter-rouge">o</code> tehát nem magát az objektumot, csak egy referenciát tárol.</p> <figcaption class="code-caption">A 2. JavaScript példa: Az objektumok mutálódnak, míg a primitívek nem.</figcaption><pre><code class="language-javascript">var s = "Alma";
var o = { nev: "Alma" };

var foo = function (arg) {
    if(arg instanceof Object) { // Objektum-e az arg.
        arg.nev = "Körte";
    } else {
        arg = "Körte";
    }
};
foo(s);
foo(o);
console.log(s); //=&gt; "Alma"
console.log(o); //=&gt; "{ nev: "Körte" }"
</code></pre><p>Összefoglalva tehát, <strong>a Javascript-ben kizárólag érték szerinti paraméterátadás van!</strong> Az objektumoknál a <strong>referenciák másolatai</strong> érték szerint adódnak át a függvényeknek (az objektum értékei mutálódnak), míg a primitív típusoknál <strong>lokális másolat</strong> készül a változók értékeiről (az eredeti értékek nem mutálódnak).</p> <p>A JS-ben számos implicit (rejtett) típuskonverzió van. A változók típusa változhat a program futása során, amit az implicit típuskonverziók tesznek lehetővé:</p><pre><code class="language-javascript">var szam = 101, szoveg = " kiskutya";
/* A + operátor az n számot sztringgé konvertálja
 * és összefűzi s-sel.
 */
var eredmeny = szam + szoveg;
console.log(eredmeny); //=&gt; 101 kiskutya

/* A '-' operátor a sztringet számmá konvertálja/castolja
 * (ha tudja, különben undefined lesz) és kivonja belőle a 10-et.
 */
var x = "62" - 10; //=&gt; 52

// De explicite mi is végezhetünk típuskonverziót.
var y = "1500";
y = Number(y); // Számmá castoljuk a sztringet.
console.log(x + y); //=&gt; 1552
</code></pre><p>Amikor az egyenlőség és az egyenlőtlenség operátorokat használjuk, akkor életbevágóan fontos tisztában lenni az implicit típuskonverziókkal. Létezik az egyenlőség operátor (<code class="highlighter-rouge">==</code>) és a szigorú egyenlőség operátor (<code class="highlighter-rouge">===</code>). Az utóbbi az azonosság szigorú definícióját használja és az alapján határozza meg a két operanduszának az azonosságát. A “sima” egyenlőség operátor (<code class="highlighter-rouge">==</code>) sokkal megengedőbb, hiszen engedélyezi a típuskonverziókat. A nemegyenlőség operátorból szintén kettő van: a “sima” (<code class="highlighter-rouge">!=</code>) és szigorú (<code class="highlighter-rouge">!==</code>) változat. Egy rövid kódrészleten bemutatva ez világosabb lesz:</p><pre><code class="language-javascript">console.log(60 == "60"); //=&gt; true, a "60"-ból szám lesz
console.log(60 === "60"); //=&gt; false; szám és sztring különbözik
console.log(1 == true); //=&gt; true
console.log(1 === true); //=&gt; false; szám !== logikai érték
console.log(NaN == NaN); //=&gt; false
console.log(NaN === NaN); //=&gt; false

/* Ezzel a függvénnyel meghatározható, hogy NaN-e a vizsgált érték. */
console.log(isNaN(NaN)); //=&gt; true
</code></pre><p>A NaN érték (not-a-number) a “nem szám” jelölésére való. Akkor kapjuk értékül például, ha számot osztunk sztringgel: <code class="highlighter-rouge">10/"a"</code>. Ez nyilvánvalóan értelmetlen eredményre vezet. A NaN semmilyen másik értékkel, de még önmagával sem azonos!</p> <p>A JS-ben az összes számot <strong>64-bites lebegőpontos formátum</strong>ban reprezentálja az <strong>IEEE 754 szabvány</strong> szerint. Ez azt jelenti, hogy maximum az olyan nagy számot képes eltárolni, mint a <code class="highlighter-rouge">±1.7976931348623157 x 10^308</code>, és olyan kicsit, mint <code class="highlighter-rouge">5 x 10^-324</code> ( <strong>alulcsordulás</strong> történik amikor olyan kicsi a szám, hogy a számítógép nem tudja megkülönböztetni a 0-tól). A túlcsordulást szerinten nem kell magyaráznom. A JavaScript számformátuma pontosan reprezentálja az egész számokat <code class="highlighter-rouge">-9007199254740992</code> (<code class="highlighter-rouge">-2^53</code>) és <code class="highlighter-rouge">9007199254740992</code> (<code class="highlighter-rouge">2^53</code>) között. Bizonyos operátorok viszont (mint például a tömbök indexelése vagy a bitenkénti műveletek) 32-bites egész számokkal működnek.</p> <p>A <strong>hexadecimális számok is támogatottak</strong> az ECMAScript szabványban, viszont az oktális számok nem!</p> <p>Legyetek tisztában azzal is, hogy <strong>a lebegőpontos értékek bizonyos esetekben nem pontosak</strong>, így ne lepődjetek meg, ha ezt tapasztaljátok:</p><pre><code class="language-javascript">console.log(0.1 + 0.2); //=&gt; 0.30000000000000004
console.log(0.1 + 0.2 == 0.3); //=&gt; false
</code></pre><p class="update">Apró kiegészítés: két fontos dolgot kell itt pótolnom. Az egyik a változók elnevezési konvenciója. Ha a változó egyszerű szó, akkor nincs probléma, mivel minden betűjét kisbetűvel írjuk. Az összetett szavak esetén az első tagot mindig kisbetűvel írjuk, viszont az utána következő tagokat nagy kezdőbetűvel írjuk: <code class="highlighter-rouge">likeThis</code>, illetve használhatunk egy alulvonást is a tagok elválasztására: <code class="highlighter-rouge">like_this</code>. Ezt nem kötelező betartani, de erősen ajánlott. A másik dolog az úgynevezett <strong>“hamisértékek”</strong> (falsy values) bevezetése a JS-ben. Ezek közé tartozik: a <code class="highlighter-rouge">false</code>, a <code class="highlighter-rouge">0</code>, a <code class="highlighter-rouge">null</code>, az <code class="highlighter-rouge">undefined</code>, az <code class="highlighter-rouge">""</code> (üres sztring) és a <code class="highlighter-rouge">NaN</code>. Ezek a kifejezésekben <strong>mindig hamisnak</strong> (<code class="highlighter-rouge">false</code>) <strong>értékelődnek ki</strong> a szabvány szerint. (2017. augusztus 31.)</p> <p>Egy részbe elég ennyi, majd a folytatom ezt az oktató sorozatot. A következő részekben ezekről tervezek írni:</p> <ul> <li>a függvényhatókör és blokkhatókör</li> <li>a bezárás (closure)</li> <li>a tömbök és a tömbszerű objektumok</li> <li>hozzáférés az objektum tulajdonságaihoz</li> <li>a <code class="highlighter-rouge">this</code> érték</li> <li>objektumok és függvények létrehozása</li> <li>a prototípusos öröklés</li> <li>a JSON (JavaScript Object Notation)</li> <li>a RegExp objektumok</li> <li>a funkcionális programozás (<code class="highlighter-rouge">map()</code>, <code class="highlighter-rouge">reduce()</code> és <code class="highlighter-rouge">filter()</code>)</li> <li>a “use strict” pragma</li> <li>a globális objektum (Window)</li> </ul> <p>Ez a cikksorozat csak bevezető jellegű. Ez alapján elindulhattok a JavaScript mélyebb megismeréséhez vezető úton.</p> <h2 id="erősen-ajánlott-irodalom">Erősen ajánlott irodalom</h2> <ol> <li><em>David Flanagan</em> (2011). <a href="http://shop.oreilly.com/product/9780596805531.do">JavaScript: The Definitive Guide. 6th Edition.</a> O’Reilly, USA.</li> </ol> </div> <aside class="post-content" role="complementary"> <h2>Kapcsolódó bejegyzések</h2> <div> <ul> <li> <a class="writings" href="/tudomany/2017/11/05/big_data.html"><span>A Big Data és a felhő alapú számítástechnika a földrajzban</span></a> </li> <li> <a class="writings" href="/tudomany/2017/09/20/javascript_03.html"><span>Rövid elméleti bevezető a JavaScript nyelvbe, 3. rész.</span></a> </li> <li> <a class="writings" href="/tudomany/2017/09/03/javascript_02.html"><span>Rövid elméleti bevezető a JavaScript nyelvbe, 2. rész.</span></a> </li> <li> <a class="writings" href="/tudomany/2017/08/07/google_earth_engine_01.html"><span>A Google Earth Engine felhő alapú platform alkalmazása a geoinformatikában, 1. rész.</span></a> </li> </ul> </div> </aside> </article> <div class="navigation-menu"> <ul id="collapsed-menu"> <li><span id="menu-button"> <svg height="15px" width="18px" viewBox="0 0 18 15"> <path fill="#606060" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/> <path fill="#606060" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/> <path fill="#606060" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/> </svg> Menü</span> <ul id="dropdown"> <li> <a href="http://localhost:4000">Kezdőlap</a> </li> <li> <a href="/writings/">Írásaim</a> </li> <li> <a href="/about/">Magamról</a> </li> <li> <a href="/book/">Könyv</a> </li> <li> <a href="https://www.facebook.com/newgeographer">Közösség</a> </li> </ul> </li> </ul> <ul id="full-menu"> <li> <a href="http://localhost:4000">Kezdőlap</a> </li> <li> <a href="/writings/">Írásaim</a> </li> <li> <a href="/about/">Magamról</a> </li> <li> <a href="/book/">Könyv</a> </li> <li> <a href="https://www.facebook.com/newgeographer">Közösség</a> </li> </ul> </div> <!--<span> <div class="copyright"> <span>&copy; Gulácsi András 2017</span> </div></span> <span id="top" style="float:right;color:#828282">Fel<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#828282" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"> <line x1="12" y1="20" x2="12" y2="4"/> <polyline points="6 10 12 4 18 10"/> </svg></span>--> </div> </div> <!-- jQuery here --> <script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"> </script> <script type="text/javascript"> $(document).ready(function () { $("#menu-button").on("click", function() { $("#dropdown").slideToggle(); }); $('table tr:even').addClass('color'); $("table tr").filter(":first").css("font-weight", "600"); }); </script> </body> </html>
